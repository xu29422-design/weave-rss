"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(action-browser)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DirectChatTransport: () => (/* binding */ DirectChatTransport),\n/* harmony export */   DownloadError: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolApprovalError: () => (/* binding */ InvalidToolApprovalError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoSpeechGeneratedError: () => (/* binding */ NoSpeechGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallNotFoundForApprovalError: () => (/* binding */ ToolCallNotFoundForApprovalError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolLoopAgent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UIMessageStreamError: () => (/* binding */ UIMessageStreamError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   addToolInputExamplesMiddleware: () => (/* binding */ addToolInputExamplesMiddleware),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createAgentUIStream: () => (/* binding */ createAgentUIStream),\n/* harmony export */   createAgentUIStreamResponse: () => (/* binding */ createAgentUIStreamResponse),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultEmbeddingSettingsMiddleware: () => (/* binding */ defaultEmbeddingSettingsMiddleware),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ experimental_generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractJsonMiddleware: () => (/* binding */ extractJsonMiddleware),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateImage: () => (/* binding */ generateImage),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getStaticToolName: () => (/* binding */ getStaticToolName),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDataUIPart: () => (/* binding */ isDataUIPart),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isFileUIPart: () => (/* binding */ isFileUIPart),\n/* harmony export */   isReasoningUIPart: () => (/* binding */ isReasoningUIPart),\n/* harmony export */   isStaticToolUIPart: () => (/* binding */ isStaticToolUIPart),\n/* harmony export */   isTextUIPart: () => (/* binding */ isTextUIPart),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithApprovalResponses: () => (/* binding */ lastAssistantMessageIsCompleteWithApprovalResponses),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parseJsonEventStream: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeAgentUIStreamToResponse: () => (/* binding */ pipeAgentUIStreamToResponse),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   pruneMessages: () => (/* binding */ pruneMessages),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   rerank: () => (/* binding */ rerank),\n/* harmony export */   safeValidateUIMessages: () => (/* binding */ safeValidateUIMessages),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   uiMessageChunkSchema: () => (/* binding */ uiMessageChunkSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapEmbeddingModel: () => (/* binding */ wrapEmbeddingModel),\n/* harmony export */   wrapImageModel: () => (/* binding */ wrapImageModel),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(action-browser)/./node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(action-browser)/./node_modules/zod/v4/index.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name17 in all)__defProp(target, name17, {\n        get: all[name17],\n        enumerable: true\n    });\n};\n// src/index.ts\n\n\n// src/generate-text/generate-text.ts\n\n// src/error/index.ts\n\n// src/error/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n    }\n};\n_a = symbol;\n// src/error/invalid-stream-part-error.ts\n\nvar name2 = \"AI_InvalidStreamPartError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ chunk, message }){\n        super({\n            name: name2,\n            message\n        });\n        this[_a2] = true;\n        this.chunk = chunk;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n    }\n};\n_a2 = symbol2;\n// src/error/invalid-tool-approval-error.ts\n\nvar name3 = \"AI_InvalidToolApprovalError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidToolApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ approvalId }){\n        super({\n            name: name3,\n            message: `Tool approval response references unknown approvalId: \"${approvalId}\". No matching tool-approval-request found in message history.`\n        });\n        this[_a3] = true;\n        this.approvalId = approvalId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n    }\n};\n_a3 = symbol3;\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolInput, toolName, cause, message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name4,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.toolInput = toolInput;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/error/tool-call-not-found-for-approval-error.ts\n\nvar name5 = \"AI_ToolCallNotFoundForApprovalError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar ToolCallNotFoundForApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolCallId, approvalId }){\n        super({\n            name: name5,\n            message: `Tool call \"${toolCallId}\" not found for approval request \"${approvalId}\".`\n        });\n        this[_a5] = true;\n        this.toolCallId = toolCallId;\n        this.approvalId = approvalId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// src/error/no-image-generated-error.ts\n\nvar name6 = \"AI_NoImageGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message = \"No image generated.\", cause, responses }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.responses = responses;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// src/error/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message = \"No object generated.\", cause, text: text2, response, usage, finishReason }){\n        super({\n            name: name7,\n            message,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text2;\n        this.response = response;\n        this.usage = usage;\n        this.finishReason = finishReason;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n    }\n};\n_a7 = symbol7;\n// src/error/no-output-generated-error.ts\n\nvar name8 = \"AI_NoOutputGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No output generated.\", cause } = {}){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n    }\n};\n_a8 = symbol8;\n// src/error/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoSpeechGeneratedError\",\n            message: \"No speech audio generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// src/error/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n    }\n};\n_a9 = symbol9;\n// src/error/tool-call-repair-error.ts\n\nvar name10 = \"AI_ToolCallRepairError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ cause, originalError, message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name10,\n            message,\n            cause\n        });\n        this[_a10] = true;\n        this.originalError = originalError;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n    }\n};\n_a10 = symbol10;\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_UnsupportedModelVersionError\",\n            message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n        });\n        this.version = options.version;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n    }\n};\n// src/error/ui-message-stream-error.ts\n\nvar name11 = \"AI_UIMessageStreamError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar UIMessageStreamError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ chunkType, chunkId, message }){\n        super({\n            name: name11,\n            message\n        });\n        this[_a11] = true;\n        this.chunkType = chunkType;\n        this.chunkId = chunkId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n    }\n};\n_a11 = symbol11;\n// src/prompt/invalid-data-content-error.ts\n\nvar name12 = \"AI_InvalidDataContentError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name12,\n            message,\n            cause\n        });\n        this[_a12] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n    }\n};\n_a12 = symbol12;\n// src/prompt/invalid-message-role-error.ts\n\nvar name13 = \"AI_InvalidMessageRoleError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name13,\n            message\n        });\n        this[_a13] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n    }\n};\n_a13 = symbol13;\n// src/prompt/message-conversion-error.ts\n\nvar name14 = \"AI_MessageConversionError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name14,\n            message\n        });\n        this[_a14] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n    }\n};\n_a14 = symbol14;\n// src/error/index.ts\n\n// src/util/retry-error.ts\n\nvar name15 = \"AI_RetryError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name15,\n            message\n        });\n        this[_a15] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n    }\n};\n_a15 = symbol15;\n// src/logger/log-warnings.ts\nfunction formatWarning({ warning, provider, model }) {\n    const prefix = `AI SDK Warning (${provider} / ${model}):`;\n    switch(warning.type){\n        case \"unsupported\":\n            {\n                let message = `${prefix} The feature \"${warning.feature}\" is not supported.`;\n                if (warning.details) {\n                    message += ` ${warning.details}`;\n                }\n                return message;\n            }\n        case \"compatibility\":\n            {\n                let message = `${prefix} The feature \"${warning.feature}\" is used in a compatibility mode.`;\n                if (warning.details) {\n                    message += ` ${warning.details}`;\n                }\n                return message;\n            }\n        case \"other\":\n            {\n                return `${prefix} ${warning.message}`;\n            }\n        default:\n            {\n                return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n            }\n    }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (options)=>{\n    if (options.warnings.length === 0) {\n        return;\n    }\n    const logger = globalThis.AI_SDK_LOG_WARNINGS;\n    if (logger === false) {\n        return;\n    }\n    if (typeof logger === \"function\") {\n        logger(options);\n        return;\n    }\n    if (!hasLoggedBefore) {\n        hasLoggedBefore = true;\n        console.info(FIRST_WARNING_INFO_MESSAGE);\n    }\n    for (const warning of options.warnings){\n        console.warn(formatWarning({\n            warning,\n            provider: options.provider,\n            model: options.model\n        }));\n    }\n};\n// src/model/resolve-model.ts\n\n// src/util/log-v2-compatibility-warning.ts\nfunction logV2CompatibilityWarning({ provider, modelId }) {\n    logWarnings({\n        warnings: [\n            {\n                type: \"compatibility\",\n                feature: \"specificationVersion\",\n                details: `Using v2 specification compatibility mode. Some features may not be available.`\n            }\n        ],\n        provider,\n        model: modelId\n    });\n}\n// src/model/as-embedding-model-v3.ts\nfunction asEmbeddingModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-image-model-v3.ts\nfunction asImageModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-language-model-v3.ts\nfunction asLanguageModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            switch(prop){\n                case \"specificationVersion\":\n                    return \"v3\";\n                case \"doGenerate\":\n                    return async (...args)=>{\n                        const result = await target.doGenerate(...args);\n                        return {\n                            ...result,\n                            finishReason: convertV2FinishReasonToV3(result.finishReason),\n                            usage: convertV2UsageToV3(result.usage)\n                        };\n                    };\n                case \"doStream\":\n                    return async (...args)=>{\n                        const result = await target.doStream(...args);\n                        return {\n                            ...result,\n                            stream: convertV2StreamToV3(result.stream)\n                        };\n                    };\n                default:\n                    return target[prop];\n            }\n        }\n    });\n}\nfunction convertV2StreamToV3(stream) {\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            switch(chunk.type){\n                case \"finish\":\n                    controller.enqueue({\n                        ...chunk,\n                        finishReason: convertV2FinishReasonToV3(chunk.finishReason),\n                        usage: convertV2UsageToV3(chunk.usage)\n                    });\n                    break;\n                default:\n                    controller.enqueue(chunk);\n                    break;\n            }\n        }\n    }));\n}\nfunction convertV2FinishReasonToV3(finishReason) {\n    return {\n        unified: finishReason === \"unknown\" ? \"other\" : finishReason,\n        raw: void 0\n    };\n}\nfunction convertV2UsageToV3(usage) {\n    return {\n        inputTokens: {\n            total: usage.inputTokens,\n            noCache: void 0,\n            cacheRead: usage.cachedInputTokens,\n            cacheWrite: void 0\n        },\n        outputTokens: {\n            total: usage.outputTokens,\n            text: void 0,\n            reasoning: usage.reasoningTokens\n        }\n    };\n}\n// src/model/as-speech-model-v3.ts\nfunction asSpeechModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-transcription-model-v3.ts\nfunction asTranscriptionModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asLanguageModelV3(model);\n    }\n    return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asEmbeddingModelV3(model);\n    }\n    return getGlobalProvider().embeddingModel(model);\n}\nfunction resolveTranscriptionModel(model) {\n    var _a17, _b;\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asTranscriptionModelV3(model);\n    }\n    return (_b = (_a17 = getGlobalProvider()).transcriptionModel) == null ? void 0 : _b.call(_a17, model);\n}\nfunction resolveSpeechModel(model) {\n    var _a17, _b;\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asSpeechModelV3(model);\n    }\n    return (_b = (_a17 = getGlobalProvider()).speechModel) == null ? void 0 : _b.call(_a17, model);\n}\nfunction resolveImageModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asImageModelV3(model);\n    }\n    return getGlobalProvider().imageModel(model);\n}\nfunction getGlobalProvider() {\n    var _a17;\n    return (_a17 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a17 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n// src/prompt/call-settings.ts\nfunction getTotalTimeoutMs(timeout) {\n    if (timeout == null) {\n        return void 0;\n    }\n    if (typeof timeout === \"number\") {\n        return timeout;\n    }\n    return timeout.totalMs;\n}\nfunction getStepTimeoutMs(timeout) {\n    if (timeout == null || typeof timeout === \"number\") {\n        return void 0;\n    }\n    return timeout.stepMs;\n}\nfunction getChunkTimeoutMs(timeout) {\n    if (timeout == null || typeof timeout === \"number\") {\n        return void 0;\n    }\n    return timeout.chunkMs;\n}\n// src/prompt/convert-to-language-model-prompt.ts\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n    {\n        mediaType: \"image/gif\",\n        bytesPrefix: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mediaType: \"image/png\",\n        bytesPrefix: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mediaType: \"image/jpeg\",\n        bytesPrefix: [\n            255,\n            216\n        ]\n    },\n    {\n        mediaType: \"image/webp\",\n        bytesPrefix: [\n            82,\n            73,\n            70,\n            70,\n            // \"RIFF\"\n            null,\n            null,\n            null,\n            null,\n            // file size (variable)\n            87,\n            69,\n            66,\n            80\n        ]\n    },\n    {\n        mediaType: \"image/bmp\",\n        bytesPrefix: [\n            66,\n            77\n        ]\n    },\n    {\n        mediaType: \"image/tiff\",\n        bytesPrefix: [\n            73,\n            73,\n            42,\n            0\n        ]\n    },\n    {\n        mediaType: \"image/tiff\",\n        bytesPrefix: [\n            77,\n            77,\n            0,\n            42\n        ]\n    },\n    {\n        mediaType: \"image/avif\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            97,\n            118,\n            105,\n            102\n        ]\n    },\n    {\n        mediaType: \"image/heic\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            104,\n            101,\n            105,\n            99\n        ]\n    }\n];\nvar audioMediaTypeSignatures = [\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            251\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            250\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            243\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            242\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            227\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            226\n        ]\n    },\n    {\n        mediaType: \"audio/wav\",\n        bytesPrefix: [\n            82,\n            // R\n            73,\n            // I\n            70,\n            // F\n            70,\n            // F\n            null,\n            null,\n            null,\n            null,\n            87,\n            // W\n            65,\n            // A\n            86,\n            // V\n            69\n        ]\n    },\n    {\n        mediaType: \"audio/ogg\",\n        bytesPrefix: [\n            79,\n            103,\n            103,\n            83\n        ]\n    },\n    {\n        mediaType: \"audio/flac\",\n        bytesPrefix: [\n            102,\n            76,\n            97,\n            67\n        ]\n    },\n    {\n        mediaType: \"audio/aac\",\n        bytesPrefix: [\n            64,\n            21,\n            0,\n            0\n        ]\n    },\n    {\n        mediaType: \"audio/mp4\",\n        bytesPrefix: [\n            102,\n            116,\n            121,\n            112\n        ]\n    },\n    {\n        mediaType: \"audio/webm\",\n        bytesPrefix: [\n            26,\n            69,\n            223,\n            163\n        ]\n    }\n];\nvar stripID3 = (data)=>{\n    const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n    return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n    const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n    data[1] === 68 && // 'D'\n    data[2] === 51;\n    return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({ data, signatures }) {\n    const processedData = stripID3TagsIfPresent(data);\n    const bytes = typeof processedData === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(processedData.substring(0, Math.min(processedData.length, 24))) : processedData;\n    for (const signature of signatures){\n        if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>byte === null || bytes[index] === byte)) {\n            return signature.mediaType;\n        }\n    }\n    return void 0;\n}\n// src/util/download/download.ts\n\n\n// src/version.ts\nvar VERSION =  true ? \"6.0.42\" : 0;\n// src/util/download/download.ts\nvar download = async ({ url })=>{\n    var _a17;\n    const urlText = url.toString();\n    try {\n        const response = await fetch(urlText, {\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({}, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)())\n        });\n        if (!response.ok) {\n            throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mediaType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n        };\n    } catch (error) {\n        if (_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n};\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download)=>(requestedDownloads)=>Promise.all(requestedDownloads.map(async (requestedDownload)=>requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));\n// src/prompt/data-content.ts\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mediaType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mediaType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(Uint8Array),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(ArrayBuffer),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a17, _b;\n        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertToLanguageModelV3DataContent(content) {\n    if (content instanceof Uint8Array) {\n        return {\n            data: content,\n            mediaType: void 0\n        };\n    }\n    if (content instanceof ArrayBuffer) {\n        return {\n            data: new Uint8Array(content),\n            mediaType: void 0\n        };\n    }\n    if (typeof content === \"string\") {\n        try {\n            content = new URL(content);\n        } catch (error) {}\n    }\n    if (content instanceof URL && content.protocol === \"data:\") {\n        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());\n        if (dataUrlMediaType == null || base64Content == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n                name: \"InvalidDataContentError\",\n                message: `Invalid data URL format in content ${content.toString()}`\n            });\n        }\n        return {\n            data: base64Content,\n            mediaType: dataUrlMediaType\n        };\n    }\n    return {\n        data: content,\n        mediaType: void 0\n    };\n}\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\n// src/util/as-array.ts\nfunction asArray(value) {\n    return value === void 0 ? [] : Array.isArray(value) ? value : [\n        value\n    ];\n}\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, supportedUrls, download: download2 = createDefaultDownloadFunction() }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls);\n    const messages = [\n        ...prompt.system != null ? typeof prompt.system === \"string\" ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : asArray(prompt.system).map((message)=>({\n                role: \"system\",\n                content: message.content,\n                providerOptions: message.providerOptions\n            })) : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage({\n                message,\n                downloadedAssets\n            }))\n    ];\n    const combinedMessages = [];\n    for (const message of messages){\n        if (message.role !== \"tool\") {\n            combinedMessages.push(message);\n            continue;\n        }\n        const lastCombinedMessage = combinedMessages.at(-1);\n        if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === \"tool\") {\n            lastCombinedMessage.content.push(...message.content);\n        } else {\n            combinedMessages.push(message);\n        }\n    }\n    return combinedMessages;\n}\nfunction convertToLanguageModelMessage({ message, downloadedAssets }) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerOptions: message.providerOptions\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerOptions: message.providerOptions\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts (no text, and no provider options):\n                    (part)=>part.type !== \"text\" || part.text !== \"\" || part.providerOptions != null).filter((part)=>part.type !== \"tool-approval-request\").map((part)=>{\n                        const providerOptions = part.providerOptions;\n                        switch(part.type){\n                            case \"file\":\n                                {\n                                    const { data, mediaType } = convertToLanguageModelV3DataContent(part.data);\n                                    return {\n                                        type: \"file\",\n                                        data,\n                                        filename: part.filename,\n                                        mediaType: mediaType != null ? mediaType : part.mediaType,\n                                        providerOptions\n                                    };\n                                }\n                            case \"reasoning\":\n                                {\n                                    return {\n                                        type: \"reasoning\",\n                                        text: part.text,\n                                        providerOptions\n                                    };\n                                }\n                            case \"text\":\n                                {\n                                    return {\n                                        type: \"text\",\n                                        text: part.text,\n                                        providerOptions\n                                    };\n                                }\n                            case \"tool-call\":\n                                {\n                                    return {\n                                        type: \"tool-call\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        input: part.input,\n                                        providerExecuted: part.providerExecuted,\n                                        providerOptions\n                                    };\n                                }\n                            case \"tool-result\":\n                                {\n                                    return {\n                                        type: \"tool-result\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        output: mapToolResultOutput(part.output),\n                                        providerOptions\n                                    };\n                                }\n                        }\n                    }),\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.filter(// Only include tool-approval-response for provider-executed tools\n                    (part)=>part.type !== \"tool-approval-response\" || part.providerExecuted).map((part)=>{\n                        switch(part.type){\n                            case \"tool-result\":\n                                {\n                                    return {\n                                        type: \"tool-result\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        output: mapToolResultOutput(part.output),\n                                        providerOptions: part.providerOptions\n                                    };\n                                }\n                            case \"tool-approval-response\":\n                                {\n                                    return {\n                                        type: \"tool-approval-response\",\n                                        approvalId: part.approvalId,\n                                        approved: part.approved,\n                                        reason: part.reason\n                                    };\n                                }\n                        }\n                    }),\n                    providerOptions: message.providerOptions\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n    const plannedDownloads = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").map((part)=>{\n        var _a17;\n        const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === \"image\" ? \"image/*\" : void 0;\n        let data = part.type === \"image\" ? part.image : part.data;\n        if (typeof data === \"string\") {\n            try {\n                data = new URL(data);\n            } catch (ignored) {}\n        }\n        return {\n            mediaType,\n            data\n        };\n    }).filter((part)=>part.data instanceof URL).map((part)=>({\n            url: part.data,\n            isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n                url: part.data.toString(),\n                mediaType: part.mediaType,\n                supportedUrls\n            })\n        }));\n    const downloadedFiles = await download2(plannedDownloads);\n    return Object.fromEntries(downloadedFiles.map((file, index)=>file == null ? null : [\n            plannedDownloads[index].url.toString(),\n            {\n                data: file.data,\n                mediaType: file.mediaType\n            }\n        ]).filter((file)=>file != null));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    var _a17;\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerOptions: part.providerOptions\n        };\n    }\n    let originalData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            originalData = part.image;\n            break;\n        case \"file\":\n            originalData = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);\n    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n    let data = convertedData;\n    if (data instanceof URL) {\n        const downloadedFile = downloadedAssets[data.toString()];\n        if (downloadedFile) {\n            data = downloadedFile.data;\n            mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n        }\n    }\n    switch(type){\n        case \"image\":\n            {\n                if (data instanceof Uint8Array || typeof data === \"string\") {\n                    mediaType = (_a17 = detectMediaType({\n                        data,\n                        signatures: imageMediaTypeSignatures\n                    })) != null ? _a17 : mediaType;\n                }\n                return {\n                    type: \"file\",\n                    mediaType: mediaType != null ? mediaType : \"image/*\",\n                    // any image\n                    filename: void 0,\n                    data,\n                    providerOptions: part.providerOptions\n                };\n            }\n        case \"file\":\n            {\n                if (mediaType == null) {\n                    throw new Error(`Media type is missing for file part`);\n                }\n                return {\n                    type: \"file\",\n                    mediaType,\n                    filename: part.filename,\n                    data,\n                    providerOptions: part.providerOptions\n                };\n            }\n    }\n}\nfunction mapToolResultOutput(output) {\n    if (output.type !== \"content\") {\n        return output;\n    }\n    return {\n        type: \"content\",\n        value: output.value.map((item)=>{\n            if (item.type !== \"media\") {\n                return item;\n            }\n            if (item.mediaType.startsWith(\"image/\")) {\n                return {\n                    type: \"image-data\",\n                    data: item.data,\n                    mediaType: item.mediaType\n                };\n            }\n            return {\n                type: \"file-data\",\n                data: item.data,\n                mediaType: item.mediaType\n            };\n        })\n    };\n}\n// src/prompt/create-tool-model-output.ts\n\nasync function createToolModelOutput({ toolCallId, input, output, tool: tool2, errorMode }) {\n    if (errorMode === \"text\") {\n        return {\n            type: \"error-text\",\n            value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output)\n        };\n    } else if (errorMode === \"json\") {\n        return {\n            type: \"error-json\",\n            value: toJSONValue(output)\n        };\n    }\n    if (tool2 == null ? void 0 : tool2.toModelOutput) {\n        return await tool2.toModelOutput({\n            toolCallId,\n            input,\n            output\n        });\n    }\n    return typeof output === \"string\" ? {\n        type: \"text\",\n        value: output\n    } : {\n        type: \"json\",\n        value: toJSONValue(output)\n    };\n}\nfunction toJSONValue(value) {\n    return value === void 0 ? null : value;\n}\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxOutputTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, seed, stopSequences }) {\n    if (maxOutputTokens != null) {\n        if (!Number.isInteger(maxOutputTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxOutputTokens\",\n                value: maxOutputTokens,\n                message: \"maxOutputTokens must be an integer\"\n            });\n        }\n        if (maxOutputTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxOutputTokens\",\n                value: maxOutputTokens,\n                message: \"maxOutputTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    return {\n        maxOutputTokens,\n        temperature,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences,\n        seed\n    };\n}\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n    return object2 != null && Object.keys(object2).length > 0;\n}\n// src/prompt/prepare-tools-and-tool-choice.ts\nasync function prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name17])=>activeTools.includes(name17)) : Object.entries(tools);\n    const languageModelTools = [];\n    for (const [name17, tool2] of filteredTools){\n        const toolType = tool2.type;\n        switch(toolType){\n            case void 0:\n            case \"dynamic\":\n            case \"function\":\n                languageModelTools.push({\n                    type: \"function\",\n                    name: name17,\n                    description: tool2.description,\n                    inputSchema: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema).jsonSchema,\n                    ...tool2.inputExamples != null ? {\n                        inputExamples: tool2.inputExamples\n                    } : {},\n                    providerOptions: tool2.providerOptions,\n                    ...tool2.strict != null ? {\n                        strict: tool2.strict\n                    } : {}\n                });\n                break;\n            case \"provider\":\n                languageModelTools.push({\n                    type: \"provider\",\n                    name: name17,\n                    id: tool2.id,\n                    args: tool2.args\n                });\n                break;\n            default:\n                {\n                    const exhaustiveCheck = toolType;\n                    throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                }\n        }\n    }\n    return {\n        tools: languageModelTools,\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// src/prompt/standardize-prompt.ts\n\n\n\n// src/prompt/message.ts\n\n// src/types/provider-metadata.ts\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.lazy(()=>zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.null(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.number(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema.optional()),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(jsonValueSchema)\n    ]));\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema.optional()));\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n    image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-call\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n    providerOptions: providerMetadataSchema.optional(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.discriminatedUnion(\"type\", [\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"json\"),\n        value: jsonValueSchema,\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"execution-denied\"),\n        reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error-text\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error-json\"),\n        value: jsonValueSchema,\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"content\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"media\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-data\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-url\"),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-id\"),\n                fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string())\n                ]),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-data\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-url\"),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-file-id\"),\n                fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string())\n                ]),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"custom\"),\n                providerOptions: providerMetadataSchema.optional()\n            })\n        ]))\n    })\n]);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-result\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    output: outputSchema,\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolApprovalRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-request\"),\n    approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n});\nvar toolApprovalResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-response\"),\n    approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n});\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"user\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"assistant\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            filePartSchema,\n            reasoningPartSchema,\n            toolCallPartSchema,\n            toolResultPartSchema,\n            toolApprovalRequestSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        toolResultPartSchema,\n        toolApprovalResponseSchema\n    ])),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    systemModelMessageSchema,\n    userModelMessageSchema,\n    assistantModelMessageSchema,\n    toolModelMessageSchema\n]);\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\" && !asArray(prompt.system).every((message)=>typeof message === \"object\" && message !== null && \"role\" in message && message.role === \"system\")) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string, SystemModelMessage, or array of SystemModelMessage\"\n        });\n    }\n    let messages;\n    if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n        messages = [\n            {\n                role: \"user\",\n                content: prompt.prompt\n            }\n        ];\n    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n        messages = prompt.prompt;\n    } else if (prompt.messages != null) {\n        messages = prompt.messages;\n    } else {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (messages.length === 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"messages must not be empty\"\n        });\n    }\n    const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: messages,\n        schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(modelMessageSchema)\n    });\n    if (!validationResult.success) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"The messages do not match the ModelMessage[] schema.\",\n            cause: validationResult.error\n        });\n    }\n    return {\n        messages,\n        system: prompt.system\n    };\n}\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n    if (!_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error)) return error;\n    const isProductionEnv = (process == null ? void 0 : \"development\") === \"production\";\n    const moreInfoURL = \"https://ai-sdk.dev/unauthenticated-ai-gateway\";\n    if (isProductionEnv) {\n        return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n            name: \"GatewayError\",\n            message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`\n        });\n    }\n    return Object.assign(new Error(`\\x1B[1m\\x1B[31mUnauthenticated request to AI Gateway.\\x1B[0m\n\nTo authenticate, set the \\x1B[33mAI_GATEWAY_API_KEY\\x1B[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\x1B[34m${moreInfoURL}\\x1B[0m\n\n`), {\n        name: \"GatewayAuthenticationError\"\n    });\n}\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a17;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            if (key === \"timeout\") {\n                const totalTimeoutMs = getTotalTimeoutMs(value);\n                if (totalTimeoutMs != null) {\n                    attributes[`ai.settings.${key}`] = totalTimeoutMs;\n                }\n            } else {\n                attributes[`ai.settings.${key}`] = value;\n            }\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// src/telemetry/get-tracer.ts\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name17, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// src/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n// src/telemetry/record-span.ts\n\nasync function recordSpan({ name: name17, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name17, {\n        attributes: await attributes\n    }, async (span)=>{\n        const ctx = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.context.active();\n        try {\n            const result = await _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.context.with(ctx, ()=>fn(span));\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                recordErrorOnSpan(span, error);\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\nfunction recordErrorOnSpan(span, error) {\n    if (error instanceof Error) {\n        span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n        });\n        span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR,\n            message: error.message\n        });\n    } else {\n        span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR\n        });\n    }\n}\n// src/telemetry/select-telemetry-attributes.ts\nasync function selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    const resultAttributes = {};\n    for (const [key, value] of Object.entries(attributes)){\n        if (value == null) {\n            continue;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                continue;\n            }\n            const result = await value.input();\n            if (result != null) {\n                resultAttributes[key] = result;\n            }\n            continue;\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                continue;\n            }\n            const result = await value.output();\n            if (result != null) {\n                resultAttributes[key] = result;\n            }\n            continue;\n        }\n        resultAttributes[key] = value;\n    }\n    return resultAttributes;\n}\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n    return JSON.stringify(prompt.map((message)=>({\n            ...message,\n            content: typeof message.content === \"string\" ? message.content : message.content.map((part)=>part.type === \"file\" ? {\n                    ...part,\n                    data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n                } : part)\n        })));\n}\n// src/types/usage.ts\nfunction asLanguageModelUsage(usage) {\n    return {\n        inputTokens: usage.inputTokens.total,\n        inputTokenDetails: {\n            noCacheTokens: usage.inputTokens.noCache,\n            cacheReadTokens: usage.inputTokens.cacheRead,\n            cacheWriteTokens: usage.inputTokens.cacheWrite\n        },\n        outputTokens: usage.outputTokens.total,\n        outputTokenDetails: {\n            textTokens: usage.outputTokens.text,\n            reasoningTokens: usage.outputTokens.reasoning\n        },\n        totalTokens: addTokenCounts(usage.inputTokens.total, usage.outputTokens.total),\n        raw: usage.raw,\n        reasoningTokens: usage.outputTokens.reasoning,\n        cachedInputTokens: usage.inputTokens.cacheRead\n    };\n}\nfunction createNullLanguageModelUsage() {\n    return {\n        inputTokens: void 0,\n        inputTokenDetails: {\n            noCacheTokens: void 0,\n            cacheReadTokens: void 0,\n            cacheWriteTokens: void 0\n        },\n        outputTokens: void 0,\n        outputTokenDetails: {\n            textTokens: void 0,\n            reasoningTokens: void 0\n        },\n        totalTokens: void 0,\n        raw: void 0\n    };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n    var _a17, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    return {\n        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n        inputTokenDetails: {\n            noCacheTokens: addTokenCounts((_a17 = usage1.inputTokenDetails) == null ? void 0 : _a17.noCacheTokens, (_b = usage2.inputTokenDetails) == null ? void 0 : _b.noCacheTokens),\n            cacheReadTokens: addTokenCounts((_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens, (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens),\n            cacheWriteTokens: addTokenCounts((_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens, (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens)\n        },\n        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n        outputTokenDetails: {\n            textTokens: addTokenCounts((_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens, (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens),\n            reasoningTokens: addTokenCounts((_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens, (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens)\n        },\n        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n        reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),\n        cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)\n    };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\nfunction addImageModelUsage(usage1, usage2) {\n    return {\n        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens)\n    };\n}\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n    if (base === void 0 && overrides === void 0) {\n        return void 0;\n    }\n    if (base === void 0) {\n        return overrides;\n    }\n    if (overrides === void 0) {\n        return base;\n    }\n    const result = {\n        ...base\n    };\n    for(const key in overrides){\n        if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n            const overridesValue = overrides[key];\n            if (overridesValue === void 0) continue;\n            const baseValue = key in base ? base[key] : void 0;\n            const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n            const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n            if (isSourceObject && isTargetObject) {\n                result[key] = mergeObjects(baseValue, overridesValue);\n            } else {\n                result[key] = overridesValue;\n            }\n        }\n    }\n    return result;\n}\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({ error, exponentialBackoffDelay }) {\n    const headers = error.responseHeaders;\n    if (!headers) return exponentialBackoffDelay;\n    let ms;\n    const retryAfterMs = headers[\"retry-after-ms\"];\n    if (retryAfterMs) {\n        const timeoutMs = parseFloat(retryAfterMs);\n        if (!Number.isNaN(timeoutMs)) {\n            ms = timeoutMs;\n        }\n    }\n    const retryAfter = headers[\"retry-after\"];\n    if (retryAfter && ms === void 0) {\n        const timeoutSeconds = parseFloat(retryAfter);\n        if (!Number.isNaN(timeoutSeconds)) {\n            ms = timeoutSeconds * 1e3;\n        } else {\n            ms = Date.parse(retryAfter) - Date.now();\n        }\n    }\n    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n        return ms;\n    }\n    return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2, abortSignal } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor,\n            abortSignal\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor, abortSignal }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(getRetryDelayInMs({\n                error,\n                exponentialBackoffDelay: delayInMs\n            }), {\n                abortSignal\n            });\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor,\n                abortSignal\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// src/util/prepare-retries.ts\nfunction prepareRetries({ maxRetries, abortSignal }) {\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n    return {\n        maxRetries: maxRetriesResult,\n        retry: retryWithExponentialBackoffRespectingRetryHeaders({\n            maxRetries: maxRetriesResult,\n            abortSignal\n        })\n    };\n}\n// src/generate-text/collect-tool-approvals.ts\nfunction collectToolApprovals({ messages }) {\n    const lastMessage = messages.at(-1);\n    if ((lastMessage == null ? void 0 : lastMessage.role) != \"tool\") {\n        return {\n            approvedToolApprovals: [],\n            deniedToolApprovals: []\n        };\n    }\n    const toolCallsByToolCallId = {};\n    for (const message of messages){\n        if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n            const content = message.content;\n            for (const part of content){\n                if (part.type === \"tool-call\") {\n                    toolCallsByToolCallId[part.toolCallId] = part;\n                }\n            }\n        }\n    }\n    const toolApprovalRequestsByApprovalId = {};\n    for (const message of messages){\n        if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n            const content = message.content;\n            for (const part of content){\n                if (part.type === \"tool-approval-request\") {\n                    toolApprovalRequestsByApprovalId[part.approvalId] = part;\n                }\n            }\n        }\n    }\n    const toolResults = {};\n    for (const part of lastMessage.content){\n        if (part.type === \"tool-result\") {\n            toolResults[part.toolCallId] = part;\n        }\n    }\n    const approvedToolApprovals = [];\n    const deniedToolApprovals = [];\n    const approvalResponses = lastMessage.content.filter((part)=>part.type === \"tool-approval-response\");\n    for (const approvalResponse of approvalResponses){\n        const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];\n        if (approvalRequest == null) {\n            throw new InvalidToolApprovalError({\n                approvalId: approvalResponse.approvalId\n            });\n        }\n        if (toolResults[approvalRequest.toolCallId] != null) {\n            continue;\n        }\n        const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];\n        if (toolCall == null) {\n            throw new ToolCallNotFoundForApprovalError({\n                toolCallId: approvalRequest.toolCallId,\n                approvalId: approvalRequest.approvalId\n            });\n        }\n        const approval = {\n            approvalRequest,\n            approvalResponse,\n            toolCall\n        };\n        if (approvalResponse.approved) {\n            approvedToolApprovals.push(approval);\n        } else {\n            deniedToolApprovals.push(approval);\n        }\n    }\n    return {\n        approvedToolApprovals,\n        deniedToolApprovals\n    };\n}\n// src/generate-text/execute-tool-call.ts\n\nasync function executeToolCall({ toolCall, tools, tracer, telemetry, messages, abortSignal, experimental_context, onPreliminaryToolResult }) {\n    const { toolName, toolCallId, input } = toolCall;\n    const tool2 = tools == null ? void 0 : tools[toolName];\n    if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n    }\n    return recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.toolCall\",\n                    telemetry\n                }),\n                \"ai.toolCall.name\": toolName,\n                \"ai.toolCall.id\": toolCallId,\n                \"ai.toolCall.args\": {\n                    output: ()=>JSON.stringify(input)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            let output;\n            try {\n                const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n                    execute: tool2.execute.bind(tool2),\n                    input,\n                    options: {\n                        toolCallId,\n                        messages,\n                        abortSignal,\n                        experimental_context\n                    }\n                });\n                for await (const part of stream){\n                    if (part.type === \"preliminary\") {\n                        onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({\n                            ...toolCall,\n                            type: \"tool-result\",\n                            output: part.output,\n                            preliminary: true\n                        });\n                    } else {\n                        output = part.output;\n                    }\n                }\n            } catch (error) {\n                recordErrorOnSpan(span, error);\n                return {\n                    type: \"tool-error\",\n                    toolCallId,\n                    toolName,\n                    input,\n                    error,\n                    dynamic: tool2.type === \"dynamic\",\n                    ...toolCall.providerMetadata != null ? {\n                        providerMetadata: toolCall.providerMetadata\n                    } : {}\n                };\n            }\n            try {\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.toolCall.result\": {\n                            output: ()=>JSON.stringify(output)\n                        }\n                    }\n                }));\n            } catch (ignored) {}\n            return {\n                type: \"tool-result\",\n                toolCallId,\n                toolName,\n                input,\n                output,\n                dynamic: tool2.type === \"dynamic\",\n                ...toolCall.providerMetadata != null ? {\n                    providerMetadata: toolCall.providerMetadata\n                } : {}\n            };\n        }\n    });\n}\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n    const parts = content.filter((content2)=>content2.type === \"text\");\n    if (parts.length === 0) {\n        return void 0;\n    }\n    return parts.map((content2)=>content2.text).join(\"\");\n}\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n    constructor({ data, mediaType }){\n        const isUint8Array = data instanceof Uint8Array;\n        this.base64Data = isUint8Array ? void 0 : data;\n        this.uint8ArrayData = isUint8Array ? data : void 0;\n        this.mediaType = mediaType;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get base64() {\n        if (this.base64Data == null) {\n            this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n        }\n        return this.base64Data;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get uint8Array() {\n        if (this.uint8ArrayData == null) {\n            this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n        }\n        return this.uint8ArrayData;\n    }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n    constructor(options){\n        super(options);\n        this.type = \"file\";\n    }\n};\n// src/generate-text/is-approval-needed.ts\nasync function isApprovalNeeded({ tool: tool2, toolCall, messages, experimental_context }) {\n    if (tool2.needsApproval == null) {\n        return false;\n    }\n    if (typeof tool2.needsApproval === \"boolean\") {\n        return tool2.needsApproval;\n    }\n    return await tool2.needsApproval(toolCall.input, {\n        toolCallId: toolCall.toolCallId,\n        messages,\n        experimental_context\n    });\n}\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n    array: ()=>array,\n    choice: ()=>choice,\n    json: ()=>json,\n    object: ()=>object,\n    text: ()=>text\n});\n\n\n// src/util/parse-partial-json.ts\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n    const stack = [\n        \"ROOT\"\n    ];\n    let lastValidIndex = -1;\n    let literalStart = null;\n    function processValueStart(char, i, swapState) {\n        {\n            switch(char){\n                case '\"':\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_STRING\");\n                        break;\n                    }\n                case \"f\":\n                case \"t\":\n                case \"n\":\n                    {\n                        lastValidIndex = i;\n                        literalStart = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_LITERAL\");\n                        break;\n                    }\n                case \"-\":\n                    {\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"{\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_OBJECT_START\");\n                        break;\n                    }\n                case \"[\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_ARRAY_START\");\n                        break;\n                    }\n            }\n        }\n    }\n    function processAfterObjectValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n                    break;\n                }\n            case \"}\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    function processAfterArrayValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                    break;\n                }\n            case \"]\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    for(let i = 0; i < input.length; i++){\n        const char = input[i];\n        const currentState = stack[stack.length - 1];\n        switch(currentState){\n            case \"ROOT\":\n                processValueStart(char, i, \"FINISH\");\n                break;\n            case \"INSIDE_OBJECT_START\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n                {\n                    switch(char){\n                        case \":\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n                {\n                    processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    processAfterObjectValue(char, i);\n                    break;\n                }\n            case \"INSIDE_STRING\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"\\\\\":\n                            {\n                                stack.push(\"INSIDE_STRING_ESCAPE\");\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n                {\n                    switch(char){\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    switch(char){\n                        case \",\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n                {\n                    processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_STRING_ESCAPE\":\n                {\n                    stack.pop();\n                    lastValidIndex = i;\n                    break;\n                }\n            case \"INSIDE_NUMBER\":\n                {\n                    switch(char){\n                        case \"0\":\n                        case \"1\":\n                        case \"2\":\n                        case \"3\":\n                        case \"4\":\n                        case \"5\":\n                        case \"6\":\n                        case \"7\":\n                        case \"8\":\n                        case \"9\":\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"e\":\n                        case \"E\":\n                        case \"-\":\n                        case \".\":\n                            {\n                                break;\n                            }\n                        case \",\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                break;\n                            }\n                        default:\n                            {\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, i + 1);\n                    if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n                        stack.pop();\n                        if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                            processAfterObjectValue(char, i);\n                        } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                            processAfterArrayValue(char, i);\n                        }\n                    } else {\n                        lastValidIndex = i;\n                    }\n                    break;\n                }\n        }\n    }\n    let result = input.slice(0, lastValidIndex + 1);\n    for(let i = stack.length - 1; i >= 0; i--){\n        const state = stack[i];\n        switch(state){\n            case \"INSIDE_STRING\":\n                {\n                    result += '\"';\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n            case \"INSIDE_OBJECT_START\":\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    result += \"}\";\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    result += \"]\";\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, input.length);\n                    if (\"true\".startsWith(partialLiteral)) {\n                        result += \"true\".slice(partialLiteral.length);\n                    } else if (\"false\".startsWith(partialLiteral)) {\n                        result += \"false\".slice(partialLiteral.length);\n                    } else if (\"null\".startsWith(partialLiteral)) {\n                        result += \"null\".slice(partialLiteral.length);\n                    }\n                }\n        }\n    }\n    return result;\n}\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n    if (jsonText === void 0) {\n        return {\n            value: void 0,\n            state: \"undefined-input\"\n        };\n    }\n    let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: jsonText\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"successful-parse\"\n        };\n    }\n    result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: fixJson(jsonText)\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"repaired-parse\"\n        };\n    }\n    return {\n        value: void 0,\n        state: \"failed-parse\"\n    };\n}\n// src/generate-text/output.ts\nvar text = ()=>({\n        name: \"text\",\n        responseFormat: Promise.resolve({\n            type: \"text\"\n        }),\n        async parseCompleteOutput ({ text: text2 }) {\n            return text2;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            return {\n                partial: text2\n            };\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    });\nvar object = ({ schema: inputSchema, name: name17, description })=>{\n    const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n    return {\n        name: \"object\",\n        responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(schema.jsonSchema).then((jsonSchema2)=>({\n                type: \"json\",\n                schema: jsonSchema2,\n                ...name17 != null && {\n                    name: name17\n                },\n                ...description != null && {\n                    description\n                }\n            })),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value: parseResult.value,\n                schema\n            });\n            if (!validationResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: validationResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return validationResult.value;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        return {\n                            // Note: currently no validation of partial results:\n                            partial: result.value\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\nvar array = ({ element: inputElementSchema, name: name17, description })=>{\n    const elementSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputElementSchema);\n    return {\n        name: \"array\",\n        // JSON schema that describes an array of elements:\n        responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(elementSchema.jsonSchema).then((jsonSchema2)=>{\n            const { $schema, ...itemSchema } = jsonSchema2;\n            return {\n                type: \"json\",\n                schema: {\n                    $schema: \"http://json-schema.org/draft-07/schema#\",\n                    type: \"object\",\n                    properties: {\n                        elements: {\n                            type: \"array\",\n                            items: itemSchema\n                        }\n                    },\n                    required: [\n                        \"elements\"\n                    ],\n                    additionalProperties: false\n                },\n                ...name17 != null && {\n                    name: name17\n                },\n                ...description != null && {\n                    description\n                }\n            };\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const outerValue = parseResult.value;\n            if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value: outerValue,\n                        cause: \"response must be an object with an elements array\"\n                    }),\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            for (const element of outerValue.elements){\n                const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema: elementSchema\n                });\n                if (!validationResult.success) {\n                    throw new NoObjectGeneratedError({\n                        message: \"No object generated: response did not match schema.\",\n                        cause: validationResult.error,\n                        text: text2,\n                        response: context2.response,\n                        usage: context2.usage,\n                        finishReason: context2.finishReason\n                    });\n                }\n            }\n            return outerValue.elements;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        const outerValue = result.value;\n                        if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n                            return void 0;\n                        }\n                        const rawElements = result.state === \"repaired-parse\" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;\n                        const parsedElements = [];\n                        for (const rawElement of rawElements){\n                            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                                value: rawElement,\n                                schema: elementSchema\n                            });\n                            if (validationResult.success) {\n                                parsedElements.push(validationResult.value);\n                            }\n                        }\n                        return {\n                            partial: parsedElements\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            let publishedElements = 0;\n            return new TransformStream({\n                transform ({ partialOutput }, controller) {\n                    if (partialOutput != null) {\n                        for(; publishedElements < partialOutput.length; publishedElements++){\n                            controller.enqueue(partialOutput[publishedElements]);\n                        }\n                    }\n                }\n            });\n        }\n    };\n};\nvar choice = ({ options: choiceOptions, name: name17, description })=>{\n    return {\n        name: \"choice\",\n        // JSON schema that describes an enumeration:\n        responseFormat: Promise.resolve({\n            type: \"json\",\n            schema: {\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    result: {\n                        type: \"string\",\n                        enum: choiceOptions\n                    }\n                },\n                required: [\n                    \"result\"\n                ],\n                additionalProperties: false\n            },\n            ...name17 != null && {\n                name: name17\n            },\n            ...description != null && {\n                description\n            }\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const outerValue = parseResult.value;\n            if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\" || !choiceOptions.includes(outerValue.result)) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value: outerValue,\n                        cause: \"response must be an object that contains a choice value.\"\n                    }),\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return outerValue.result;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        const outerValue = result.value;\n                        if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\") {\n                            return void 0;\n                        }\n                        const potentialMatches = choiceOptions.filter((choiceOption)=>choiceOption.startsWith(outerValue.result));\n                        if (result.state === \"successful-parse\") {\n                            return potentialMatches.includes(outerValue.result) ? {\n                                partial: outerValue.result\n                            } : void 0;\n                        } else {\n                            return potentialMatches.length === 1 ? {\n                                partial: potentialMatches[0]\n                            } : void 0;\n                        }\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\nvar json = ({ name: name17, description } = {})=>{\n    return {\n        name: \"json\",\n        responseFormat: Promise.resolve({\n            type: \"json\",\n            ...name17 != null && {\n                name: name17\n            },\n            ...description != null && {\n                description\n            }\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return parseResult.value;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        return result.value === void 0 ? void 0 : {\n                            partial: result.value\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {\n    var _a17;\n    try {\n        if (tools == null) {\n            if (toolCall.providerExecuted && toolCall.dynamic) {\n                return await parseProviderExecutedDynamicToolCall(toolCall);\n            }\n            throw new NoSuchToolError({\n                toolName: toolCall.toolName\n            });\n        }\n        try {\n            return await doParseToolCall({\n                toolCall,\n                tools\n            });\n        } catch (error) {\n            if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n                throw error;\n            }\n            let repairedToolCall = null;\n            try {\n                repairedToolCall = await repairToolCall({\n                    toolCall,\n                    tools,\n                    inputSchema: async ({ toolName })=>{\n                        const { inputSchema } = tools[toolName];\n                        return await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n                    },\n                    system,\n                    messages,\n                    error\n                });\n            } catch (repairError) {\n                throw new ToolCallRepairError({\n                    cause: repairError,\n                    originalError: error\n                });\n            }\n            if (repairedToolCall == null) {\n                throw error;\n            }\n            return await doParseToolCall({\n                toolCall: repairedToolCall,\n                tools\n            });\n        }\n    } catch (error) {\n        const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n            text: toolCall.input\n        });\n        const input = parsedInput.success ? parsedInput.value : toolCall.input;\n        return {\n            type: \"tool-call\",\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            input,\n            dynamic: true,\n            invalid: true,\n            error,\n            title: (_a17 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a17.title,\n            providerExecuted: toolCall.providerExecuted,\n            providerMetadata: toolCall.providerMetadata\n        };\n    }\n}\nasync function parseProviderExecutedDynamicToolCall(toolCall) {\n    const parseResult = toolCall.input.trim() === \"\" ? {\n        success: true,\n        value: {}\n    } : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.input\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolInputError({\n            toolName: toolCall.toolName,\n            toolInput: toolCall.input,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        input: parseResult.value,\n        providerExecuted: true,\n        dynamic: true,\n        providerMetadata: toolCall.providerMetadata\n    };\n}\nasync function doParseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        if (toolCall.providerExecuted && toolCall.dynamic) {\n            return await parseProviderExecutedDynamicToolCall(toolCall);\n        }\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema);\n    const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.input,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolInputError({\n            toolName,\n            toolInput: toolCall.input,\n            cause: parseResult.error\n        });\n    }\n    return tool2.type === \"dynamic\" ? {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        dynamic: true,\n        title: tool2.title\n    } : {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        title: tool2.title\n    };\n}\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n    constructor({ content, finishReason, rawFinishReason, usage, warnings, request, response, providerMetadata }){\n        this.content = content;\n        this.finishReason = finishReason;\n        this.rawFinishReason = rawFinishReason;\n        this.usage = usage;\n        this.warnings = warnings;\n        this.request = request;\n        this.response = response;\n        this.providerMetadata = providerMetadata;\n    }\n    get text() {\n        return this.content.filter((part)=>part.type === \"text\").map((part)=>part.text).join(\"\");\n    }\n    get reasoning() {\n        return this.content.filter((part)=>part.type === \"reasoning\");\n    }\n    get reasoningText() {\n        return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part)=>part.text).join(\"\");\n    }\n    get files() {\n        return this.content.filter((part)=>part.type === \"file\").map((part)=>part.file);\n    }\n    get sources() {\n        return this.content.filter((part)=>part.type === \"source\");\n    }\n    get toolCalls() {\n        return this.content.filter((part)=>part.type === \"tool-call\");\n    }\n    get staticToolCalls() {\n        return this.toolCalls.filter((toolCall)=>toolCall.dynamic !== true);\n    }\n    get dynamicToolCalls() {\n        return this.toolCalls.filter((toolCall)=>toolCall.dynamic === true);\n    }\n    get toolResults() {\n        return this.content.filter((part)=>part.type === \"tool-result\");\n    }\n    get staticToolResults() {\n        return this.toolResults.filter((toolResult)=>toolResult.dynamic !== true);\n    }\n    get dynamicToolResults() {\n        return this.toolResults.filter((toolResult)=>toolResult.dynamic === true);\n    }\n};\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n    return ({ steps })=>steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n    return ({ steps })=>{\n        var _a17, _b, _c;\n        return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some((toolCall)=>toolCall.toolName === toolName)) != null ? _c : false;\n    };\n}\nasync function isStopConditionMet({ stopConditions, steps }) {\n    return (await Promise.all(stopConditions.map((condition)=>condition({\n            steps\n        })))).some((result)=>result);\n}\n// src/generate-text/to-response-messages.ts\nasync function toResponseMessages({ content: inputContent, tools }) {\n    const responseMessages = [];\n    const content = [];\n    for (const part of inputContent){\n        if (part.type === \"source\") {\n            continue;\n        }\n        if ((part.type === \"tool-result\" || part.type === \"tool-error\") && !part.providerExecuted) {\n            continue;\n        }\n        if (part.type === \"text\" && part.text.length === 0) {\n            continue;\n        }\n        switch(part.type){\n            case \"text\":\n                content.push({\n                    type: \"text\",\n                    text: part.text,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"reasoning\":\n                content.push({\n                    type: \"reasoning\",\n                    text: part.text,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"file\":\n                content.push({\n                    type: \"file\",\n                    data: part.file.base64,\n                    mediaType: part.file.mediaType,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"tool-call\":\n                content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName: part.toolName,\n                    input: part.input,\n                    providerExecuted: part.providerExecuted,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"tool-result\":\n                {\n                    const output = await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        tool: tools == null ? void 0 : tools[part.toolName],\n                        output: part.output,\n                        errorMode: \"none\"\n                    });\n                    content.push({\n                        type: \"tool-result\",\n                        toolCallId: part.toolCallId,\n                        toolName: part.toolName,\n                        output,\n                        providerOptions: part.providerMetadata\n                    });\n                    break;\n                }\n            case \"tool-error\":\n                {\n                    const output = await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        tool: tools == null ? void 0 : tools[part.toolName],\n                        output: part.error,\n                        errorMode: \"json\"\n                    });\n                    content.push({\n                        type: \"tool-result\",\n                        toolCallId: part.toolCallId,\n                        toolName: part.toolName,\n                        output,\n                        providerOptions: part.providerMetadata\n                    });\n                    break;\n                }\n            case \"tool-approval-request\":\n                content.push({\n                    type: \"tool-approval-request\",\n                    approvalId: part.approvalId,\n                    toolCallId: part.toolCall.toolCallId\n                });\n                break;\n        }\n    }\n    if (content.length > 0) {\n        responseMessages.push({\n            role: \"assistant\",\n            content\n        });\n    }\n    const toolResultContent = [];\n    for (const part of inputContent){\n        if (!(part.type === \"tool-result\" || part.type === \"tool-error\") || part.providerExecuted) {\n            continue;\n        }\n        const output = await createToolModelOutput({\n            toolCallId: part.toolCallId,\n            input: part.input,\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.type === \"tool-result\" ? part.output : part.error,\n            errorMode: part.type === \"tool-error\" ? \"text\" : \"none\"\n        });\n        toolResultContent.push({\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            output,\n            ...part.providerMetadata != null ? {\n                providerOptions: part.providerMetadata\n            } : {}\n        });\n    }\n    if (toolResultContent.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResultContent\n        });\n    }\n    return responseMessages;\n}\n// src/util/merge-abort-signals.ts\nfunction mergeAbortSignals(...signals) {\n    const validSignals = signals.filter((signal)=>signal != null);\n    if (validSignals.length === 0) {\n        return void 0;\n    }\n    if (validSignals.length === 1) {\n        return validSignals[0];\n    }\n    const controller = new AbortController();\n    for (const signal of validSignals){\n        if (signal.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal.addEventListener(\"abort\", ()=>{\n            controller.abort(signal.reason);\n        }, {\n            once: true\n        });\n    }\n    return controller.signal;\n}\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model: modelArg, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, timeout, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_prepareStep, prepareStep = experimental_prepareStep, experimental_repairToolCall: repairToolCall, experimental_download: download2, experimental_context, _internal: { generateId: generateId2 = originalGenerateId } = {}, onStepFinish, onFinish, ...settings }) {\n    const model = resolveLanguageModel(modelArg);\n    const stopConditions = asArray(stopWhen);\n    const totalTimeoutMs = getTotalTimeoutMs(timeout);\n    const stepTimeoutMs = getStepTimeoutMs(timeout);\n    const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n    const mergedAbortSignal = mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal: mergedAbortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            ...callSettings,\n            maxRetries\n        }\n    });\n    const initialPrompt = await standardizePrompt({\n        system,\n        prompt,\n        messages\n    });\n    const tracer = getTracer(telemetry);\n    try {\n        return await recordSpan({\n            name: \"ai.generateText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.generateText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": model.provider,\n                    \"ai.model.id\": model.modelId,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                var _a17, _b, _c, _d, _e, _f, _g, _h;\n                const initialMessages = initialPrompt.messages;\n                const responseMessages = [];\n                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({\n                    messages: initialMessages\n                });\n                const localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {\n                    const toolOutputs = await executeTools({\n                        toolCalls: localApprovedToolApprovals.map((toolApproval)=>toolApproval.toolCall),\n                        tools,\n                        tracer,\n                        telemetry,\n                        messages: initialMessages,\n                        abortSignal: mergedAbortSignal,\n                        experimental_context\n                    });\n                    const toolContent = [];\n                    for (const output2 of toolOutputs){\n                        const modelOutput = await createToolModelOutput({\n                            toolCallId: output2.toolCallId,\n                            input: output2.input,\n                            tool: tools == null ? void 0 : tools[output2.toolName],\n                            output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                            errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                        });\n                        toolContent.push({\n                            type: \"tool-result\",\n                            toolCallId: output2.toolCallId,\n                            toolName: output2.toolName,\n                            output: modelOutput\n                        });\n                    }\n                    for (const toolApproval of deniedToolApprovals){\n                        toolContent.push({\n                            type: \"tool-result\",\n                            toolCallId: toolApproval.toolCall.toolCallId,\n                            toolName: toolApproval.toolCall.toolName,\n                            output: {\n                                type: \"execution-denied\",\n                                reason: toolApproval.approvalResponse.reason,\n                                // For provider-executed tools, include approvalId so provider can correlate\n                                ...toolApproval.toolCall.providerExecuted && {\n                                    providerOptions: {\n                                        openai: {\n                                            approvalId: toolApproval.approvalResponse.approvalId\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    responseMessages.push({\n                        role: \"tool\",\n                        content: toolContent\n                    });\n                }\n                const providerExecutedToolApprovals = [\n                    ...approvedToolApprovals,\n                    ...deniedToolApprovals\n                ].filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                if (providerExecutedToolApprovals.length > 0) {\n                    responseMessages.push({\n                        role: \"tool\",\n                        content: providerExecutedToolApprovals.map((toolApproval)=>({\n                                type: \"tool-approval-response\",\n                                approvalId: toolApproval.approvalResponse.approvalId,\n                                approved: toolApproval.approvalResponse.approved,\n                                reason: toolApproval.approvalResponse.reason,\n                                providerExecuted: true\n                            }))\n                    });\n                }\n                const callSettings2 = prepareCallSettings(settings);\n                let currentModelResponse;\n                let clientToolCalls = [];\n                let clientToolOutputs = [];\n                const steps = [];\n                const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n                do {\n                    const stepTimeoutId = stepTimeoutMs != null ? setTimeout(()=>stepAbortController.abort(), stepTimeoutMs) : void 0;\n                    try {\n                        const stepInputMessages = [\n                            ...initialMessages,\n                            ...responseMessages\n                        ];\n                        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n                            model,\n                            steps,\n                            stepNumber: steps.length,\n                            messages: stepInputMessages,\n                            experimental_context\n                        }));\n                        const stepModel = resolveLanguageModel((_a17 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a17 : model);\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: {\n                                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n                            },\n                            supportedUrls: await stepModel.supportedUrls,\n                            download: download2\n                        });\n                        experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;\n                        const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n                            tools,\n                            toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,\n                            activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools\n                        });\n                        currentModelResponse = await retry(()=>{\n                            var _a18;\n                            return recordSpan({\n                                name: \"ai.generateText.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateText.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        // model:\n                                        \"ai.model.provider\": stepModel.provider,\n                                        \"ai.model.id\": stepModel.modelId,\n                                        // prompt:\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>stringifyForTelemetry(promptMessages)\n                                        },\n                                        \"ai.prompt.tools\": {\n                                            // convert the language model level tools:\n                                            input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))\n                                        },\n                                        \"ai.prompt.toolChoice\": {\n                                            input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                                        },\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": stepModel.provider,\n                                        \"gen_ai.request.model\": stepModel.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                        \"gen_ai.request.temperature\": (_a18 = settings.temperature) != null ? _a18 : void 0,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a19, _b2, _c2, _d2, _e2, _f2, _g2, _h2;\n                                    const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);\n                                    const result = await stepModel.doGenerate({\n                                        ...callSettings2,\n                                        tools: stepTools,\n                                        toolChoice: stepToolChoice,\n                                        responseFormat: await (output == null ? void 0 : output.responseFormat),\n                                        prompt: promptMessages,\n                                        providerOptions: stepProviderOptions,\n                                        abortSignal: mergedAbortSignal,\n                                        headers: headersWithUserAgent\n                                    });\n                                    const responseData = {\n                                        id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId2(),\n                                        timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date(),\n                                        modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                                        headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                                        body: (_h2 = result.response) == null ? void 0 : _h2.body\n                                    };\n                                    span2.setAttributes(await selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result.finishReason.unified,\n                                            \"ai.response.text\": {\n                                                output: ()=>extractTextContent(result.content)\n                                            },\n                                            \"ai.response.toolCalls\": {\n                                                output: ()=>{\n                                                    const toolCalls = asToolCalls(result.content);\n                                                    return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                                                }\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.response.providerMetadata\": JSON.stringify(result.providerMetadata),\n                                            // TODO rename telemetry attributes to inputTokens and outputTokens\n                                            \"ai.usage.promptTokens\": result.usage.inputTokens.total,\n                                            \"ai.usage.completionTokens\": result.usage.outputTokens.total,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result.finishReason.unified\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result.usage.inputTokens.total,\n                                            \"gen_ai.usage.output_tokens\": result.usage.outputTokens.total\n                                        }\n                                    }));\n                                    return {\n                                        ...result,\n                                        response: responseData\n                                    };\n                                }\n                            });\n                        });\n                        const stepToolCalls = await Promise.all(currentModelResponse.content.filter((part)=>part.type === \"tool-call\").map((toolCall)=>parseToolCall({\n                                toolCall,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages: stepInputMessages\n                            })));\n                        const toolApprovalRequests = {};\n                        for (const toolCall of stepToolCalls){\n                            if (toolCall.invalid) {\n                                continue;\n                            }\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if (tool2 == null) {\n                                continue;\n                            }\n                            if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {\n                                await tool2.onInputAvailable({\n                                    input: toolCall.input,\n                                    toolCallId: toolCall.toolCallId,\n                                    messages: stepInputMessages,\n                                    abortSignal: mergedAbortSignal,\n                                    experimental_context\n                                });\n                            }\n                            if (await isApprovalNeeded({\n                                tool: tool2,\n                                toolCall,\n                                messages: stepInputMessages,\n                                experimental_context\n                            })) {\n                                toolApprovalRequests[toolCall.toolCallId] = {\n                                    type: \"tool-approval-request\",\n                                    approvalId: generateId2(),\n                                    toolCall\n                                };\n                            }\n                        }\n                        const invalidToolCalls = stepToolCalls.filter((toolCall)=>toolCall.invalid && toolCall.dynamic);\n                        clientToolOutputs = [];\n                        for (const toolCall of invalidToolCalls){\n                            clientToolOutputs.push({\n                                type: \"tool-error\",\n                                toolCallId: toolCall.toolCallId,\n                                toolName: toolCall.toolName,\n                                input: toolCall.input,\n                                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                                dynamic: true\n                            });\n                        }\n                        clientToolCalls = stepToolCalls.filter((toolCall)=>!toolCall.providerExecuted);\n                        if (tools != null) {\n                            clientToolOutputs.push(...await executeTools({\n                                toolCalls: clientToolCalls.filter((toolCall)=>!toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null),\n                                tools,\n                                tracer,\n                                telemetry,\n                                messages: stepInputMessages,\n                                abortSignal: mergedAbortSignal,\n                                experimental_context\n                            }));\n                        }\n                        for (const toolCall of stepToolCalls){\n                            if (!toolCall.providerExecuted) continue;\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                                const hasResultInResponse = currentModelResponse.content.some((part)=>part.type === \"tool-result\" && part.toolCallId === toolCall.toolCallId);\n                                if (!hasResultInResponse) {\n                                    pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                                        toolName: toolCall.toolName\n                                    });\n                                }\n                            }\n                        }\n                        for (const part of currentModelResponse.content){\n                            if (part.type === \"tool-result\") {\n                                pendingDeferredToolCalls.delete(part.toolCallId);\n                            }\n                        }\n                        const stepContent = asContent({\n                            content: currentModelResponse.content,\n                            toolCalls: stepToolCalls,\n                            toolOutputs: clientToolOutputs,\n                            toolApprovalRequests: Object.values(toolApprovalRequests),\n                            tools\n                        });\n                        responseMessages.push(...await toResponseMessages({\n                            content: stepContent,\n                            tools\n                        }));\n                        const currentStepResult = new DefaultStepResult({\n                            content: stepContent,\n                            finishReason: currentModelResponse.finishReason.unified,\n                            rawFinishReason: currentModelResponse.finishReason.raw,\n                            usage: asLanguageModelUsage(currentModelResponse.usage),\n                            warnings: currentModelResponse.warnings,\n                            providerMetadata: currentModelResponse.providerMetadata,\n                            request: (_g = currentModelResponse.request) != null ? _g : {},\n                            response: {\n                                ...currentModelResponse.response,\n                                // deep clone msgs to avoid mutating past messages in multi-step:\n                                messages: structuredClone(responseMessages)\n                            }\n                        });\n                        logWarnings({\n                            warnings: (_h = currentModelResponse.warnings) != null ? _h : [],\n                            provider: stepModel.provider,\n                            model: stepModel.modelId\n                        });\n                        steps.push(currentStepResult);\n                        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    } finally{\n                        if (stepTimeoutId != null) {\n                            clearTimeout(stepTimeoutId);\n                        }\n                    }\n                }while (// Continue if:\n                // 1. There are client tool calls that have all been executed, OR\n                // 2. There are pending deferred results from provider-executed tools\n                (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                !await isStopConditionMet({\n                    stopConditions,\n                    steps\n                }));\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.response.finishReason\": currentModelResponse.finishReason.unified,\n                        \"ai.response.text\": {\n                            output: ()=>extractTextContent(currentModelResponse.content)\n                        },\n                        \"ai.response.toolCalls\": {\n                            output: ()=>{\n                                const toolCalls = asToolCalls(currentModelResponse.content);\n                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                            }\n                        },\n                        \"ai.response.providerMetadata\": JSON.stringify(currentModelResponse.providerMetadata),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens.total,\n                        \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens.total\n                    }\n                }));\n                const lastStep = steps[steps.length - 1];\n                const totalUsage = steps.reduce((totalUsage2, step)=>{\n                    return addLanguageModelUsage(totalUsage2, step.usage);\n                }, {\n                    inputTokens: void 0,\n                    outputTokens: void 0,\n                    totalTokens: void 0,\n                    reasoningTokens: void 0,\n                    cachedInputTokens: void 0\n                });\n                await (onFinish == null ? void 0 : onFinish({\n                    finishReason: lastStep.finishReason,\n                    rawFinishReason: lastStep.rawFinishReason,\n                    usage: lastStep.usage,\n                    content: lastStep.content,\n                    text: lastStep.text,\n                    reasoningText: lastStep.reasoningText,\n                    reasoning: lastStep.reasoning,\n                    files: lastStep.files,\n                    sources: lastStep.sources,\n                    toolCalls: lastStep.toolCalls,\n                    staticToolCalls: lastStep.staticToolCalls,\n                    dynamicToolCalls: lastStep.dynamicToolCalls,\n                    toolResults: lastStep.toolResults,\n                    staticToolResults: lastStep.staticToolResults,\n                    dynamicToolResults: lastStep.dynamicToolResults,\n                    request: lastStep.request,\n                    response: lastStep.response,\n                    warnings: lastStep.warnings,\n                    providerMetadata: lastStep.providerMetadata,\n                    steps,\n                    totalUsage,\n                    experimental_context\n                }));\n                let resolvedOutput;\n                if (lastStep.finishReason === \"stop\") {\n                    const outputSpecification = output != null ? output : text();\n                    resolvedOutput = await outputSpecification.parseCompleteOutput({\n                        text: lastStep.text\n                    }, {\n                        response: lastStep.response,\n                        usage: lastStep.usage,\n                        finishReason: lastStep.finishReason\n                    });\n                }\n                return new DefaultGenerateTextResult({\n                    steps,\n                    totalUsage,\n                    output: resolvedOutput\n                });\n            }\n        });\n    } catch (error) {\n        throw wrapGatewayError(error);\n    }\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal, experimental_context }) {\n    const toolOutputs = await Promise.all(toolCalls.map(async (toolCall)=>executeToolCall({\n            toolCall,\n            tools,\n            tracer,\n            telemetry,\n            messages,\n            abortSignal,\n            experimental_context\n        })));\n    return toolOutputs.filter((output)=>output != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.steps = options.steps;\n        this._output = options.output;\n        this.totalUsage = options.totalUsage;\n    }\n    get finalStep() {\n        return this.steps[this.steps.length - 1];\n    }\n    get content() {\n        return this.finalStep.content;\n    }\n    get text() {\n        return this.finalStep.text;\n    }\n    get files() {\n        return this.finalStep.files;\n    }\n    get reasoningText() {\n        return this.finalStep.reasoningText;\n    }\n    get reasoning() {\n        return this.finalStep.reasoning;\n    }\n    get toolCalls() {\n        return this.finalStep.toolCalls;\n    }\n    get staticToolCalls() {\n        return this.finalStep.staticToolCalls;\n    }\n    get dynamicToolCalls() {\n        return this.finalStep.dynamicToolCalls;\n    }\n    get toolResults() {\n        return this.finalStep.toolResults;\n    }\n    get staticToolResults() {\n        return this.finalStep.staticToolResults;\n    }\n    get dynamicToolResults() {\n        return this.finalStep.dynamicToolResults;\n    }\n    get sources() {\n        return this.finalStep.sources;\n    }\n    get finishReason() {\n        return this.finalStep.finishReason;\n    }\n    get rawFinishReason() {\n        return this.finalStep.rawFinishReason;\n    }\n    get warnings() {\n        return this.finalStep.warnings;\n    }\n    get providerMetadata() {\n        return this.finalStep.providerMetadata;\n    }\n    get response() {\n        return this.finalStep.response;\n    }\n    get request() {\n        return this.finalStep.request;\n    }\n    get usage() {\n        return this.finalStep.usage;\n    }\n    get experimental_output() {\n        return this.output;\n    }\n    get output() {\n        if (this._output == null) {\n            throw new NoOutputGeneratedError();\n        }\n        return this._output;\n    }\n};\nfunction asToolCalls(content) {\n    const parts = content.filter((part)=>part.type === \"tool-call\");\n    if (parts.length === 0) {\n        return void 0;\n    }\n    return parts.map((toolCall)=>({\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            input: toolCall.input\n        }));\n}\nfunction asContent({ content, toolCalls, toolOutputs, toolApprovalRequests, tools }) {\n    const contentParts = [];\n    for (const part of content){\n        switch(part.type){\n            case \"text\":\n            case \"reasoning\":\n            case \"source\":\n                contentParts.push(part);\n                break;\n            case \"file\":\n                {\n                    contentParts.push({\n                        type: \"file\",\n                        file: new DefaultGeneratedFile(part),\n                        ...part.providerMetadata != null ? {\n                            providerMetadata: part.providerMetadata\n                        } : {}\n                    });\n                    break;\n                }\n            case \"tool-call\":\n                {\n                    contentParts.push(toolCalls.find((toolCall)=>toolCall.toolCallId === part.toolCallId));\n                    break;\n                }\n            case \"tool-result\":\n                {\n                    const toolCall = toolCalls.find((toolCall2)=>toolCall2.toolCallId === part.toolCallId);\n                    if (toolCall == null) {\n                        const tool2 = tools == null ? void 0 : tools[part.toolName];\n                        const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults;\n                        if (!supportsDeferredResults) {\n                            throw new Error(`Tool call ${part.toolCallId} not found.`);\n                        }\n                        if (part.isError) {\n                            contentParts.push({\n                                type: \"tool-error\",\n                                toolCallId: part.toolCallId,\n                                toolName: part.toolName,\n                                input: void 0,\n                                error: part.result,\n                                providerExecuted: true,\n                                dynamic: part.dynamic\n                            });\n                        } else {\n                            contentParts.push({\n                                type: \"tool-result\",\n                                toolCallId: part.toolCallId,\n                                toolName: part.toolName,\n                                input: void 0,\n                                output: part.result,\n                                providerExecuted: true,\n                                dynamic: part.dynamic\n                            });\n                        }\n                        break;\n                    }\n                    if (part.isError) {\n                        contentParts.push({\n                            type: \"tool-error\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            input: toolCall.input,\n                            error: part.result,\n                            providerExecuted: true,\n                            dynamic: toolCall.dynamic\n                        });\n                    } else {\n                        contentParts.push({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            input: toolCall.input,\n                            output: part.result,\n                            providerExecuted: true,\n                            dynamic: toolCall.dynamic\n                        });\n                    }\n                    break;\n                }\n            case \"tool-approval-request\":\n                {\n                    const toolCall = toolCalls.find((toolCall2)=>toolCall2.toolCallId === part.toolCallId);\n                    if (toolCall == null) {\n                        throw new ToolCallNotFoundForApprovalError({\n                            toolCallId: part.toolCallId,\n                            approvalId: part.approvalId\n                        });\n                    }\n                    contentParts.push({\n                        type: \"tool-approval-request\",\n                        approvalId: part.approvalId,\n                        toolCall\n                    });\n                    break;\n                }\n        }\n    }\n    return [\n        ...contentParts,\n        ...toolOutputs,\n        ...toolApprovalRequests\n    ];\n}\n// src/generate-text/stream-text.ts\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n    const responseHeaders = new Headers(headers != null ? headers : {});\n    for (const [key, value] of Object.entries(defaultHeaders)){\n        if (!responseHeaders.has(key)) {\n            responseHeaders.set(key, value);\n        }\n    }\n    return responseHeaders;\n}\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({ status, statusText, headers, textStream }) {\n    return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n        status: status != null ? status : 200,\n        statusText,\n        headers: prepareHeaders(headers, {\n            \"content-type\": \"text/plain; charset=utf-8\"\n        })\n    });\n}\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    const statusCode = status != null ? status : 200;\n    if (statusText !== void 0) {\n        response.writeHead(statusCode, statusText, headers);\n    } else {\n        response.writeHead(statusCode, headers);\n    }\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                const canContinue = response.write(value);\n                if (!canContinue) {\n                    await new Promise((resolve3)=>{\n                        response.once(\"drain\", resolve3);\n                    });\n                }\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({ response, status, statusText, headers, textStream }) {\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: Object.fromEntries(prepareHeaders(headers, {\n            \"content-type\": \"text/plain; charset=utf-8\"\n        }).entries()),\n        stream: textStream.pipeThrough(new TextEncoderStream())\n    });\n}\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n    constructor(){\n        super({\n            transform (part, controller) {\n                controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n            },\n            flush (controller) {\n                controller.enqueue(\"data: [DONE]\\n\\n\");\n            }\n        });\n    }\n};\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n    \"content-type\": \"text/event-stream\",\n    \"cache-control\": \"no-cache\",\n    connection: \"keep-alive\",\n    \"x-vercel-ai-ui-message-stream\": \"v1\",\n    \"x-accel-buffering\": \"no\"\n};\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({ status, statusText, headers, stream, consumeSseStream }) {\n    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n    if (consumeSseStream) {\n        const [stream1, stream2] = sseStream.tee();\n        sseStream = stream1;\n        consumeSseStream({\n            stream: stream2\n        });\n    }\n    return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n        status,\n        statusText,\n        headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n    });\n}\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({ originalMessages, responseMessageId }) {\n    if (originalMessages == null) {\n        return void 0;\n    }\n    const lastMessage = originalMessages[originalMessages.length - 1];\n    return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n// src/ui/process-ui-message-stream.ts\n\n// src/ui-message-stream/ui-message-chunks.ts\n\n\nvar uiMessageChunkSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(()=>(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-start\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-delta\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-end\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error\"),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-start\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-delta\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-available\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-error\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-request\"),\n            approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-available\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-error\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-denied\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-start\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-delta\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-end\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-url\"),\n            sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-document\"),\n            sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.custom((value)=>typeof value === \"string\" && value.startsWith(\"data-\"), {\n                message: 'Type must start with \"data-\"'\n            }),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n            transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"start-step\")\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"finish-step\")\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"start\"),\n            messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"finish\"),\n            finishReason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.enum([\n                \"stop\",\n                \"length\",\n                \"content-filter\",\n                \"tool-calls\",\n                \"error\",\n                \"other\"\n            ]).optional(),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"abort\"),\n            reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"message-metadata\"),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n        })\n    ])));\nfunction isDataUIMessageChunk(chunk) {\n    return chunk.type.startsWith(\"data-\");\n}\n// src/ui/ui-messages.ts\nfunction isDataUIPart(part) {\n    return part.type.startsWith(\"data-\");\n}\nfunction isTextUIPart(part) {\n    return part.type === \"text\";\n}\nfunction isFileUIPart(part) {\n    return part.type === \"file\";\n}\nfunction isReasoningUIPart(part) {\n    return part.type === \"reasoning\";\n}\nfunction isStaticToolUIPart(part) {\n    return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n    return part.type === \"dynamic-tool\";\n}\nfunction isToolUIPart(part) {\n    return isStaticToolUIPart(part) || isDynamicToolUIPart(part);\n}\nvar isToolOrDynamicToolUIPart = isToolUIPart;\nfunction getStaticToolName(part) {\n    return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolName(part) {\n    return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);\n}\nvar getToolOrDynamicToolName = getToolName;\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({ lastMessage, messageId }) {\n    return {\n        message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n            id: messageId,\n            metadata: void 0,\n            role: \"assistant\",\n            parts: []\n        },\n        activeTextParts: {},\n        activeReasoningParts: {},\n        partialToolCalls: {}\n    };\n}\nfunction processUIMessageStream({ stream, messageMetadataSchema, dataPartSchemas, runUpdateMessageJob, onError, onToolCall, onData }) {\n    return stream.pipeThrough(new TransformStream({\n        async transform (chunk, controller) {\n            await runUpdateMessageJob(async ({ state, write })=>{\n                var _a17, _b, _c, _d;\n                function getToolInvocation(toolCallId) {\n                    const toolInvocations = state.message.parts.filter(isToolUIPart);\n                    const toolInvocation = toolInvocations.find((invocation)=>invocation.toolCallId === toolCallId);\n                    if (toolInvocation == null) {\n                        throw new UIMessageStreamError({\n                            chunkType: \"tool-invocation\",\n                            chunkId: toolCallId,\n                            message: `No tool invocation found for tool call ID \"${toolCallId}\".`\n                        });\n                    }\n                    return toolInvocation;\n                }\n                function updateToolPart(options) {\n                    var _a18;\n                    const part = state.message.parts.find((part2)=>isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId);\n                    const anyOptions = options;\n                    const anyPart = part;\n                    if (part != null) {\n                        part.state = options.state;\n                        anyPart.input = anyOptions.input;\n                        anyPart.output = anyOptions.output;\n                        anyPart.errorText = anyOptions.errorText;\n                        anyPart.rawInput = anyOptions.rawInput;\n                        anyPart.preliminary = anyOptions.preliminary;\n                        if (options.title !== void 0) {\n                            anyPart.title = options.title;\n                        }\n                        anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;\n                        if (anyOptions.providerMetadata != null) {\n                            part.callProviderMetadata = anyOptions.providerMetadata;\n                        }\n                    } else {\n                        state.message.parts.push({\n                            type: `tool-${options.toolName}`,\n                            toolCallId: options.toolCallId,\n                            state: options.state,\n                            title: options.title,\n                            input: anyOptions.input,\n                            output: anyOptions.output,\n                            rawInput: anyOptions.rawInput,\n                            errorText: anyOptions.errorText,\n                            providerExecuted: anyOptions.providerExecuted,\n                            preliminary: anyOptions.preliminary,\n                            ...anyOptions.providerMetadata != null ? {\n                                callProviderMetadata: anyOptions.providerMetadata\n                            } : {}\n                        });\n                    }\n                }\n                function updateDynamicToolPart(options) {\n                    var _a18, _b2;\n                    const part = state.message.parts.find((part2)=>part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId);\n                    const anyOptions = options;\n                    const anyPart = part;\n                    if (part != null) {\n                        part.state = options.state;\n                        anyPart.toolName = options.toolName;\n                        anyPart.input = anyOptions.input;\n                        anyPart.output = anyOptions.output;\n                        anyPart.errorText = anyOptions.errorText;\n                        anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;\n                        anyPart.preliminary = anyOptions.preliminary;\n                        if (options.title !== void 0) {\n                            anyPart.title = options.title;\n                        }\n                        anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n                        if (anyOptions.providerMetadata != null) {\n                            part.callProviderMetadata = anyOptions.providerMetadata;\n                        }\n                    } else {\n                        state.message.parts.push({\n                            type: \"dynamic-tool\",\n                            toolName: options.toolName,\n                            toolCallId: options.toolCallId,\n                            state: options.state,\n                            input: anyOptions.input,\n                            output: anyOptions.output,\n                            errorText: anyOptions.errorText,\n                            preliminary: anyOptions.preliminary,\n                            providerExecuted: anyOptions.providerExecuted,\n                            title: options.title,\n                            ...anyOptions.providerMetadata != null ? {\n                                callProviderMetadata: anyOptions.providerMetadata\n                            } : {}\n                        });\n                    }\n                }\n                async function updateMessageMetadata(metadata) {\n                    if (metadata != null) {\n                        const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n                        if (messageMetadataSchema != null) {\n                            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                                value: mergedMetadata,\n                                schema: messageMetadataSchema\n                            });\n                        }\n                        state.message.metadata = mergedMetadata;\n                    }\n                }\n                switch(chunk.type){\n                    case \"text-start\":\n                        {\n                            const textPart = {\n                                type: \"text\",\n                                text: \"\",\n                                providerMetadata: chunk.providerMetadata,\n                                state: \"streaming\"\n                            };\n                            state.activeTextParts[chunk.id] = textPart;\n                            state.message.parts.push(textPart);\n                            write();\n                            break;\n                        }\n                    case \"text-delta\":\n                        {\n                            const textPart = state.activeTextParts[chunk.id];\n                            if (textPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"text-delta\",\n                                    chunkId: chunk.id,\n                                    message: `Received text-delta for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-delta\" chunks.`\n                                });\n                            }\n                            textPart.text += chunk.delta;\n                            textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;\n                            write();\n                            break;\n                        }\n                    case \"text-end\":\n                        {\n                            const textPart = state.activeTextParts[chunk.id];\n                            if (textPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"text-end\",\n                                    chunkId: chunk.id,\n                                    message: `Received text-end for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-end\" chunks.`\n                                });\n                            }\n                            textPart.state = \"done\";\n                            textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n                            delete state.activeTextParts[chunk.id];\n                            write();\n                            break;\n                        }\n                    case \"reasoning-start\":\n                        {\n                            const reasoningPart = {\n                                type: \"reasoning\",\n                                text: \"\",\n                                providerMetadata: chunk.providerMetadata,\n                                state: \"streaming\"\n                            };\n                            state.activeReasoningParts[chunk.id] = reasoningPart;\n                            state.message.parts.push(reasoningPart);\n                            write();\n                            break;\n                        }\n                    case \"reasoning-delta\":\n                        {\n                            const reasoningPart = state.activeReasoningParts[chunk.id];\n                            if (reasoningPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"reasoning-delta\",\n                                    chunkId: chunk.id,\n                                    message: `Received reasoning-delta for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-delta\" chunks.`\n                                });\n                            }\n                            reasoningPart.text += chunk.delta;\n                            reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n                            write();\n                            break;\n                        }\n                    case \"reasoning-end\":\n                        {\n                            const reasoningPart = state.activeReasoningParts[chunk.id];\n                            if (reasoningPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"reasoning-end\",\n                                    chunkId: chunk.id,\n                                    message: `Received reasoning-end for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-end\" chunks.`\n                                });\n                            }\n                            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n                            reasoningPart.state = \"done\";\n                            delete state.activeReasoningParts[chunk.id];\n                            write();\n                            break;\n                        }\n                    case \"file\":\n                        {\n                            state.message.parts.push({\n                                type: \"file\",\n                                mediaType: chunk.mediaType,\n                                url: chunk.url\n                            });\n                            write();\n                            break;\n                        }\n                    case \"source-url\":\n                        {\n                            state.message.parts.push({\n                                type: \"source-url\",\n                                sourceId: chunk.sourceId,\n                                url: chunk.url,\n                                title: chunk.title,\n                                providerMetadata: chunk.providerMetadata\n                            });\n                            write();\n                            break;\n                        }\n                    case \"source-document\":\n                        {\n                            state.message.parts.push({\n                                type: \"source-document\",\n                                sourceId: chunk.sourceId,\n                                mediaType: chunk.mediaType,\n                                title: chunk.title,\n                                filename: chunk.filename,\n                                providerMetadata: chunk.providerMetadata\n                            });\n                            write();\n                            break;\n                        }\n                    case \"tool-input-start\":\n                        {\n                            const toolInvocations = state.message.parts.filter(isStaticToolUIPart);\n                            state.partialToolCalls[chunk.toolCallId] = {\n                                text: \"\",\n                                toolName: chunk.toolName,\n                                index: toolInvocations.length,\n                                dynamic: chunk.dynamic,\n                                title: chunk.title\n                            };\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-streaming\",\n                                    input: void 0,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: chunk.title,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-streaming\",\n                                    input: void 0,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: chunk.title,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-input-delta\":\n                        {\n                            const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n                            if (partialToolCall == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"tool-input-delta\",\n                                    chunkId: chunk.toolCallId,\n                                    message: `Received tool-input-delta for missing tool call with ID \"${chunk.toolCallId}\". Ensure a \"tool-input-start\" chunk is sent before any \"tool-input-delta\" chunks.`\n                                });\n                            }\n                            partialToolCall.text += chunk.inputTextDelta;\n                            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);\n                            if (partialToolCall.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: partialToolCall.toolName,\n                                    state: \"input-streaming\",\n                                    input: partialArgs,\n                                    title: partialToolCall.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: partialToolCall.toolName,\n                                    state: \"input-streaming\",\n                                    input: partialArgs,\n                                    title: partialToolCall.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-input-available\":\n                        {\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-available\",\n                                    input: chunk.input,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata,\n                                    title: chunk.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-available\",\n                                    input: chunk.input,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata,\n                                    title: chunk.title\n                                });\n                            }\n                            write();\n                            if (onToolCall && !chunk.providerExecuted) {\n                                await onToolCall({\n                                    toolCall: chunk\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-input-error\":\n                        {\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"output-error\",\n                                    input: chunk.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"output-error\",\n                                    input: void 0,\n                                    rawInput: chunk.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-approval-request\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            toolInvocation.state = \"approval-requested\";\n                            toolInvocation.approval = {\n                                id: chunk.approvalId\n                            };\n                            write();\n                            break;\n                        }\n                    case \"tool-output-denied\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            toolInvocation.state = \"output-denied\";\n                            write();\n                            break;\n                        }\n                    case \"tool-output-available\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            if (toolInvocation.type === \"dynamic-tool\") {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: toolInvocation.toolName,\n                                    state: \"output-available\",\n                                    input: toolInvocation.input,\n                                    output: chunk.output,\n                                    preliminary: chunk.preliminary,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: getStaticToolName(toolInvocation),\n                                    state: \"output-available\",\n                                    input: toolInvocation.input,\n                                    output: chunk.output,\n                                    providerExecuted: chunk.providerExecuted,\n                                    preliminary: chunk.preliminary,\n                                    title: toolInvocation.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-output-error\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            if (toolInvocation.type === \"dynamic-tool\") {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: toolInvocation.toolName,\n                                    state: \"output-error\",\n                                    input: toolInvocation.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: getStaticToolName(toolInvocation),\n                                    state: \"output-error\",\n                                    input: toolInvocation.input,\n                                    rawInput: toolInvocation.rawInput,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"start-step\":\n                        {\n                            state.message.parts.push({\n                                type: \"step-start\"\n                            });\n                            break;\n                        }\n                    case \"finish-step\":\n                        {\n                            state.activeTextParts = {};\n                            state.activeReasoningParts = {};\n                            break;\n                        }\n                    case \"start\":\n                        {\n                            if (chunk.messageId != null) {\n                                state.message.id = chunk.messageId;\n                            }\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageId != null || chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (chunk.finishReason != null) {\n                                state.finishReason = chunk.finishReason;\n                            }\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"message-metadata\":\n                        {\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            onError == null ? void 0 : onError(new Error(chunk.errorText));\n                            break;\n                        }\n                    default:\n                        {\n                            if (isDataUIMessageChunk(chunk)) {\n                                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                                    await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                                        value: chunk.data,\n                                        schema: dataPartSchemas[chunk.type]\n                                    });\n                                }\n                                const dataChunk = chunk;\n                                if (dataChunk.transient) {\n                                    onData == null ? void 0 : onData(dataChunk);\n                                    break;\n                                }\n                                const existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg)=>dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : void 0;\n                                if (existingUIPart != null) {\n                                    existingUIPart.data = dataChunk.data;\n                                } else {\n                                    state.message.parts.push(dataChunk);\n                                }\n                                onData == null ? void 0 : onData(dataChunk);\n                                write();\n                            }\n                        }\n                }\n                controller.enqueue(chunk);\n            });\n        }\n    }));\n}\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({ messageId, originalMessages = [], onFinish, onError, stream }) {\n    let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n    if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n        lastMessage = void 0;\n    } else {\n        messageId = lastMessage.id;\n    }\n    let isAborted = false;\n    const idInjectedStream = stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk.type === \"start\") {\n                const startChunk = chunk;\n                if (startChunk.messageId == null && messageId != null) {\n                    startChunk.messageId = messageId;\n                }\n            }\n            if (chunk.type === \"abort\") {\n                isAborted = true;\n            }\n            controller.enqueue(chunk);\n        }\n    }));\n    if (onFinish == null) {\n        return idInjectedStream;\n    }\n    const state = createStreamingUIMessageState({\n        lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n        messageId: messageId != null ? messageId : \"\"\n    });\n    const runUpdateMessageJob = async (job)=>{\n        await job({\n            state,\n            write: ()=>{}\n        });\n    };\n    let finishCalled = false;\n    const callOnFinish = async ()=>{\n        if (finishCalled || !onFinish) {\n            return;\n        }\n        finishCalled = true;\n        const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n        await onFinish({\n            isAborted,\n            isContinuation,\n            responseMessage: state.message,\n            messages: [\n                ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n                state.message\n            ],\n            finishReason: state.finishReason\n        });\n    };\n    return processUIMessageStream({\n        stream: idInjectedStream,\n        runUpdateMessageJob,\n        onError\n    }).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n        },\n        // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n        async cancel () {\n            await callOnFinish();\n        },\n        async flush () {\n            await callOnFinish();\n        }\n    }));\n}\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({ response, status, statusText, headers, stream, consumeSseStream }) {\n    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n    if (consumeSseStream) {\n        const [stream1, stream2] = sseStream.tee();\n        sseStream = stream1;\n        consumeSseStream({\n            stream: stream2\n        });\n    }\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: Object.fromEntries(prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()),\n        stream: sseStream.pipeThrough(new TextEncoderStream())\n    });\n}\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n    const stream = source.pipeThrough(new TransformStream());\n    stream[Symbol.asyncIterator] = function() {\n        const reader = this.getReader();\n        let finished = false;\n        async function cleanup(cancelStream) {\n            var _a17;\n            if (finished) return;\n            finished = true;\n            try {\n                if (cancelStream) {\n                    await ((_a17 = reader.cancel) == null ? void 0 : _a17.call(reader));\n                }\n            } finally{\n                try {\n                    reader.releaseLock();\n                } catch (e) {}\n            }\n        }\n        return {\n            /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */ async next () {\n                if (finished) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const { done, value } = await reader.read();\n                if (done) {\n                    await cleanup(true);\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                return {\n                    done: false,\n                    value\n                };\n            },\n            /**\n       * May be called on early exit (e.g., break from for-await) or after completion.\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */ async return () {\n                await cleanup(true);\n                return {\n                    done: true,\n                    value: void 0\n                };\n            },\n            /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */ async throw (err) {\n                await cleanup(true);\n                throw err;\n            }\n        };\n    };\n    return stream;\n}\n// src/util/consume-stream.ts\nasync function consumeStream({ stream, onError }) {\n    const reader = stream.getReader();\n    try {\n        while(true){\n            const { done } = await reader.read();\n            if (done) break;\n        }\n    } catch (error) {\n        onError == null ? void 0 : onError(error);\n    } finally{\n        reader.releaseLock();\n    }\n}\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve3;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve3 = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve: resolve3,\n        reject\n    };\n}\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    let waitForNewStream = createResolvablePromise();\n    const terminate = ()=>{\n        isClosed = true;\n        waitForNewStream.resolve();\n        innerStreamReaders.forEach((reader)=>reader.cancel());\n        innerStreamReaders = [];\n        controller == null ? void 0 : controller.close();\n    };\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            waitForNewStream = createResolvablePromise();\n            await waitForNewStream.promise;\n            return processPull();\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length === 0 && isClosed) {\n                    controller == null ? void 0 : controller.close();\n                } else {\n                    await processPull();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            terminate();\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n            waitForNewStream.resolve();\n        },\n        /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */ close: ()=>{\n            isClosed = true;\n            waitForNewStream.resolve();\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        },\n        /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */ terminate\n    };\n}\n// src/util/now.ts\nfunction now() {\n    var _a17, _b;\n    return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, tracer, telemetry, system, messages, abortSignal, repairToolCall, experimental_context, generateId: generateId2 }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    const toolInputs = /* @__PURE__ */ new Map();\n    const toolCallsByToolCallId = /* @__PURE__ */ new Map();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        async transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"stream-start\":\n                case \"text-start\":\n                case \"text-delta\":\n                case \"text-end\":\n                case \"reasoning-start\":\n                case \"reasoning-delta\":\n                case \"reasoning-end\":\n                case \"tool-input-start\":\n                case \"tool-input-delta\":\n                case \"tool-input-end\":\n                case \"source\":\n                case \"response-metadata\":\n                case \"error\":\n                case \"raw\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"file\":\n                    {\n                        controller.enqueue({\n                            type: \"file\",\n                            file: new DefaultGeneratedFileWithType({\n                                data: chunk.data,\n                                mediaType: chunk.mediaType\n                            })\n                        });\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason.unified,\n                            rawFinishReason: chunk.finishReason.raw,\n                            usage: asLanguageModelUsage(chunk.usage),\n                            providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                case \"tool-approval-request\":\n                    {\n                        const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);\n                        if (toolCall == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new ToolCallNotFoundForApprovalError({\n                                    toolCallId: chunk.toolCallId,\n                                    approvalId: chunk.approvalId\n                                })\n                            });\n                            break;\n                        }\n                        controller.enqueue({\n                            type: \"tool-approval-request\",\n                            approvalId: chunk.approvalId,\n                            toolCall\n                        });\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        try {\n                            const toolCall = await parseToolCall({\n                                toolCall: chunk,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages\n                            });\n                            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);\n                            controller.enqueue(toolCall);\n                            if (toolCall.invalid) {\n                                toolResultsStreamController.enqueue({\n                                    type: \"tool-error\",\n                                    toolCallId: toolCall.toolCallId,\n                                    toolName: toolCall.toolName,\n                                    input: toolCall.input,\n                                    error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                                    dynamic: true,\n                                    title: toolCall.title\n                                });\n                                break;\n                            }\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if (tool2 == null) {\n                                break;\n                            }\n                            if (tool2.onInputAvailable != null) {\n                                await tool2.onInputAvailable({\n                                    input: toolCall.input,\n                                    toolCallId: toolCall.toolCallId,\n                                    messages,\n                                    abortSignal,\n                                    experimental_context\n                                });\n                            }\n                            if (await isApprovalNeeded({\n                                tool: tool2,\n                                toolCall,\n                                messages,\n                                experimental_context\n                            })) {\n                                toolResultsStreamController.enqueue({\n                                    type: \"tool-approval-request\",\n                                    approvalId: generateId2(),\n                                    toolCall\n                                });\n                                break;\n                            }\n                            toolInputs.set(toolCall.toolCallId, toolCall.input);\n                            if (tool2.execute != null && toolCall.providerExecuted !== true) {\n                                const toolExecutionId = generateId2();\n                                outstandingToolResults.add(toolExecutionId);\n                                executeToolCall({\n                                    toolCall,\n                                    tools,\n                                    tracer,\n                                    telemetry,\n                                    messages,\n                                    abortSignal,\n                                    experimental_context,\n                                    onPreliminaryToolResult: (result)=>{\n                                        toolResultsStreamController.enqueue(result);\n                                    }\n                                }).then((result)=>{\n                                    toolResultsStreamController.enqueue(result);\n                                }).catch((error)=>{\n                                    toolResultsStreamController.enqueue({\n                                        type: \"error\",\n                                        error\n                                    });\n                                }).finally(()=>{\n                                    outstandingToolResults.delete(toolExecutionId);\n                                    attemptClose();\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-result\":\n                    {\n                        const toolName = chunk.toolName;\n                        if (chunk.isError) {\n                            toolResultsStreamController.enqueue({\n                                type: \"tool-error\",\n                                toolCallId: chunk.toolCallId,\n                                toolName,\n                                input: toolInputs.get(chunk.toolCallId),\n                                providerExecuted: true,\n                                error: chunk.result,\n                                dynamic: chunk.dynamic\n                            });\n                        } else {\n                            controller.enqueue({\n                                type: \"tool-result\",\n                                toolCallId: chunk.toolCallId,\n                                toolName,\n                                input: toolInputs.get(chunk.toolCallId),\n                                output: chunk.result,\n                                providerExecuted: true,\n                                dynamic: chunk.dynamic\n                            });\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nfunction streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, timeout, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, prepareStep, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, experimental_download: download2, includeRawChunks = false, onChunk, onError = ({ error })=>{\n    console.error(error);\n}, onFinish, onAbort, onStepFinish, experimental_context, _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2 } = {}, ...settings }) {\n    const totalTimeoutMs = getTotalTimeoutMs(timeout);\n    const stepTimeoutMs = getStepTimeoutMs(timeout);\n    const chunkTimeoutMs = getChunkTimeoutMs(timeout);\n    const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n    const chunkAbortController = chunkTimeoutMs != null ? new AbortController() : void 0;\n    return new DefaultStreamTextResult({\n        model: resolveLanguageModel(model),\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal: mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal, chunkAbortController == null ? void 0 : chunkAbortController.signal),\n        stepTimeoutMs,\n        stepAbortController,\n        chunkTimeoutMs,\n        chunkAbortController,\n        system,\n        prompt,\n        messages,\n        tools,\n        toolChoice,\n        transforms: asArray(transform),\n        activeTools,\n        repairToolCall,\n        stopConditions: asArray(stopWhen),\n        output,\n        providerOptions,\n        prepareStep,\n        includeRawChunks,\n        onChunk,\n        onError,\n        onFinish,\n        onAbort,\n        onStepFinish,\n        now: now2,\n        generateId: generateId2,\n        experimental_context,\n        download: download2\n    });\n}\nfunction createOutputTransformStream(output) {\n    let firstTextChunkId = void 0;\n    let text2 = \"\";\n    let textChunk = \"\";\n    let textProviderMetadata = void 0;\n    let lastPublishedJson = \"\";\n    function publishTextChunk({ controller, partialOutput = void 0 }) {\n        controller.enqueue({\n            part: {\n                type: \"text-delta\",\n                id: firstTextChunkId,\n                text: textChunk,\n                providerMetadata: textProviderMetadata\n            },\n            partialOutput\n        });\n        textChunk = \"\";\n    }\n    return new TransformStream({\n        async transform (chunk, controller) {\n            var _a17;\n            if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n                publishTextChunk({\n                    controller\n                });\n            }\n            if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (firstTextChunkId == null) {\n                firstTextChunkId = chunk.id;\n            } else if (chunk.id !== firstTextChunkId) {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (chunk.type === \"text-start\") {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (chunk.type === \"text-end\") {\n                if (textChunk.length > 0) {\n                    publishTextChunk({\n                        controller\n                    });\n                }\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            text2 += chunk.text;\n            textChunk += chunk.text;\n            textProviderMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textProviderMetadata;\n            const result = await output.parsePartialOutput({\n                text: text2\n            });\n            if (result !== void 0) {\n                const currentJson = JSON.stringify(result.partial);\n                if (currentJson !== lastPublishedJson) {\n                    publishTextChunk({\n                        controller,\n                        partialOutput: result.partial\n                    });\n                    lastPublishedJson = currentJson;\n                }\n            }\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, stepTimeoutMs, stepAbortController, chunkTimeoutMs, chunkAbortController, system, prompt, messages, tools, toolChoice, transforms, activeTools, repairToolCall, stopConditions, output, providerOptions, prepareStep, includeRawChunks, now: now2, generateId: generateId2, onChunk, onError, onFinish, onAbort, onStepFinish, experimental_context, download: download2 }){\n        this._totalUsage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._rawFinishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._steps = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this.outputSpecification = output;\n        this.includeRawChunks = includeRawChunks;\n        this.tools = tools;\n        let stepFinish;\n        let recordedContent = [];\n        const recordedResponseMessages = [];\n        let recordedFinishReason = void 0;\n        let recordedRawFinishReason = void 0;\n        let recordedTotalUsage = void 0;\n        let recordedRequest = {};\n        let recordedWarnings = [];\n        const recordedSteps = [];\n        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n        let rootSpan;\n        let activeTextContent = {};\n        let activeReasoningContent = {};\n        const eventProcessor = new TransformStream({\n            async transform (chunk, controller) {\n                var _a17, _b, _c, _d;\n                controller.enqueue(chunk);\n                const { part } = chunk;\n                if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n                    await (onChunk == null ? void 0 : onChunk({\n                        chunk: part\n                    }));\n                }\n                if (part.type === \"error\") {\n                    await onError({\n                        error: wrapGatewayError(part.error)\n                    });\n                }\n                if (part.type === \"text-start\") {\n                    activeTextContent[part.id] = {\n                        type: \"text\",\n                        text: \"\",\n                        providerMetadata: part.providerMetadata\n                    };\n                    recordedContent.push(activeTextContent[part.id]);\n                }\n                if (part.type === \"text-delta\") {\n                    const activeText = activeTextContent[part.id];\n                    if (activeText == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `text part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeText.text += part.text;\n                    activeText.providerMetadata = (_a17 = part.providerMetadata) != null ? _a17 : activeText.providerMetadata;\n                }\n                if (part.type === \"text-end\") {\n                    const activeText = activeTextContent[part.id];\n                    if (activeText == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `text part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeText.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeText.providerMetadata;\n                    delete activeTextContent[part.id];\n                }\n                if (part.type === \"reasoning-start\") {\n                    activeReasoningContent[part.id] = {\n                        type: \"reasoning\",\n                        text: \"\",\n                        providerMetadata: part.providerMetadata\n                    };\n                    recordedContent.push(activeReasoningContent[part.id]);\n                }\n                if (part.type === \"reasoning-delta\") {\n                    const activeReasoning = activeReasoningContent[part.id];\n                    if (activeReasoning == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `reasoning part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeReasoning.text += part.text;\n                    activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n                }\n                if (part.type === \"reasoning-end\") {\n                    const activeReasoning = activeReasoningContent[part.id];\n                    if (activeReasoning == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `reasoning part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;\n                    delete activeReasoningContent[part.id];\n                }\n                if (part.type === \"file\") {\n                    recordedContent.push({\n                        type: \"file\",\n                        file: part.file\n                    });\n                }\n                if (part.type === \"source\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-call\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-result\" && !part.preliminary) {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-approval-request\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-error\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"start-step\") {\n                    recordedContent = [];\n                    activeReasoningContent = {};\n                    activeTextContent = {};\n                    recordedRequest = part.request;\n                    recordedWarnings = part.warnings;\n                }\n                if (part.type === \"finish-step\") {\n                    const stepMessages = await toResponseMessages({\n                        content: recordedContent,\n                        tools\n                    });\n                    const currentStepResult = new DefaultStepResult({\n                        content: recordedContent,\n                        finishReason: part.finishReason,\n                        rawFinishReason: part.rawFinishReason,\n                        usage: part.usage,\n                        warnings: recordedWarnings,\n                        request: recordedRequest,\n                        response: {\n                            ...part.response,\n                            messages: [\n                                ...recordedResponseMessages,\n                                ...stepMessages\n                            ]\n                        },\n                        providerMetadata: part.providerMetadata\n                    });\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    logWarnings({\n                        warnings: recordedWarnings,\n                        provider: model.provider,\n                        model: model.modelId\n                    });\n                    recordedSteps.push(currentStepResult);\n                    recordedResponseMessages.push(...stepMessages);\n                    stepFinish.resolve();\n                }\n                if (part.type === \"finish\") {\n                    recordedTotalUsage = part.totalUsage;\n                    recordedFinishReason = part.finishReason;\n                    recordedRawFinishReason = part.rawFinishReason;\n                }\n            },\n            async flush (controller) {\n                try {\n                    if (recordedSteps.length === 0) {\n                        const error = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({\n                            message: \"No output generated. Check the stream for errors.\"\n                        });\n                        self._finishReason.reject(error);\n                        self._rawFinishReason.reject(error);\n                        self._totalUsage.reject(error);\n                        self._steps.reject(error);\n                        return;\n                    }\n                    const finishReason = recordedFinishReason != null ? recordedFinishReason : \"other\";\n                    const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();\n                    self._finishReason.resolve(finishReason);\n                    self._rawFinishReason.resolve(recordedRawFinishReason);\n                    self._totalUsage.resolve(totalUsage);\n                    self._steps.resolve(recordedSteps);\n                    const finalStep = recordedSteps[recordedSteps.length - 1];\n                    await (onFinish == null ? void 0 : onFinish({\n                        finishReason: finalStep.finishReason,\n                        rawFinishReason: finalStep.rawFinishReason,\n                        totalUsage,\n                        usage: finalStep.usage,\n                        content: finalStep.content,\n                        text: finalStep.text,\n                        reasoningText: finalStep.reasoningText,\n                        reasoning: finalStep.reasoning,\n                        files: finalStep.files,\n                        sources: finalStep.sources,\n                        toolCalls: finalStep.toolCalls,\n                        staticToolCalls: finalStep.staticToolCalls,\n                        dynamicToolCalls: finalStep.dynamicToolCalls,\n                        toolResults: finalStep.toolResults,\n                        staticToolResults: finalStep.staticToolResults,\n                        dynamicToolResults: finalStep.dynamicToolResults,\n                        request: finalStep.request,\n                        response: finalStep.response,\n                        warnings: finalStep.warnings,\n                        providerMetadata: finalStep.providerMetadata,\n                        steps: recordedSteps,\n                        experimental_context\n                    }));\n                    rootSpan.setAttributes(await selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.text\": {\n                                output: ()=>finalStep.text\n                            },\n                            \"ai.response.toolCalls\": {\n                                output: ()=>{\n                                    var _a17;\n                                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                                }\n                            },\n                            \"ai.response.providerMetadata\": JSON.stringify(finalStep.providerMetadata),\n                            \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                            \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                            \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                            \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                            \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n                        }\n                    }));\n                } catch (error) {\n                    controller.error(error);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        });\n        const stitchableStream = createStitchableStream();\n        this.addStream = stitchableStream.addStream;\n        this.closeStream = stitchableStream.close;\n        const reader = stitchableStream.stream.getReader();\n        let stream = new ReadableStream({\n            async start (controller) {\n                controller.enqueue({\n                    type: \"start\"\n                });\n            },\n            async pull (controller) {\n                function abort() {\n                    onAbort == null ? void 0 : onAbort({\n                        steps: recordedSteps\n                    });\n                    controller.enqueue({\n                        type: \"abort\",\n                        // The `reason` is usually of type DOMException, but it can also be of any type,\n                        // so we use getErrorMessage for serialization because it is already designed to accept values of the unknown type.\n                        // See: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason\n                        ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? {\n                            reason: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(abortSignal.reason)\n                        } : {}\n                    });\n                    controller.close();\n                }\n                try {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        controller.close();\n                        return;\n                    }\n                    if (abortSignal == null ? void 0 : abortSignal.aborted) {\n                        abort();\n                        return;\n                    }\n                    controller.enqueue(value);\n                } catch (error) {\n                    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n                        abort();\n                    } else {\n                        controller.error(error);\n                    }\n                }\n            },\n            cancel (reason) {\n                return stitchableStream.stream.cancel(reason);\n            }\n        });\n        for (const transform of transforms){\n            stream = stream.pipeThrough(transform({\n                tools,\n                stopStream () {\n                    stitchableStream.terminate();\n                }\n            }));\n        }\n        this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg,\n            abortSignal\n        });\n        const tracer = getTracer(telemetry);\n        const callSettings = prepareCallSettings(settings);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...callSettings,\n                maxRetries\n            }\n        });\n        const self = this;\n        recordSpan({\n            name: \"ai.streamText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    }\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpanArg)=>{\n                rootSpan = rootSpanArg;\n                const initialPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const initialMessages = initialPrompt.messages;\n                const initialResponseMessages = [];\n                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({\n                    messages: initialMessages\n                });\n                if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {\n                    const providerExecutedToolApprovals = [\n                        ...approvedToolApprovals,\n                        ...deniedToolApprovals\n                    ].filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                    const localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                    const localDeniedToolApprovals = deniedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                    const deniedProviderExecutedToolApprovals = deniedToolApprovals.filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                    let toolExecutionStepStreamController;\n                    const toolExecutionStepStream = new ReadableStream({\n                        start (controller) {\n                            toolExecutionStepStreamController = controller;\n                        }\n                    });\n                    self.addStream(toolExecutionStepStream);\n                    try {\n                        for (const toolApproval of [\n                            ...localDeniedToolApprovals,\n                            ...deniedProviderExecutedToolApprovals\n                        ]){\n                            toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({\n                                type: \"tool-output-denied\",\n                                toolCallId: toolApproval.toolCall.toolCallId,\n                                toolName: toolApproval.toolCall.toolName\n                            });\n                        }\n                        const toolOutputs = [];\n                        await Promise.all(localApprovedToolApprovals.map(async (toolApproval)=>{\n                            const result = await executeToolCall({\n                                toolCall: toolApproval.toolCall,\n                                tools,\n                                tracer,\n                                telemetry,\n                                messages: initialMessages,\n                                abortSignal,\n                                experimental_context,\n                                onPreliminaryToolResult: (result2)=>{\n                                    toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);\n                                }\n                            });\n                            if (result != null) {\n                                toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);\n                                toolOutputs.push(result);\n                            }\n                        }));\n                        if (providerExecutedToolApprovals.length > 0) {\n                            initialResponseMessages.push({\n                                role: \"tool\",\n                                content: providerExecutedToolApprovals.map((toolApproval)=>({\n                                        type: \"tool-approval-response\",\n                                        approvalId: toolApproval.approvalResponse.approvalId,\n                                        approved: toolApproval.approvalResponse.approved,\n                                        reason: toolApproval.approvalResponse.reason,\n                                        providerExecuted: true\n                                    }))\n                            });\n                        }\n                        if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {\n                            const localToolContent = [];\n                            for (const output2 of toolOutputs){\n                                localToolContent.push({\n                                    type: \"tool-result\",\n                                    toolCallId: output2.toolCallId,\n                                    toolName: output2.toolName,\n                                    output: await createToolModelOutput({\n                                        toolCallId: output2.toolCallId,\n                                        input: output2.input,\n                                        tool: tools == null ? void 0 : tools[output2.toolName],\n                                        output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                                        errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                                    })\n                                });\n                            }\n                            for (const toolApproval of localDeniedToolApprovals){\n                                localToolContent.push({\n                                    type: \"tool-result\",\n                                    toolCallId: toolApproval.toolCall.toolCallId,\n                                    toolName: toolApproval.toolCall.toolName,\n                                    output: {\n                                        type: \"execution-denied\",\n                                        reason: toolApproval.approvalResponse.reason\n                                    }\n                                });\n                            }\n                            initialResponseMessages.push({\n                                role: \"tool\",\n                                content: localToolContent\n                            });\n                        }\n                    } finally{\n                        toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();\n                    }\n                }\n                recordedResponseMessages.push(...initialResponseMessages);\n                async function streamStep({ currentStep, responseMessages, usage }) {\n                    var _a17, _b, _c, _d, _e, _f;\n                    const includeRawChunks2 = self.includeRawChunks;\n                    const stepTimeoutId = stepTimeoutMs != null ? setTimeout(()=>stepAbortController.abort(), stepTimeoutMs) : void 0;\n                    let chunkTimeoutId = void 0;\n                    function resetChunkTimeout() {\n                        if (chunkTimeoutMs != null) {\n                            if (chunkTimeoutId != null) {\n                                clearTimeout(chunkTimeoutId);\n                            }\n                            chunkTimeoutId = setTimeout(()=>chunkAbortController.abort(), chunkTimeoutMs);\n                        }\n                    }\n                    function clearChunkTimeout() {\n                        if (chunkTimeoutId != null) {\n                            clearTimeout(chunkTimeoutId);\n                            chunkTimeoutId = void 0;\n                        }\n                    }\n                    function clearStepTimeout() {\n                        if (stepTimeoutId != null) {\n                            clearTimeout(stepTimeoutId);\n                        }\n                    }\n                    stepFinish = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n                    const stepInputMessages = [\n                        ...initialMessages,\n                        ...responseMessages\n                    ];\n                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n                        model,\n                        steps: recordedSteps,\n                        stepNumber: recordedSteps.length,\n                        messages: stepInputMessages,\n                        experimental_context\n                    }));\n                    const stepModel = resolveLanguageModel((_a17 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a17 : model);\n                    const promptMessages = await convertToLanguageModelPrompt({\n                        prompt: {\n                            system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                            messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n                        },\n                        supportedUrls: await stepModel.supportedUrls,\n                        download: download2\n                    });\n                    const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n                        tools,\n                        toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n                        activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n                    });\n                    experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;\n                    const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);\n                    const { result: { stream: stream2, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                            name: \"ai.streamText.doStream\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.streamText.doStream\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    // model:\n                                    \"ai.model.provider\": stepModel.provider,\n                                    \"ai.model.id\": stepModel.modelId,\n                                    // prompt:\n                                    \"ai.prompt.messages\": {\n                                        input: ()=>stringifyForTelemetry(promptMessages)\n                                    },\n                                    \"ai.prompt.tools\": {\n                                        // convert the language model level tools:\n                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))\n                                    },\n                                    \"ai.prompt.toolChoice\": {\n                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.system\": stepModel.provider,\n                                    \"gen_ai.request.model\": stepModel.modelId,\n                                    \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                    \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                    \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                    \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                                    \"gen_ai.request.temperature\": callSettings.temperature,\n                                    \"gen_ai.request.top_k\": callSettings.topK,\n                                    \"gen_ai.request.top_p\": callSettings.topP\n                                }\n                            }),\n                            tracer,\n                            endWhenDone: false,\n                            fn: async (doStreamSpan2)=>({\n                                    startTimestampMs: now2(),\n                                    // get before the call\n                                    doStreamSpan: doStreamSpan2,\n                                    result: await stepModel.doStream({\n                                        ...callSettings,\n                                        tools: stepTools,\n                                        toolChoice: stepToolChoice,\n                                        responseFormat: await (output == null ? void 0 : output.responseFormat),\n                                        prompt: promptMessages,\n                                        providerOptions: stepProviderOptions,\n                                        abortSignal,\n                                        headers,\n                                        includeRawChunks: includeRawChunks2\n                                    })\n                                })\n                        }));\n                    const streamWithToolResults = runToolsTransformation({\n                        tools,\n                        generatorStream: stream2,\n                        tracer,\n                        telemetry,\n                        system,\n                        messages: stepInputMessages,\n                        repairToolCall,\n                        abortSignal,\n                        experimental_context,\n                        generateId: generateId2\n                    });\n                    const stepRequest = request != null ? request : {};\n                    const stepToolCalls = [];\n                    const stepToolOutputs = [];\n                    let warnings;\n                    const activeToolCallToolNames = {};\n                    let stepFinishReason = \"other\";\n                    let stepRawFinishReason = void 0;\n                    let stepUsage = createNullLanguageModelUsage();\n                    let stepProviderMetadata;\n                    let stepFirstChunk = true;\n                    let stepResponse = {\n                        id: generateId2(),\n                        timestamp: /* @__PURE__ */ new Date(),\n                        modelId: model.modelId\n                    };\n                    let activeText = \"\";\n                    self.addStream(streamWithToolResults.pipeThrough(new TransformStream({\n                        async transform (chunk, controller) {\n                            var _a18, _b2, _c2, _d2, _e2;\n                            resetChunkTimeout();\n                            if (chunk.type === \"stream-start\") {\n                                warnings = chunk.warnings;\n                                return;\n                            }\n                            if (stepFirstChunk) {\n                                const msToFirstChunk = now2() - startTimestampMs;\n                                stepFirstChunk = false;\n                                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                doStreamSpan.setAttributes({\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                controller.enqueue({\n                                    type: \"start-step\",\n                                    request: stepRequest,\n                                    warnings: warnings != null ? warnings : []\n                                });\n                            }\n                            const chunkType = chunk.type;\n                            switch(chunkType){\n                                case \"tool-approval-request\":\n                                case \"text-start\":\n                                case \"text-end\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"text-delta\":\n                                    {\n                                        if (chunk.delta.length > 0) {\n                                            controller.enqueue({\n                                                type: \"text-delta\",\n                                                id: chunk.id,\n                                                text: chunk.delta,\n                                                providerMetadata: chunk.providerMetadata\n                                            });\n                                            activeText += chunk.delta;\n                                        }\n                                        break;\n                                    }\n                                case \"reasoning-start\":\n                                case \"reasoning-end\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"reasoning-delta\":\n                                    {\n                                        controller.enqueue({\n                                            type: \"reasoning-delta\",\n                                            id: chunk.id,\n                                            text: chunk.delta,\n                                            providerMetadata: chunk.providerMetadata\n                                        });\n                                        break;\n                                    }\n                                case \"tool-call\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolCalls.push(chunk);\n                                        break;\n                                    }\n                                case \"tool-result\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        if (!chunk.preliminary) {\n                                            stepToolOutputs.push(chunk);\n                                        }\n                                        break;\n                                    }\n                                case \"tool-error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolOutputs.push(chunk);\n                                        break;\n                                    }\n                                case \"response-metadata\":\n                                    {\n                                        stepResponse = {\n                                            id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,\n                                            timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                                            modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                                        };\n                                        break;\n                                    }\n                                case \"finish\":\n                                    {\n                                        stepUsage = chunk.usage;\n                                        stepFinishReason = chunk.finishReason;\n                                        stepRawFinishReason = chunk.rawFinishReason;\n                                        stepProviderMetadata = chunk.providerMetadata;\n                                        const msToFinish = now2() - startTimestampMs;\n                                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                                        doStreamSpan.setAttributes({\n                                            \"ai.response.msToFinish\": msToFinish,\n                                            \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                                        });\n                                        break;\n                                    }\n                                case \"file\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"source\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"tool-input-start\":\n                                    {\n                                        activeToolCallToolNames[chunk.id] = chunk.toolName;\n                                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];\n                                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {\n                                            await tool2.onInputStart({\n                                                toolCallId: chunk.id,\n                                                messages: stepInputMessages,\n                                                abortSignal,\n                                                experimental_context\n                                            });\n                                        }\n                                        controller.enqueue({\n                                            ...chunk,\n                                            dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === \"dynamic\",\n                                            title: tool2 == null ? void 0 : tool2.title\n                                        });\n                                        break;\n                                    }\n                                case \"tool-input-end\":\n                                    {\n                                        delete activeToolCallToolNames[chunk.id];\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"tool-input-delta\":\n                                    {\n                                        const toolName = activeToolCallToolNames[chunk.id];\n                                        const tool2 = tools == null ? void 0 : tools[toolName];\n                                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {\n                                            await tool2.onInputDelta({\n                                                inputTextDelta: chunk.delta,\n                                                toolCallId: chunk.id,\n                                                messages: stepInputMessages,\n                                                abortSignal,\n                                                experimental_context\n                                            });\n                                        }\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepFinishReason = \"error\";\n                                        break;\n                                    }\n                                case \"raw\":\n                                    {\n                                        if (includeRawChunks2) {\n                                            controller.enqueue(chunk);\n                                        }\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        const exhaustiveCheck = chunkType;\n                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                                    }\n                            }\n                        },\n                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                        async flush (controller) {\n                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                            try {\n                                doStreamSpan.setAttributes(await selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.response.finishReason\": stepFinishReason,\n                                        \"ai.response.text\": {\n                                            output: ()=>activeText\n                                        },\n                                        \"ai.response.toolCalls\": {\n                                            output: ()=>stepToolCallsJson\n                                        },\n                                        \"ai.response.id\": stepResponse.id,\n                                        \"ai.response.model\": stepResponse.modelId,\n                                        \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                        \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                                        \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                                        \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                                        \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                                        \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                                        \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.response.finish_reasons\": [\n                                            stepFinishReason\n                                        ],\n                                        \"gen_ai.response.id\": stepResponse.id,\n                                        \"gen_ai.response.model\": stepResponse.modelId,\n                                        \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                                        \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                                    }\n                                }));\n                            } catch (error) {} finally{\n                                doStreamSpan.end();\n                            }\n                            controller.enqueue({\n                                type: \"finish-step\",\n                                finishReason: stepFinishReason,\n                                rawFinishReason: stepRawFinishReason,\n                                usage: stepUsage,\n                                providerMetadata: stepProviderMetadata,\n                                response: {\n                                    ...stepResponse,\n                                    headers: response == null ? void 0 : response.headers\n                                }\n                            });\n                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                            await stepFinish.promise;\n                            const clientToolCalls = stepToolCalls.filter((toolCall)=>toolCall.providerExecuted !== true);\n                            const clientToolOutputs = stepToolOutputs.filter((toolOutput)=>toolOutput.providerExecuted !== true);\n                            for (const toolCall of stepToolCalls){\n                                if (toolCall.providerExecuted !== true) continue;\n                                const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                                if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                                    const hasResultInStep = stepToolOutputs.some((output2)=>output2.type === \"tool-result\" && output2.toolCallId === toolCall.toolCallId);\n                                    if (!hasResultInStep) {\n                                        pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                                            toolName: toolCall.toolName\n                                        });\n                                    }\n                                }\n                            }\n                            for (const output2 of stepToolOutputs){\n                                if (output2.type === \"tool-result\") {\n                                    pendingDeferredToolCalls.delete(output2.toolCallId);\n                                }\n                            }\n                            clearStepTimeout();\n                            clearChunkTimeout();\n                            if (// Continue if:\n                            // 1. There are client tool calls that have all been executed, OR\n                            // 2. There are pending deferred results from provider-executed tools\n                            (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                            !await isStopConditionMet({\n                                stopConditions,\n                                steps: recordedSteps\n                            })) {\n                                responseMessages.push(...await toResponseMessages({\n                                    content: // use transformed content to create the messages for the next step:\n                                    recordedSteps[recordedSteps.length - 1].content,\n                                    tools\n                                }));\n                                try {\n                                    await streamStep({\n                                        currentStep: currentStep + 1,\n                                        responseMessages,\n                                        usage: combinedUsage\n                                    });\n                                } catch (error) {\n                                    controller.enqueue({\n                                        type: \"error\",\n                                        error\n                                    });\n                                    self.closeStream();\n                                }\n                            } else {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: stepFinishReason,\n                                    rawFinishReason: stepRawFinishReason,\n                                    totalUsage: combinedUsage\n                                });\n                                self.closeStream();\n                            }\n                        }\n                    })));\n                }\n                await streamStep({\n                    currentStep: 0,\n                    responseMessages: initialResponseMessages,\n                    usage: createNullLanguageModelUsage()\n                });\n            }\n        }).catch((error)=>{\n            self.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n            self.closeStream();\n        });\n    }\n    get steps() {\n        this.consumeStream();\n        return this._steps.promise;\n    }\n    get finalStep() {\n        return this.steps.then((steps)=>steps[steps.length - 1]);\n    }\n    get content() {\n        return this.finalStep.then((step)=>step.content);\n    }\n    get warnings() {\n        return this.finalStep.then((step)=>step.warnings);\n    }\n    get providerMetadata() {\n        return this.finalStep.then((step)=>step.providerMetadata);\n    }\n    get text() {\n        return this.finalStep.then((step)=>step.text);\n    }\n    get reasoningText() {\n        return this.finalStep.then((step)=>step.reasoningText);\n    }\n    get reasoning() {\n        return this.finalStep.then((step)=>step.reasoning);\n    }\n    get sources() {\n        return this.finalStep.then((step)=>step.sources);\n    }\n    get files() {\n        return this.finalStep.then((step)=>step.files);\n    }\n    get toolCalls() {\n        return this.finalStep.then((step)=>step.toolCalls);\n    }\n    get staticToolCalls() {\n        return this.finalStep.then((step)=>step.staticToolCalls);\n    }\n    get dynamicToolCalls() {\n        return this.finalStep.then((step)=>step.dynamicToolCalls);\n    }\n    get toolResults() {\n        return this.finalStep.then((step)=>step.toolResults);\n    }\n    get staticToolResults() {\n        return this.finalStep.then((step)=>step.staticToolResults);\n    }\n    get dynamicToolResults() {\n        return this.finalStep.then((step)=>step.dynamicToolResults);\n    }\n    get usage() {\n        return this.finalStep.then((step)=>step.usage);\n    }\n    get request() {\n        return this.finalStep.then((step)=>step.request);\n    }\n    get response() {\n        return this.finalStep.then((step)=>step.response);\n    }\n    get totalUsage() {\n        this.consumeStream();\n        return this._totalUsage.promise;\n    }\n    get finishReason() {\n        this.consumeStream();\n        return this._finishReason.promise;\n    }\n    get rawFinishReason() {\n        this.consumeStream();\n        return this._rawFinishReason.promise;\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.baseStream.tee();\n        this.baseStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                if (part.type === \"text-delta\") {\n                    controller.enqueue(part.text);\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                controller.enqueue(part);\n            }\n        })));\n    }\n    async consumeStream(options) {\n        var _a17;\n        try {\n            await consumeStream({\n                stream: this.fullStream,\n                onError: options == null ? void 0 : options.onError\n            });\n        } catch (error) {\n            (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n        }\n    }\n    get experimental_partialOutputStream() {\n        return this.partialOutputStream;\n    }\n    get partialOutputStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ partialOutput }, controller) {\n                if (partialOutput != null) {\n                    controller.enqueue(partialOutput);\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        var _a17, _b, _c;\n        const transform = (_a17 = this.outputSpecification) == null ? void 0 : _a17.createElementStreamTransform();\n        if (transform == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: `element streams in ${(_c = (_b = this.outputSpecification) == null ? void 0 : _b.name) != null ? _c : \"text\"} mode`\n            });\n        }\n        return createAsyncIterableStream(this.teeStream().pipeThrough(transform));\n    }\n    get output() {\n        return this.finalStep.then((step)=>{\n            var _a17;\n            const output = (_a17 = this.outputSpecification) != null ? _a17 : text();\n            return output.parseCompleteOutput({\n                text: step.text\n            }, {\n                response: step.response,\n                usage: step.usage,\n                finishReason: step.finishReason\n            });\n        });\n    }\n    toUIMessageStream({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning = true, sendSources = false, sendStart = true, sendFinish = true, onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage } = {}) {\n        const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n            originalMessages,\n            responseMessageId: generateMessageId\n        }) : void 0;\n        const isDynamic = (part)=>{\n            var _a17;\n            const tool2 = (_a17 = this.tools) == null ? void 0 : _a17[part.toolName];\n            if (tool2 == null) {\n                return part.dynamic;\n            }\n            return (tool2 == null ? void 0 : tool2.type) === \"dynamic\" ? true : void 0;\n        };\n        const baseStream = this.fullStream.pipeThrough(new TransformStream({\n            transform: async (part, controller)=>{\n                const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({\n                    part\n                });\n                const partType = part.type;\n                switch(partType){\n                    case \"text-start\":\n                        {\n                            controller.enqueue({\n                                type: \"text-start\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"text-delta\":\n                        {\n                            controller.enqueue({\n                                type: \"text-delta\",\n                                id: part.id,\n                                delta: part.text,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"text-end\":\n                        {\n                            controller.enqueue({\n                                type: \"text-end\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"reasoning-start\":\n                        {\n                            controller.enqueue({\n                                type: \"reasoning-start\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"reasoning-delta\":\n                        {\n                            if (sendReasoning) {\n                                controller.enqueue({\n                                    type: \"reasoning-delta\",\n                                    id: part.id,\n                                    delta: part.text,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"reasoning-end\":\n                        {\n                            controller.enqueue({\n                                type: \"reasoning-end\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"file\":\n                        {\n                            controller.enqueue({\n                                type: \"file\",\n                                mediaType: part.file.mediaType,\n                                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n                            });\n                            break;\n                        }\n                    case \"source\":\n                        {\n                            if (sendSources && part.sourceType === \"url\") {\n                                controller.enqueue({\n                                    type: \"source-url\",\n                                    sourceId: part.id,\n                                    url: part.url,\n                                    title: part.title,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            if (sendSources && part.sourceType === \"document\") {\n                                controller.enqueue({\n                                    type: \"source-document\",\n                                    sourceId: part.id,\n                                    mediaType: part.mediaType,\n                                    title: part.title,\n                                    filename: part.filename,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-input-start\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-input-start\",\n                                toolCallId: part.id,\n                                toolName: part.toolName,\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {},\n                                ...part.title != null ? {\n                                    title: part.title\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-input-delta\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-input-delta\",\n                                toolCallId: part.id,\n                                inputTextDelta: part.delta\n                            });\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const dynamic = isDynamic(part);\n                            if (part.invalid) {\n                                controller.enqueue({\n                                    type: \"tool-input-error\",\n                                    toolCallId: part.toolCallId,\n                                    toolName: part.toolName,\n                                    input: part.input,\n                                    ...part.providerExecuted != null ? {\n                                        providerExecuted: part.providerExecuted\n                                    } : {},\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {},\n                                    ...dynamic != null ? {\n                                        dynamic\n                                    } : {},\n                                    errorText: onError(part.error),\n                                    ...part.title != null ? {\n                                        title: part.title\n                                    } : {}\n                                });\n                            } else {\n                                controller.enqueue({\n                                    type: \"tool-input-available\",\n                                    toolCallId: part.toolCallId,\n                                    toolName: part.toolName,\n                                    input: part.input,\n                                    ...part.providerExecuted != null ? {\n                                        providerExecuted: part.providerExecuted\n                                    } : {},\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {},\n                                    ...dynamic != null ? {\n                                        dynamic\n                                    } : {},\n                                    ...part.title != null ? {\n                                        title: part.title\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-approval-request\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-approval-request\",\n                                approvalId: part.approvalId,\n                                toolCallId: part.toolCall.toolCallId\n                            });\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-output-available\",\n                                toolCallId: part.toolCallId,\n                                output: part.output,\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...part.preliminary != null ? {\n                                    preliminary: part.preliminary\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-error\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-output-error\",\n                                toolCallId: part.toolCallId,\n                                errorText: onError(part.error),\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-output-denied\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-output-denied\",\n                                toolCallId: part.toolCallId\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue({\n                                type: \"error\",\n                                errorText: onError(part.error)\n                            });\n                            break;\n                        }\n                    case \"start-step\":\n                        {\n                            controller.enqueue({\n                                type: \"start-step\"\n                            });\n                            break;\n                        }\n                    case \"finish-step\":\n                        {\n                            controller.enqueue({\n                                type: \"finish-step\"\n                            });\n                            break;\n                        }\n                    case \"start\":\n                        {\n                            if (sendStart) {\n                                controller.enqueue({\n                                    type: \"start\",\n                                    ...messageMetadataValue != null ? {\n                                        messageMetadata: messageMetadataValue\n                                    } : {},\n                                    ...responseMessageId != null ? {\n                                        messageId: responseMessageId\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (sendFinish) {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: part.finishReason,\n                                    ...messageMetadataValue != null ? {\n                                        messageMetadata: messageMetadataValue\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"abort\":\n                        {\n                            controller.enqueue(part);\n                            break;\n                        }\n                    case \"tool-input-end\":\n                        {\n                            break;\n                        }\n                    case \"raw\":\n                        {\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = partType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n                if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n                    controller.enqueue({\n                        type: \"message-metadata\",\n                        messageMetadata: messageMetadataValue\n                    });\n                }\n            }\n        }));\n        return createAsyncIterableStream(handleUIMessageStreamFinish({\n            stream: baseStream,\n            messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n            originalMessages,\n            onFinish,\n            onError\n        }));\n    }\n    pipeUIMessageStreamToResponse(response, { originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {\n        pipeUIMessageStreamToResponse({\n            response,\n            stream: this.toUIMessageStream({\n                originalMessages,\n                generateMessageId,\n                onFinish,\n                messageMetadata,\n                sendReasoning,\n                sendSources,\n                sendFinish,\n                sendStart,\n                onError\n            }),\n            ...init\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        pipeTextStreamToResponse({\n            response,\n            textStream: this.textStream,\n            ...init\n        });\n    }\n    toUIMessageStreamResponse({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {\n        return createUIMessageStreamResponse({\n            stream: this.toUIMessageStream({\n                originalMessages,\n                generateMessageId,\n                onFinish,\n                messageMetadata,\n                sendReasoning,\n                sendSources,\n                sendFinish,\n                sendStart,\n                onError\n            }),\n            ...init\n        });\n    }\n    toTextStreamResponse(init) {\n        return createTextStreamResponse({\n            textStream: this.textStream,\n            ...init\n        });\n    }\n};\n// src/agent/tool-loop-agent.ts\nvar ToolLoopAgent = class {\n    constructor(settings){\n        this.version = \"agent-v1\";\n        this.settings = settings;\n    }\n    /**\n   * The id of the agent.\n   */ get id() {\n        return this.settings.id;\n    }\n    /**\n   * The tools that the agent can use.\n   */ get tools() {\n        return this.settings.tools;\n    }\n    async prepareCall(options) {\n        var _a17, _b, _c, _d;\n        const baseCallArgs = {\n            ...this.settings,\n            stopWhen: (_a17 = this.settings.stopWhen) != null ? _a17 : stepCountIs(20),\n            ...options\n        };\n        const preparedCallArgs = (_d = await ((_c = (_b = this.settings).prepareCall) == null ? void 0 : _c.call(_b, baseCallArgs))) != null ? _d : baseCallArgs;\n        const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;\n        return {\n            ...callArgs,\n            // restore prompt types\n            ...{\n                system: instructions,\n                messages,\n                prompt\n            }\n        };\n    }\n    /**\n   * Generates an output from the agent (non-streaming).\n   */ async generate({ abortSignal, timeout, ...options }) {\n        return generateText({\n            ...await this.prepareCall(options),\n            abortSignal,\n            timeout\n        });\n    }\n    /**\n   * Streams an output from the agent (streaming).\n   */ async stream({ abortSignal, timeout, experimental_transform, ...options }) {\n        return streamText({\n            ...await this.prepareCall(options),\n            abortSignal,\n            timeout,\n            experimental_transform\n        });\n    }\n};\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({ execute, onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage, originalMessages, onFinish, generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId }) {\n    let controller;\n    const ongoingStreamPromises = [];\n    const stream = new ReadableStream({\n        start (controllerArg) {\n            controller = controllerArg;\n        }\n    });\n    function safeEnqueue(data) {\n        try {\n            controller.enqueue(data);\n        } catch (error) {}\n    }\n    try {\n        const result = execute({\n            writer: {\n                write (part) {\n                    safeEnqueue(part);\n                },\n                merge (streamArg) {\n                    ongoingStreamPromises.push((async ()=>{\n                        const reader = streamArg.getReader();\n                        while(true){\n                            const { done, value } = await reader.read();\n                            if (done) break;\n                            safeEnqueue(value);\n                        }\n                    })().catch((error)=>{\n                        safeEnqueue({\n                            type: \"error\",\n                            errorText: onError(error)\n                        });\n                    }));\n                },\n                onError\n            }\n        });\n        if (result) {\n            ongoingStreamPromises.push(result.catch((error)=>{\n                safeEnqueue({\n                    type: \"error\",\n                    errorText: onError(error)\n                });\n            }));\n        }\n    } catch (error) {\n        safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n        });\n    }\n    const waitForStreams = new Promise(async (resolve3)=>{\n        while(ongoingStreamPromises.length > 0){\n            await ongoingStreamPromises.shift();\n        }\n        resolve3();\n    });\n    waitForStreams.finally(()=>{\n        try {\n            controller.close();\n        } catch (error) {}\n    });\n    return handleUIMessageStreamFinish({\n        stream,\n        messageId: generateId2(),\n        originalMessages,\n        onFinish,\n        onError\n    });\n}\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({ message, stream, onError, terminateOnError = false }) {\n    var _a17;\n    let controller;\n    let hasErrored = false;\n    const outputStream = new ReadableStream({\n        start (controllerParam) {\n            controller = controllerParam;\n        }\n    });\n    const state = createStreamingUIMessageState({\n        messageId: (_a17 = message == null ? void 0 : message.id) != null ? _a17 : \"\",\n        lastMessage: message\n    });\n    const handleError = (error)=>{\n        onError == null ? void 0 : onError(error);\n        if (!hasErrored && terminateOnError) {\n            hasErrored = true;\n            controller == null ? void 0 : controller.error(error);\n        }\n    };\n    consumeStream({\n        stream: processUIMessageStream({\n            stream,\n            runUpdateMessageJob (job) {\n                return job({\n                    state,\n                    write: ()=>{\n                        controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n                    }\n                });\n            },\n            onError: handleError\n        }),\n        onError: handleError\n    }).finally(()=>{\n        if (!hasErrored) {\n            controller == null ? void 0 : controller.close();\n        }\n    });\n    return createAsyncIterableStream(outputStream);\n}\n// src/ui/convert-to-model-messages.ts\n\nasync function convertToModelMessages(messages, options) {\n    const modelMessages = [];\n    if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n        messages = messages.map((message)=>({\n                ...message,\n                parts: message.parts.filter((part)=>!isToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\")\n            }));\n    }\n    for (const message of messages){\n        switch(message.role){\n            case \"system\":\n                {\n                    const textParts = message.parts.filter((part)=>part.type === \"text\");\n                    const providerMetadata = textParts.reduce((acc, part)=>{\n                        if (part.providerMetadata != null) {\n                            return {\n                                ...acc,\n                                ...part.providerMetadata\n                            };\n                        }\n                        return acc;\n                    }, {});\n                    modelMessages.push({\n                        role: \"system\",\n                        content: textParts.map((part)=>part.text).join(\"\"),\n                        ...Object.keys(providerMetadata).length > 0 ? {\n                            providerOptions: providerMetadata\n                        } : {}\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    modelMessages.push({\n                        role: \"user\",\n                        content: message.parts.map((part)=>{\n                            var _a17;\n                            if (isTextUIPart(part)) {\n                                return {\n                                    type: \"text\",\n                                    text: part.text,\n                                    ...part.providerMetadata != null ? {\n                                        providerOptions: part.providerMetadata\n                                    } : {}\n                                };\n                            }\n                            if (isFileUIPart(part)) {\n                                return {\n                                    type: \"file\",\n                                    mediaType: part.mediaType,\n                                    filename: part.filename,\n                                    data: part.url,\n                                    ...part.providerMetadata != null ? {\n                                        providerOptions: part.providerMetadata\n                                    } : {}\n                                };\n                            }\n                            if (isDataUIPart(part)) {\n                                return (_a17 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a17.call(options, part);\n                            }\n                        }).filter(_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isNonNullable)\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (message.parts != null) {\n                        let block = [];\n                        async function processBlock() {\n                            var _a17, _b, _c, _d, _e, _f;\n                            if (block.length === 0) {\n                                return;\n                            }\n                            const content = [];\n                            for (const part of block){\n                                if (isTextUIPart(part)) {\n                                    content.push({\n                                        type: \"text\",\n                                        text: part.text,\n                                        ...part.providerMetadata != null ? {\n                                            providerOptions: part.providerMetadata\n                                        } : {}\n                                    });\n                                } else if (isFileUIPart(part)) {\n                                    content.push({\n                                        type: \"file\",\n                                        mediaType: part.mediaType,\n                                        filename: part.filename,\n                                        data: part.url\n                                    });\n                                } else if (isReasoningUIPart(part)) {\n                                    content.push({\n                                        type: \"reasoning\",\n                                        text: part.text,\n                                        providerOptions: part.providerMetadata\n                                    });\n                                } else if (isToolUIPart(part)) {\n                                    const toolName = getToolName(part);\n                                    if (part.state !== \"input-streaming\") {\n                                        content.push({\n                                            type: \"tool-call\",\n                                            toolCallId: part.toolCallId,\n                                            toolName,\n                                            input: part.state === \"output-error\" ? (_a17 = part.input) != null ? _a17 : \"rawInput\" in part ? part.rawInput : void 0 : part.input,\n                                            providerExecuted: part.providerExecuted,\n                                            ...part.callProviderMetadata != null ? {\n                                                providerOptions: part.callProviderMetadata\n                                            } : {}\n                                        });\n                                        if (part.approval != null) {\n                                            content.push({\n                                                type: \"tool-approval-request\",\n                                                approvalId: part.approval.id,\n                                                toolCallId: part.toolCallId\n                                            });\n                                        }\n                                        if (part.providerExecuted === true && part.state !== \"approval-responded\" && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                                            content.push({\n                                                type: \"tool-result\",\n                                                toolCallId: part.toolCallId,\n                                                toolName,\n                                                output: await createToolModelOutput({\n                                                    toolCallId: part.toolCallId,\n                                                    input: part.input,\n                                                    output: part.state === \"output-error\" ? part.errorText : part.output,\n                                                    tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                                                    errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                                                }),\n                                                ...part.callProviderMetadata != null ? {\n                                                    providerOptions: part.callProviderMetadata\n                                                } : {}\n                                            });\n                                        }\n                                    }\n                                } else if (isDataUIPart(part)) {\n                                    const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(options, part);\n                                    if (dataPart != null) {\n                                        content.push(dataPart);\n                                    }\n                                } else {\n                                    const _exhaustiveCheck = part;\n                                    throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                                }\n                            }\n                            modelMessages.push({\n                                role: \"assistant\",\n                                content\n                            });\n                            const toolParts = block.filter((part)=>{\n                                var _a18;\n                                return isToolUIPart(part) && (part.providerExecuted !== true || ((_a18 = part.approval) == null ? void 0 : _a18.approved) != null);\n                            });\n                            if (toolParts.length > 0) {\n                                {\n                                    const content2 = [];\n                                    for (const toolPart of toolParts){\n                                        if (((_d = toolPart.approval) == null ? void 0 : _d.approved) != null) {\n                                            content2.push({\n                                                type: \"tool-approval-response\",\n                                                approvalId: toolPart.approval.id,\n                                                approved: toolPart.approval.approved,\n                                                reason: toolPart.approval.reason,\n                                                providerExecuted: toolPart.providerExecuted\n                                            });\n                                        }\n                                        if (toolPart.providerExecuted === true) {\n                                            continue;\n                                        }\n                                        switch(toolPart.state){\n                                            case \"output-denied\":\n                                                {\n                                                    content2.push({\n                                                        type: \"tool-result\",\n                                                        toolCallId: toolPart.toolCallId,\n                                                        toolName: getToolName(toolPart),\n                                                        output: {\n                                                            type: \"error-text\",\n                                                            value: (_e = toolPart.approval.reason) != null ? _e : \"Tool execution denied.\"\n                                                        },\n                                                        ...toolPart.callProviderMetadata != null ? {\n                                                            providerOptions: toolPart.callProviderMetadata\n                                                        } : {}\n                                                    });\n                                                    break;\n                                                }\n                                            case \"output-error\":\n                                            case \"output-available\":\n                                                {\n                                                    const toolName = getToolName(toolPart);\n                                                    content2.push({\n                                                        type: \"tool-result\",\n                                                        toolCallId: toolPart.toolCallId,\n                                                        toolName,\n                                                        output: await createToolModelOutput({\n                                                            toolCallId: toolPart.toolCallId,\n                                                            input: toolPart.input,\n                                                            output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                                                            tool: (_f = options == null ? void 0 : options.tools) == null ? void 0 : _f[toolName],\n                                                            errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                                                        }),\n                                                        ...toolPart.callProviderMetadata != null ? {\n                                                            providerOptions: toolPart.callProviderMetadata\n                                                        } : {}\n                                                    });\n                                                    break;\n                                                }\n                                        }\n                                    }\n                                    if (content2.length > 0) {\n                                        modelMessages.push({\n                                            role: \"tool\",\n                                            content: content2\n                                        });\n                                    }\n                                }\n                            }\n                            block = [];\n                        }\n                        for (const part of message.parts){\n                            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolUIPart(part) || isDataUIPart(part)) {\n                                block.push(part);\n                            } else if (part.type === \"step-start\") {\n                                await processBlock();\n                            }\n                        }\n                        await processBlock();\n                        break;\n                    }\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = message.role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return modelMessages;\n}\n// src/ui/validate-ui-messages.ts\n\n\n\nvar uiMessagesSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(()=>(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.enum([\n            \"system\",\n            \"user\",\n            \"assistant\"\n        ]),\n        metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n        parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.enum([\n                    \"streaming\",\n                    \"done\"\n                ]).optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.enum([\n                    \"streaming\",\n                    \"done\"\n                ]).optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-url\"),\n                sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-document\"),\n                sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"step-start\")\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"data-\"),\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-streaming\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-available\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-requested\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-responded\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-available\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-error\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-denied\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(false),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-streaming\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-available\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-requested\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-responded\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-available\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-error\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-denied\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(false),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n                })\n            })\n        ])).nonempty(\"Message must contain at least one part\")\n    })).nonempty(\"Messages array must not be empty\")));\nasync function safeValidateUIMessages({ messages, metadataSchema, dataSchemas, tools }) {\n    try {\n        if (messages == null) {\n            return {\n                success: false,\n                error: new InvalidArgumentError({\n                    parameter: \"messages\",\n                    value: messages,\n                    message: \"messages parameter must be provided\"\n                })\n            };\n        }\n        const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: messages,\n            schema: uiMessagesSchema\n        });\n        if (metadataSchema) {\n            for (const message of validatedMessages){\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: message.metadata,\n                    schema: metadataSchema\n                });\n            }\n        }\n        if (dataSchemas) {\n            for (const message of validatedMessages){\n                const dataParts = message.parts.filter((part)=>part.type.startsWith(\"data-\"));\n                for (const dataPart of dataParts){\n                    const dataName = dataPart.type.slice(5);\n                    const dataSchema = dataSchemas[dataName];\n                    if (!dataSchema) {\n                        return {\n                            success: false,\n                            error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                                value: dataPart.data,\n                                cause: `No data schema found for data part ${dataName}`\n                            })\n                        };\n                    }\n                    await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                        value: dataPart.data,\n                        schema: dataSchema\n                    });\n                }\n            }\n        }\n        if (tools) {\n            for (const message of validatedMessages){\n                const toolParts = message.parts.filter((part)=>part.type.startsWith(\"tool-\"));\n                for (const toolPart of toolParts){\n                    const toolName = toolPart.type.slice(5);\n                    const tool2 = tools[toolName];\n                    if (!tool2) {\n                        return {\n                            success: false,\n                            error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                                value: toolPart.input,\n                                cause: `No tool schema found for tool part ${toolName}`\n                            })\n                        };\n                    }\n                    if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\" && toolPart.input !== void 0) {\n                        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                            value: toolPart.input,\n                            schema: tool2.inputSchema\n                        });\n                    }\n                    if (toolPart.state === \"output-available\" && tool2.outputSchema) {\n                        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                            value: toolPart.output,\n                            schema: tool2.outputSchema\n                        });\n                    }\n                }\n            }\n        }\n        return {\n            success: true,\n            data: validatedMessages\n        };\n    } catch (error) {\n        const err = error;\n        return {\n            success: false,\n            error: err\n        };\n    }\n}\nasync function validateUIMessages({ messages, metadataSchema, dataSchemas, tools }) {\n    const response = await safeValidateUIMessages({\n        messages,\n        metadataSchema,\n        dataSchemas,\n        tools\n    });\n    if (!response.success) throw response.error;\n    return response.data;\n}\n// src/agent/create-agent-ui-stream.ts\nasync function createAgentUIStream({ agent, uiMessages, options, abortSignal, timeout, experimental_transform, ...uiMessageStreamOptions }) {\n    const validatedMessages = await validateUIMessages({\n        messages: uiMessages,\n        tools: agent.tools\n    });\n    const modelMessages = await convertToModelMessages(validatedMessages, {\n        tools: agent.tools\n    });\n    const result = await agent.stream({\n        prompt: modelMessages,\n        options,\n        abortSignal,\n        timeout,\n        experimental_transform\n    });\n    return result.toUIMessageStream(uiMessageStreamOptions);\n}\n// src/agent/create-agent-ui-stream-response.ts\nasync function createAgentUIStreamResponse({ headers, status, statusText, consumeSseStream, ...options }) {\n    return createUIMessageStreamResponse({\n        headers,\n        status,\n        statusText,\n        consumeSseStream,\n        stream: await createAgentUIStream(options)\n    });\n}\n// src/agent/pipe-agent-ui-stream-to-response.ts\nasync function pipeAgentUIStreamToResponse({ response, headers, status, statusText, consumeSseStream, ...options }) {\n    pipeUIMessageStreamToResponse({\n        response,\n        headers,\n        status,\n        statusText,\n        consumeSseStream,\n        stream: await createAgentUIStream(options)\n    });\n}\n// src/embed/embed.ts\n\nasync function embed({ model: modelArg, value, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const model = resolveEmbeddingModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const { embedding, usage, warnings, response, providerMetadata } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a17;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers: headersWithUserAgent,\n                            providerOptions\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            warnings: modelResponse.warnings,\n                            providerMetadata: modelResponse.providerMetadata,\n                            response: modelResponse.response\n                        };\n                    }\n                }));\n            span.setAttributes(await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            logWarnings({\n                warnings,\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                warnings,\n                providerMetadata,\n                response\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.response = options.response;\n    }\n};\n// src/embed/embed-many.ts\n\n// src/util/split-array.ts\nfunction splitArray(array2, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array2.length; i += chunkSize){\n        result.push(array2.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// src/embed/embed-many.ts\nasync function embedMany({ model: modelArg, values, maxParallelCalls = Infinity, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {\n    const model = resolveEmbeddingModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a17;\n            const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n                model.maxEmbeddingsPerCall,\n                model.supportsParallelCalls\n            ]);\n            if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n                const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a18;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers: headersWithUserAgent,\n                                providerOptions\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a18 = modelResponse.usage) != null ? _a18 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2,\n                                warnings: modelResponse.warnings,\n                                providerMetadata: modelResponse.providerMetadata,\n                                response: modelResponse.response\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                logWarnings({\n                    warnings: warnings2,\n                    provider: model.provider,\n                    model: model.modelId\n                });\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage,\n                    warnings: warnings2,\n                    providerMetadata: providerMetadata2,\n                    responses: [\n                        response\n                    ]\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            const warnings = [];\n            const responses = [];\n            let tokens = 0;\n            let providerMetadata;\n            const parallelChunks = splitArray(valueChunks, supportsParallelCalls ? maxParallelCalls : 1);\n            for (const parallelChunk of parallelChunks){\n                const results = await Promise.all(parallelChunk.map((chunk)=>{\n                    return retry(()=>{\n                        return recordSpan({\n                            name: \"ai.embedMany.doEmbed\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.embedMany.doEmbed\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    // specific settings that only make sense on the outer level:\n                                    \"ai.values\": {\n                                        input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                    }\n                                }\n                            }),\n                            tracer,\n                            fn: async (doEmbedSpan)=>{\n                                var _a18;\n                                const modelResponse = await model.doEmbed({\n                                    values: chunk,\n                                    abortSignal,\n                                    headers: headersWithUserAgent,\n                                    providerOptions\n                                });\n                                const embeddings2 = modelResponse.embeddings;\n                                const usage = (_a18 = modelResponse.usage) != null ? _a18 : {\n                                    tokens: NaN\n                                };\n                                doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.embeddings\": {\n                                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                        },\n                                        \"ai.usage.tokens\": usage.tokens\n                                    }\n                                }));\n                                return {\n                                    embeddings: embeddings2,\n                                    usage,\n                                    warnings: modelResponse.warnings,\n                                    providerMetadata: modelResponse.providerMetadata,\n                                    response: modelResponse.response\n                                };\n                            }\n                        });\n                    });\n                }));\n                for (const result of results){\n                    embeddings.push(...result.embeddings);\n                    warnings.push(...result.warnings);\n                    responses.push(result.response);\n                    tokens += result.usage.tokens;\n                    if (result.providerMetadata) {\n                        if (!providerMetadata) {\n                            providerMetadata = {\n                                ...result.providerMetadata\n                            };\n                        } else {\n                            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){\n                                providerMetadata[providerName] = {\n                                    ...(_a17 = providerMetadata[providerName]) != null ? _a17 : {},\n                                    ...metadata\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n            span.setAttributes(await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            logWarnings({\n                warnings,\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                },\n                warnings,\n                providerMetadata,\n                responses\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.responses = options.responses;\n    }\n};\n// src/generate-image/generate-image.ts\n\nasync function generateImage({ model: modelArg, prompt: promptArg, n = 1, maxImagesPerCall, size, aspectRatio, seed, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17, _b;\n    const model = resolveImageModel(modelArg);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a17 : 1;\n    const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n    const callImageCounts = Array.from({\n        length: callCount\n    }, (_, i)=>{\n        if (i < callCount - 1) {\n            return maxImagesPerCallWithDefault;\n        }\n        const remainder = n % maxImagesPerCallWithDefault;\n        return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n    });\n    const results = await Promise.all(callImageCounts.map(async (callImageCount)=>retry(()=>{\n            const { prompt, files, mask } = normalizePrompt(promptArg);\n            return model.doGenerate({\n                prompt,\n                files,\n                mask,\n                n: callImageCount,\n                abortSignal,\n                headers: headersWithUserAgent,\n                size,\n                aspectRatio,\n                seed,\n                providerOptions: providerOptions != null ? providerOptions : {}\n            });\n        })));\n    const images = [];\n    const warnings = [];\n    const responses = [];\n    const providerMetadata = {};\n    let totalUsage = {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0\n    };\n    for (const result of results){\n        images.push(...result.images.map((image)=>{\n            var _a18;\n            return new DefaultGeneratedFile({\n                data: image,\n                mediaType: (_a18 = detectMediaType({\n                    data: image,\n                    signatures: imageMediaTypeSignatures\n                })) != null ? _a18 : \"image/png\"\n            });\n        }));\n        warnings.push(...result.warnings);\n        if (result.usage != null) {\n            totalUsage = addImageModelUsage(totalUsage, result.usage);\n        }\n        if (result.providerMetadata) {\n            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){\n                if (providerName === \"gateway\") {\n                    const currentEntry = providerMetadata[providerName];\n                    if (currentEntry != null && typeof currentEntry === \"object\") {\n                        providerMetadata[providerName] = {\n                            ...currentEntry,\n                            ...metadata\n                        };\n                    } else {\n                        providerMetadata[providerName] = metadata;\n                    }\n                    const imagesValue = providerMetadata[providerName].images;\n                    if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n                        delete providerMetadata[providerName].images;\n                    }\n                } else {\n                    (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = {\n                        images: []\n                    };\n                    providerMetadata[providerName].images.push(...result.providerMetadata[providerName].images);\n                }\n            }\n        }\n        responses.push(result.response);\n    }\n    logWarnings({\n        warnings,\n        provider: model.provider,\n        model: model.modelId\n    });\n    if (!images.length) {\n        throw new NoImageGeneratedError({\n            responses\n        });\n    }\n    return new DefaultGenerateImageResult({\n        images,\n        warnings,\n        responses,\n        providerMetadata,\n        usage: totalUsage\n    });\n}\nvar DefaultGenerateImageResult = class {\n    constructor(options){\n        this.images = options.images;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = options.providerMetadata;\n        this.usage = options.usage;\n    }\n    get image() {\n        return this.images[0];\n    }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n    const isFunction = model.maxImagesPerCall instanceof Function;\n    if (!isFunction) {\n        return model.maxImagesPerCall;\n    }\n    return model.maxImagesPerCall({\n        modelId: model.modelId\n    });\n}\nfunction normalizePrompt(prompt) {\n    if (typeof prompt === \"string\") {\n        return {\n            prompt,\n            files: void 0,\n            mask: void 0\n        };\n    }\n    return {\n        prompt: prompt.text,\n        files: prompt.images.map(toImageModelV3File),\n        mask: prompt.mask ? toImageModelV3File(prompt.mask) : void 0\n    };\n}\nfunction toImageModelV3File(dataContent) {\n    if (typeof dataContent === \"string\" && dataContent.startsWith(\"http\")) {\n        return {\n            type: \"url\",\n            url: dataContent\n        };\n    }\n    if (typeof dataContent === \"string\" && dataContent.startsWith(\"data:\")) {\n        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(dataContent);\n        if (base64Content != null) {\n            const uint8Data2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content);\n            return {\n                type: \"file\",\n                data: uint8Data2,\n                mediaType: dataUrlMediaType || detectMediaType({\n                    data: uint8Data2,\n                    signatures: imageMediaTypeSignatures\n                }) || \"image/png\"\n            };\n        }\n    }\n    const uint8Data = convertDataContentToUint8Array(dataContent);\n    return {\n        type: \"file\",\n        data: uint8Data,\n        mediaType: detectMediaType({\n            data: uint8Data,\n            signatures: imageMediaTypeSignatures\n        }) || \"image/png\"\n    };\n}\n// src/generate-image/index.ts\nvar experimental_generateImage = generateImage;\n// src/generate-object/generate-object.ts\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n    const parts = content.filter((content2)=>content2.type === \"reasoning\");\n    return parts.length === 0 ? void 0 : parts.map((content2)=>content2.text).join(\"\\n\");\n}\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: async ()=>void 0,\n    async validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    async validateFinalResult (value, context2) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError({\n                message: \"No object generated: response did not match schema.\",\n                text: context2.text,\n                response: context2.response,\n                usage: context2.usage,\n                finishReason: context2.finishReason\n            })\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: async ()=>await schema.jsonSchema,\n        async validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        async validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    return {\n        type: \"array\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: async ()=>{\n            const { $schema, ...itemSchema } = await schema.jsonSchema;\n            return {\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    elements: {\n                        type: \"array\",\n                        items: itemSchema\n                    }\n                },\n                required: [\n                    \"elements\"\n                ],\n                additionalProperties: false\n            };\n        },\n        async validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a17;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        async validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array2 = chunk.object;\n                                for(; publishedElements < array2.length; publishedElements++){\n                                    controller.enqueue(array2[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                        case \"error\":\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            })));\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: async ()=>({\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    result: {\n                        type: \"string\",\n                        enum: enumValues\n                    }\n                },\n                required: [\n                    \"result\"\n                ],\n                additionalProperties: false\n            }),\n        async validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        async validatePartialResult ({ value, textDelta }) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            const possibleEnumValues = enumValues.filter((enumValue)=>enumValue.startsWith(result));\n            if (value.result.length === 0 || possibleEnumValues.length === 0) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be a string in the enum\"\n                    })\n                };\n            }\n            return {\n                success: true,\n                value: {\n                    partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n                    textDelta\n                }\n            };\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context2) {\n    const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: result\n    });\n    if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n            message: \"No object generated: could not parse the response.\",\n            cause: parseResult.error,\n            text: result,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n        });\n    }\n    const validationResult = await outputStrategy.validateFinalResult(parseResult.value, {\n        text: result,\n        response: context2.response,\n        usage: context2.usage\n    });\n    if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: result,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n        });\n    }\n    return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context2) {\n    try {\n        return await parseAndValidateObjectResult(result, outputStrategy, context2);\n    } catch (error) {\n        if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n            const repairedText = await repairText({\n                text: result,\n                error: error.cause\n            });\n            if (repairedText === null) {\n                throw error;\n            }\n            return await parseAndValidateObjectResult(repairedText, outputStrategy, context2);\n        }\n        throw error;\n    }\n}\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject(options) {\n    const { model: modelArg, output = \"object\", system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, experimental_download: download2, providerOptions, _internal: { generateId: generateId2 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings } = options;\n    const model = resolveLanguageModel(modelArg);\n    const enumValues = \"enum\" in options ? options.enum : void 0;\n    const { schema: inputSchema, schemaDescription, schemaName } = \"schema\" in options ? options : {};\n    validateObjectGenerationInput({\n        output,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    const callSettings = prepareCallSettings(settings);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            ...callSettings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const jsonSchema2 = await outputStrategy.jsonSchema();\n    try {\n        return await recordSpan({\n            name: \"ai.generateObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.generateObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": jsonSchema2 != null ? {\n                        input: ()=>JSON.stringify(jsonSchema2)\n                    } : void 0,\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                var _a17;\n                let result;\n                let finishReason;\n                let usage;\n                let warnings;\n                let response;\n                let request;\n                let resultProviderMetadata;\n                let reasoning;\n                const standardizedPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: standardizedPrompt,\n                    supportedUrls: await model.supportedUrls,\n                    download: download2\n                });\n                const generateResult = await retry(()=>recordSpan({\n                        name: \"ai.generateObject.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateObject.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.messages\": {\n                                    input: ()=>stringifyForTelemetry(promptMessages)\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                \"gen_ai.request.temperature\": callSettings.temperature,\n                                \"gen_ai.request.top_k\": callSettings.topK,\n                                \"gen_ai.request.top_p\": callSettings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a18, _b, _c, _d, _e, _f, _g, _h;\n                            const result2 = await model.doGenerate({\n                                responseFormat: {\n                                    type: \"json\",\n                                    schema: jsonSchema2,\n                                    name: schemaName,\n                                    description: schemaDescription\n                                },\n                                ...prepareCallSettings(settings),\n                                prompt: promptMessages,\n                                providerOptions,\n                                abortSignal,\n                                headers: headersWithUserAgent\n                            });\n                            const responseData = {\n                                id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId2(),\n                                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                                body: (_h = result2.response) == null ? void 0 : _h.body\n                            };\n                            const text2 = extractTextContent(result2.content);\n                            const reasoning2 = extractReasoningContent(result2.content);\n                            if (text2 === void 0) {\n                                throw new NoObjectGeneratedError({\n                                    message: \"No object generated: the model did not return a response.\",\n                                    response: responseData,\n                                    usage: asLanguageModelUsage(result2.usage),\n                                    finishReason: result2.finishReason.unified\n                                });\n                            }\n                            span2.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result2.finishReason.unified,\n                                    \"ai.response.object\": {\n                                        output: ()=>text2\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.response.providerMetadata\": JSON.stringify(result2.providerMetadata),\n                                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                                    \"ai.usage.promptTokens\": result2.usage.inputTokens.total,\n                                    \"ai.usage.completionTokens\": result2.usage.outputTokens.total,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result2.finishReason.unified\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens.total,\n                                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens.total\n                                }\n                            }));\n                            return {\n                                ...result2,\n                                objectText: text2,\n                                reasoning: reasoning2,\n                                responseData\n                            };\n                        }\n                    }));\n                result = generateResult.objectText;\n                finishReason = generateResult.finishReason.unified;\n                usage = asLanguageModelUsage(generateResult.usage);\n                warnings = generateResult.warnings;\n                resultProviderMetadata = generateResult.providerMetadata;\n                request = (_a17 = generateResult.request) != null ? _a17 : {};\n                response = generateResult.responseData;\n                reasoning = generateResult.reasoning;\n                logWarnings({\n                    warnings,\n                    provider: model.provider,\n                    model: model.modelId\n                });\n                const object2 = await parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, {\n                    response,\n                    usage,\n                    finishReason\n                });\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.response.finishReason\": finishReason,\n                        \"ai.response.object\": {\n                            output: ()=>JSON.stringify(object2)\n                        },\n                        \"ai.response.providerMetadata\": JSON.stringify(resultProviderMetadata),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": usage.inputTokens,\n                        \"ai.usage.completionTokens\": usage.outputTokens\n                    }\n                }));\n                return new DefaultGenerateObjectResult({\n                    object: object2,\n                    reasoning,\n                    finishReason,\n                    usage,\n                    warnings,\n                    request,\n                    response,\n                    providerMetadata: resultProviderMetadata\n                });\n            }\n        });\n    } catch (error) {\n        throw wrapGatewayError(error);\n    }\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.reasoning = options.reasoning;\n    }\n    toJsonResponse(init) {\n        var _a17;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n            headers: prepareHeaders(init == null ? void 0 : init.headers, {\n                \"content-type\": \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\n// src/generate-object/stream-object.ts\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new InvalidArgumentError({\n            parameter: \"vector1,vector2\",\n            value: {\n                vector1Length: vector1.length,\n                vector2Length: vector2.length\n            },\n            message: `Vectors must have the same length`\n        });\n    }\n    const n = vector1.length;\n    if (n === 0) {\n        return 0;\n    }\n    let magnitudeSquared1 = 0;\n    let magnitudeSquared2 = 0;\n    let dotProduct = 0;\n    for(let i = 0; i < n; i++){\n        const value1 = vector1[i];\n        const value2 = vector2[i];\n        magnitudeSquared1 += value1 * value1;\n        magnitudeSquared2 += value2 * value2;\n        dotProduct += value1 * value2;\n    }\n    return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n    const [header, base64Content] = dataUrl.split(\",\");\n    const mediaType = header.split(\";\")[0].split(\":\")[1];\n    if (mediaType == null || base64Content == null) {\n        throw new Error(\"Invalid data URL format\");\n    }\n    try {\n        return window.atob(base64Content);\n    } catch (error) {\n        throw new Error(`Error decoding data URL`);\n    }\n}\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (obj1 == null || obj2 == null) return false;\n    if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\") return obj1 === obj2;\n    if (obj1.constructor !== obj2.constructor) return false;\n    if (obj1 instanceof Date && obj2 instanceof Date) {\n        return obj1.getTime() === obj2.getTime();\n    }\n    if (Array.isArray(obj1)) {\n        if (obj1.length !== obj2.length) return false;\n        for(let i = 0; i < obj1.length; i++){\n            if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n        }\n        return true;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    for (const key of keys1){\n        if (!keys2.includes(key)) return false;\n        if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n    }\n    return true;\n}\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n    constructor(){\n        this.queue = [];\n        this.isProcessing = false;\n    }\n    async processQueue() {\n        if (this.isProcessing) {\n            return;\n        }\n        this.isProcessing = true;\n        while(this.queue.length > 0){\n            await this.queue[0]();\n            this.queue.shift();\n        }\n        this.isProcessing = false;\n    }\n    async run(job) {\n        return new Promise((resolve3, reject)=>{\n            this.queue.push(async ()=>{\n                try {\n                    await job();\n                    resolve3();\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            void this.processQueue();\n        });\n    }\n};\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({ chunks, initialDelayInMs = 0, chunkDelayInMs = 0, _internal }) {\n    var _a17;\n    const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n    let index = 0;\n    return new ReadableStream({\n        async pull (controller) {\n            if (index < chunks.length) {\n                await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n                controller.enqueue(chunks[index++]);\n            } else {\n                controller.close();\n            }\n        }\n    });\n}\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nfunction streamObject(options) {\n    const { model, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, experimental_download: download2, providerOptions, onError = ({ error })=>{\n        console.error(error);\n    }, onFinish, _internal: { generateId: generateId2 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings } = options;\n    const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n    const { schema: inputSchema, schemaDescription, schemaName } = \"schema\" in options ? options : {};\n    validateObjectGenerationInput({\n        output,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    return new DefaultStreamObjectResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        outputStrategy,\n        system,\n        prompt,\n        messages,\n        schemaName,\n        schemaDescription,\n        providerOptions,\n        repairText,\n        onError,\n        onFinish,\n        download: download2,\n        generateId: generateId2,\n        currentDate,\n        now: now2\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ model: modelArg, headers, telemetry, settings, maxRetries: maxRetriesArg, abortSignal, outputStrategy, system, prompt, messages, schemaName, schemaDescription, providerOptions, repairText, onError, onFinish, download: download2, generateId: generateId2, currentDate, now: now2 }){\n        this._object = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._usage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._providerMetadata = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._warnings = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._request = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._response = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        const model = resolveLanguageModel(modelArg);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg,\n            abortSignal\n        });\n        const callSettings = prepareCallSettings(settings);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...callSettings,\n                maxRetries\n            }\n        });\n        const tracer = getTracer(telemetry);\n        const self = this;\n        const stitchableStream = createStitchableStream();\n        const eventProcessor = new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"error\") {\n                    onError({\n                        error: wrapGatewayError(chunk.error)\n                    });\n                }\n            }\n        });\n        this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n        recordSpan({\n            name: \"ai.streamObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": {\n                        input: async ()=>JSON.stringify(await outputStrategy.jsonSchema())\n                    },\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpan)=>{\n                const standardizedPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const callOptions = {\n                    responseFormat: {\n                        type: \"json\",\n                        schema: await outputStrategy.jsonSchema(),\n                        name: schemaName,\n                        description: schemaDescription\n                    },\n                    ...prepareCallSettings(settings),\n                    prompt: await convertToLanguageModelPrompt({\n                        prompt: standardizedPrompt,\n                        supportedUrls: await model.supportedUrls,\n                        download: download2\n                    }),\n                    providerOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: false\n                };\n                const transformer = {\n                    transform: (chunk, controller)=>{\n                        switch(chunk.type){\n                            case \"text-delta\":\n                                controller.enqueue(chunk.delta);\n                                break;\n                            case \"response-metadata\":\n                            case \"finish\":\n                            case \"error\":\n                            case \"stream-start\":\n                                controller.enqueue(chunk);\n                                break;\n                        }\n                    }\n                };\n                const { result: { stream, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                        name: \"ai.streamObject.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamObject.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.messages\": {\n                                    input: ()=>stringifyForTelemetry(callOptions.prompt)\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                \"gen_ai.request.temperature\": callSettings.temperature,\n                                \"gen_ai.request.top_k\": callSettings.topK,\n                                \"gen_ai.request.top_p\": callSettings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan2)=>({\n                                startTimestampMs: now2(),\n                                doStreamSpan: doStreamSpan2,\n                                result: await model.doStream(callOptions)\n                            })\n                    }));\n                self._request.resolve(request != null ? request : {});\n                let warnings;\n                let usage = createNullLanguageModelUsage();\n                let finishReason;\n                let providerMetadata;\n                let object2;\n                let error;\n                let accumulatedText = \"\";\n                let textDelta = \"\";\n                let fullResponse = {\n                    id: generateId2(),\n                    timestamp: currentDate(),\n                    modelId: model.modelId\n                };\n                let latestObjectJson = void 0;\n                let latestObject = void 0;\n                let isFirstChunk = true;\n                let isFirstDelta = true;\n                const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(new TransformStream({\n                    async transform (chunk, controller) {\n                        var _a17, _b, _c;\n                        if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                            warnings = chunk.warnings;\n                            return;\n                        }\n                        if (isFirstChunk) {\n                            const msToFirstChunk = now2() - startTimestampMs;\n                            isFirstChunk = false;\n                            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                            doStreamSpan.setAttributes({\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                        }\n                        if (typeof chunk === \"string\") {\n                            accumulatedText += chunk;\n                            textDelta += chunk;\n                            const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                            if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                                const validationResult = await outputStrategy.validatePartialResult({\n                                    value: currentObjectJson,\n                                    textDelta,\n                                    latestObject,\n                                    isFirstDelta,\n                                    isFinalDelta: parseState === \"successful-parse\"\n                                });\n                                if (validationResult.success && !isDeepEqualData(latestObject, validationResult.value.partial)) {\n                                    latestObjectJson = currentObjectJson;\n                                    latestObject = validationResult.value.partial;\n                                    controller.enqueue({\n                                        type: \"object\",\n                                        object: latestObject\n                                    });\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        textDelta: validationResult.value.textDelta\n                                    });\n                                    textDelta = \"\";\n                                    isFirstDelta = false;\n                                }\n                            }\n                            return;\n                        }\n                        switch(chunk.type){\n                            case \"response-metadata\":\n                                {\n                                    fullResponse = {\n                                        id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,\n                                        timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                                        modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                                    };\n                                    break;\n                                }\n                            case \"finish\":\n                                {\n                                    if (textDelta !== \"\") {\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            textDelta\n                                        });\n                                    }\n                                    finishReason = chunk.finishReason.unified;\n                                    usage = asLanguageModelUsage(chunk.usage);\n                                    providerMetadata = chunk.providerMetadata;\n                                    controller.enqueue({\n                                        ...chunk,\n                                        finishReason: chunk.finishReason.unified,\n                                        usage,\n                                        response: fullResponse\n                                    });\n                                    logWarnings({\n                                        warnings: warnings != null ? warnings : [],\n                                        provider: model.provider,\n                                        model: model.modelId\n                                    });\n                                    self._usage.resolve(usage);\n                                    self._providerMetadata.resolve(providerMetadata);\n                                    self._warnings.resolve(warnings);\n                                    self._response.resolve({\n                                        ...fullResponse,\n                                        headers: response == null ? void 0 : response.headers\n                                    });\n                                    self._finishReason.resolve(finishReason != null ? finishReason : \"other\");\n                                    try {\n                                        object2 = await parseAndValidateObjectResultWithRepair(accumulatedText, outputStrategy, repairText, {\n                                            response: fullResponse,\n                                            usage,\n                                            finishReason\n                                        });\n                                        self._object.resolve(object2);\n                                    } catch (e) {\n                                        error = e;\n                                        self._object.reject(e);\n                                    }\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(chunk);\n                                    break;\n                                }\n                        }\n                    },\n                    // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                    async flush (controller) {\n                        try {\n                            const finalUsage = usage != null ? usage : {\n                                promptTokens: NaN,\n                                completionTokens: NaN,\n                                totalTokens: NaN\n                            };\n                            doStreamSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": finishReason,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.id\": fullResponse.id,\n                                    \"ai.response.model\": fullResponse.modelId,\n                                    \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                                    \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                                    \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                                    \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                                    \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                                    \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                                    \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        finishReason\n                                    ],\n                                    \"gen_ai.response.id\": fullResponse.id,\n                                    \"gen_ai.response.model\": fullResponse.modelId,\n                                    \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                                    \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                                }\n                            }));\n                            doStreamSpan.end();\n                            rootSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                                    \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                                    \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                                    \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                                    \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                                }\n                            }));\n                            await (onFinish == null ? void 0 : onFinish({\n                                usage: finalUsage,\n                                object: object2,\n                                error,\n                                response: {\n                                    ...fullResponse,\n                                    headers: response == null ? void 0 : response.headers\n                                },\n                                warnings,\n                                providerMetadata\n                            }));\n                        } catch (error2) {\n                            controller.enqueue({\n                                type: \"error\",\n                                error: error2\n                            });\n                        } finally{\n                            rootSpan.end();\n                        }\n                    }\n                }));\n                stitchableStream.addStream(transformedStream);\n            }\n        }).catch((error)=>{\n            stitchableStream.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n        }).finally(()=>{\n            stitchableStream.close();\n        });\n        this.outputStrategy = outputStrategy;\n    }\n    get object() {\n        return this._object.promise;\n    }\n    get usage() {\n        return this._usage.promise;\n    }\n    get providerMetadata() {\n        return this._providerMetadata.promise;\n    }\n    get warnings() {\n        return this._warnings.promise;\n    }\n    get request() {\n        return this._request.promise;\n    }\n    get response() {\n        return this._response.promise;\n    }\n    get finishReason() {\n        return this._finishReason.promise;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.baseStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.baseStream);\n    }\n    pipeTextStreamToResponse(response, init) {\n        pipeTextStreamToResponse({\n            response,\n            textStream: this.textStream,\n            ...init\n        });\n    }\n    toTextStreamResponse(init) {\n        return createTextStreamResponse({\n            textStream: this.textStream,\n            ...init\n        });\n    }\n};\n// src/generate-speech/generate-speech.ts\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n    constructor({ data, mediaType }){\n        super({\n            data,\n            mediaType\n        });\n        let format = \"mp3\";\n        if (mediaType) {\n            const mediaTypeParts = mediaType.split(\"/\");\n            if (mediaTypeParts.length === 2) {\n                if (mediaType !== \"audio/mpeg\") {\n                    format = mediaTypeParts[1];\n                }\n            }\n        }\n        if (!format) {\n            throw new Error(\"Audio format must be provided or determinable from media type\");\n        }\n        this.format = format;\n    }\n};\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({ model, text: text2, voice, outputFormat, instructions, speed, language, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17;\n    const resolvedModel = resolveSpeechModel(model);\n    if (!resolvedModel) {\n        throw new Error(\"Model could not be resolved\");\n    }\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const result = await retry(()=>resolvedModel.doGenerate({\n            text: text2,\n            voice,\n            outputFormat,\n            instructions,\n            speed,\n            language,\n            abortSignal,\n            headers: headersWithUserAgent,\n            providerOptions\n        }));\n    if (!result.audio || result.audio.length === 0) {\n        throw new NoSpeechGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    logWarnings({\n        warnings: result.warnings,\n        provider: resolvedModel.provider,\n        model: resolvedModel.modelId\n    });\n    return new DefaultSpeechResult({\n        audio: new DefaultGeneratedAudioFile({\n            data: result.audio,\n            mediaType: (_a17 = detectMediaType({\n                data: result.audio,\n                signatures: audioMediaTypeSignatures\n            })) != null ? _a17 : \"audio/mp3\"\n        }),\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultSpeechResult = class {\n    constructor(options){\n        var _a17;\n        this.audio = options.audio;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// src/generate-text/prune-messages.ts\nfunction pruneMessages({ messages, reasoning = \"none\", toolCalls = [], emptyMessages = \"remove\" }) {\n    if (reasoning === \"all\" || reasoning === \"before-last-message\") {\n        messages = messages.map((message, messageIndex)=>{\n            if (message.role !== \"assistant\" || typeof message.content === \"string\" || reasoning === \"before-last-message\" && messageIndex === messages.length - 1) {\n                return message;\n            }\n            return {\n                ...message,\n                content: message.content.filter((part)=>part.type !== \"reasoning\")\n            };\n        });\n    }\n    if (toolCalls === \"none\") {\n        toolCalls = [];\n    } else if (toolCalls === \"all\") {\n        toolCalls = [\n            {\n                type: \"all\"\n            }\n        ];\n    } else if (toolCalls === \"before-last-message\") {\n        toolCalls = [\n            {\n                type: \"before-last-message\"\n            }\n        ];\n    } else if (typeof toolCalls === \"string\") {\n        toolCalls = [\n            {\n                type: toolCalls\n            }\n        ];\n    }\n    for (const toolCall of toolCalls){\n        const keepLastMessagesCount = toolCall.type === \"all\" ? void 0 : toolCall.type === \"before-last-message\" ? 1 : Number(toolCall.type.slice(\"before-last-\".length).slice(0, -\"-messages\".length));\n        const keptToolCallIds = /* @__PURE__ */ new Set();\n        const keptApprovalIds = /* @__PURE__ */ new Set();\n        if (keepLastMessagesCount != null) {\n            for (const message of messages.slice(-keepLastMessagesCount)){\n                if ((message.role === \"assistant\" || message.role === \"tool\") && typeof message.content !== \"string\") {\n                    for (const part of message.content){\n                        if (part.type === \"tool-call\" || part.type === \"tool-result\") {\n                            keptToolCallIds.add(part.toolCallId);\n                        } else if (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") {\n                            keptApprovalIds.add(part.approvalId);\n                        }\n                    }\n                }\n            }\n        }\n        messages = messages.map((message, messageIndex)=>{\n            if (message.role !== \"assistant\" && message.role !== \"tool\" || typeof message.content === \"string\" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {\n                return message;\n            }\n            const toolCallIdToToolName = {};\n            const approvalIdToToolName = {};\n            return {\n                ...message,\n                content: message.content.filter((part)=>{\n                    if (part.type !== \"tool-call\" && part.type !== \"tool-result\" && part.type !== \"tool-approval-request\" && part.type !== \"tool-approval-response\") {\n                        return true;\n                    }\n                    if (part.type === \"tool-call\") {\n                        toolCallIdToToolName[part.toolCallId] = part.toolName;\n                    } else if (part.type === \"tool-approval-request\") {\n                        approvalIdToToolName[part.approvalId] = toolCallIdToToolName[part.toolCallId];\n                    }\n                    if ((part.type === \"tool-call\" || part.type === \"tool-result\") && keptToolCallIds.has(part.toolCallId) || (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") && keptApprovalIds.has(part.approvalId)) {\n                        return true;\n                    }\n                    return toolCall.tools != null && !toolCall.tools.includes(part.type === \"tool-call\" || part.type === \"tool-result\" ? part.toolName : approvalIdToToolName[part.approvalId]);\n                })\n            };\n        });\n    }\n    if (emptyMessages === \"remove\") {\n        messages = messages.filter((message)=>message.content.length > 0);\n    }\n    return messages;\n}\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n    word: /\\S+\\s+/m,\n    line: /\\n+/m\n};\nfunction smoothStream({ delayInMs = 10, chunking = \"word\", _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {} } = {}) {\n    let detectChunk;\n    if (chunking != null && typeof chunking === \"object\" && \"segment\" in chunking && typeof chunking.segment === \"function\") {\n        const segmenter = chunking;\n        detectChunk = (buffer)=>{\n            if (buffer.length === 0) return null;\n            const iterator = segmenter.segment(buffer)[Symbol.iterator]();\n            const first = iterator.next().value;\n            return (first == null ? void 0 : first.segment) || null;\n        };\n    } else if (typeof chunking === \"function\") {\n        detectChunk = (buffer)=>{\n            const match = chunking(buffer);\n            if (match == null) {\n                return null;\n            }\n            if (!match.length) {\n                throw new Error(`Chunking function must return a non-empty string.`);\n            }\n            if (!buffer.startsWith(match)) {\n                throw new Error(`Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`);\n            }\n            return match;\n        };\n    } else {\n        const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking instanceof RegExp ? chunking : void 0;\n        if (chunkingRegex == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n                argument: \"chunking\",\n                message: `Chunking must be \"word\", \"line\", a RegExp, an Intl.Segmenter, or a ChunkDetector function. Received: ${chunking}`\n            });\n        }\n        detectChunk = (buffer)=>{\n            const match = chunkingRegex.exec(buffer);\n            if (!match) {\n                return null;\n            }\n            return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n        };\n    }\n    return ()=>{\n        let buffer = \"\";\n        let id = \"\";\n        let type = void 0;\n        let providerMetadata = void 0;\n        function flushBuffer(controller) {\n            if (buffer.length > 0 && type !== void 0) {\n                controller.enqueue({\n                    type,\n                    text: buffer,\n                    id,\n                    ...providerMetadata != null ? {\n                        providerMetadata\n                    } : {}\n                });\n                buffer = \"\";\n                providerMetadata = void 0;\n            }\n        }\n        return new TransformStream({\n            async transform (chunk, controller) {\n                if (chunk.type !== \"text-delta\" && chunk.type !== \"reasoning-delta\") {\n                    flushBuffer(controller);\n                    controller.enqueue(chunk);\n                    return;\n                }\n                if ((chunk.type !== type || chunk.id !== id) && buffer.length > 0) {\n                    flushBuffer(controller);\n                }\n                buffer += chunk.text;\n                id = chunk.id;\n                type = chunk.type;\n                if (chunk.providerMetadata != null) {\n                    providerMetadata = chunk.providerMetadata;\n                }\n                let match;\n                while((match = detectChunk(buffer)) != null){\n                    controller.enqueue({\n                        type,\n                        text: match,\n                        id\n                    });\n                    buffer = buffer.slice(match.length);\n                    await delay2(delayInMs);\n                }\n            }\n        });\n    };\n}\n// src/middleware/default-embedding-settings-middleware.ts\nfunction defaultEmbeddingSettingsMiddleware({ settings }) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            return mergeObjects(settings, params);\n        }\n    };\n}\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({ settings }) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            return mergeObjects(settings, params);\n        }\n    };\n}\n// src/middleware/extract-json-middleware.ts\nfunction defaultTransform(text2) {\n    return text2.replace(/^```(?:json)?\\s*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\").trim();\n}\nfunction extractJsonMiddleware(options) {\n    var _a17;\n    const transform = (_a17 = options == null ? void 0 : options.transform) != null ? _a17 : defaultTransform;\n    const hasCustomTransform = (options == null ? void 0 : options.transform) !== void 0;\n    return {\n        specificationVersion: \"v3\",\n        wrapGenerate: async ({ doGenerate })=>{\n            const { content, ...rest } = await doGenerate();\n            const transformedContent = [];\n            for (const part of content){\n                if (part.type !== \"text\") {\n                    transformedContent.push(part);\n                    continue;\n                }\n                transformedContent.push({\n                    ...part,\n                    text: transform(part.text)\n                });\n            }\n            return {\n                content: transformedContent,\n                ...rest\n            };\n        },\n        wrapStream: async ({ doStream })=>{\n            const { stream, ...rest } = await doStream();\n            const textBlocks = {};\n            const SUFFIX_BUFFER_SIZE = 12;\n            return {\n                stream: stream.pipeThrough(new TransformStream({\n                    transform: (chunk, controller)=>{\n                        if (chunk.type === \"text-start\") {\n                            textBlocks[chunk.id] = {\n                                startEvent: chunk,\n                                // Custom transforms need to buffer all content\n                                phase: hasCustomTransform ? \"buffering\" : \"prefix\",\n                                buffer: \"\",\n                                prefixStripped: false\n                            };\n                            return;\n                        }\n                        if (chunk.type === \"text-delta\") {\n                            const block = textBlocks[chunk.id];\n                            if (!block) {\n                                controller.enqueue(chunk);\n                                return;\n                            }\n                            block.buffer += chunk.delta;\n                            if (block.phase === \"buffering\") {\n                                return;\n                            }\n                            if (block.phase === \"prefix\") {\n                                if (block.buffer.length > 0 && !block.buffer.startsWith(\"`\")) {\n                                    block.phase = \"streaming\";\n                                    controller.enqueue(block.startEvent);\n                                } else if (block.buffer.startsWith(\"```\")) {\n                                    if (block.buffer.includes(\"\\n\")) {\n                                        const prefixMatch = block.buffer.match(/^```(?:json)?\\s*\\n/);\n                                        if (prefixMatch) {\n                                            block.buffer = block.buffer.slice(prefixMatch[0].length);\n                                            block.prefixStripped = true;\n                                            block.phase = \"streaming\";\n                                            controller.enqueue(block.startEvent);\n                                        } else {\n                                            block.phase = \"streaming\";\n                                            controller.enqueue(block.startEvent);\n                                        }\n                                    }\n                                } else if (block.buffer.length >= 3 && !block.buffer.startsWith(\"```\")) {\n                                    block.phase = \"streaming\";\n                                    controller.enqueue(block.startEvent);\n                                }\n                            }\n                            if (block.phase === \"streaming\" && block.buffer.length > SUFFIX_BUFFER_SIZE) {\n                                const toStream = block.buffer.slice(0, -SUFFIX_BUFFER_SIZE);\n                                block.buffer = block.buffer.slice(-SUFFIX_BUFFER_SIZE);\n                                controller.enqueue({\n                                    type: \"text-delta\",\n                                    id: chunk.id,\n                                    delta: toStream\n                                });\n                            }\n                            return;\n                        }\n                        if (chunk.type === \"text-end\") {\n                            const block = textBlocks[chunk.id];\n                            if (block) {\n                                if (block.phase === \"prefix\" || block.phase === \"buffering\") {\n                                    controller.enqueue(block.startEvent);\n                                }\n                                let remaining = block.buffer;\n                                if (block.phase === \"buffering\") {\n                                    remaining = transform(remaining);\n                                } else if (block.prefixStripped) {\n                                    remaining = remaining.replace(/\\n?```\\s*$/, \"\").trimEnd();\n                                } else {\n                                    remaining = transform(remaining);\n                                }\n                                if (remaining.length > 0) {\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        id: chunk.id,\n                                        delta: remaining\n                                    });\n                                }\n                                controller.enqueue(chunk);\n                                delete textBlocks[chunk.id];\n                                return;\n                            }\n                        }\n                        controller.enqueue(chunk);\n                    }\n                })),\n                ...rest\n            };\n        }\n    };\n}\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n    if (searchedText.length === 0) {\n        return null;\n    }\n    const directIndex = text2.indexOf(searchedText);\n    if (directIndex !== -1) {\n        return directIndex;\n    }\n    for(let i = text2.length - 1; i >= 0; i--){\n        const suffix = text2.substring(i);\n        if (searchedText.startsWith(suffix)) {\n            return i;\n        }\n    }\n    return null;\n}\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({ tagName, separator = \"\\n\", startWithReasoning = false }) {\n    const openingTag = `<${tagName}>`;\n    const closingTag = `</${tagName}>`;\n    return {\n        specificationVersion: \"v3\",\n        wrapGenerate: async ({ doGenerate })=>{\n            const { content, ...rest } = await doGenerate();\n            const transformedContent = [];\n            for (const part of content){\n                if (part.type !== \"text\") {\n                    transformedContent.push(part);\n                    continue;\n                }\n                const text2 = startWithReasoning ? openingTag + part.text : part.text;\n                const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n                const matches = Array.from(text2.matchAll(regexp));\n                if (!matches.length) {\n                    transformedContent.push(part);\n                    continue;\n                }\n                const reasoningText = matches.map((match)=>match[1]).join(separator);\n                let textWithoutReasoning = text2;\n                for(let i = matches.length - 1; i >= 0; i--){\n                    const match = matches[i];\n                    const beforeMatch = textWithoutReasoning.slice(0, match.index);\n                    const afterMatch = textWithoutReasoning.slice(match.index + match[0].length);\n                    textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n                }\n                transformedContent.push({\n                    type: \"reasoning\",\n                    text: reasoningText\n                });\n                transformedContent.push({\n                    type: \"text\",\n                    text: textWithoutReasoning\n                });\n            }\n            return {\n                content: transformedContent,\n                ...rest\n            };\n        },\n        wrapStream: async ({ doStream })=>{\n            const { stream, ...rest } = await doStream();\n            const reasoningExtractions = {};\n            let delayedTextStart;\n            return {\n                stream: stream.pipeThrough(new TransformStream({\n                    transform: (chunk, controller)=>{\n                        if (chunk.type === \"text-start\") {\n                            delayedTextStart = chunk;\n                            return;\n                        }\n                        if (chunk.type === \"text-end\" && delayedTextStart) {\n                            controller.enqueue(delayedTextStart);\n                            delayedTextStart = void 0;\n                        }\n                        if (chunk.type !== \"text-delta\") {\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (reasoningExtractions[chunk.id] == null) {\n                            reasoningExtractions[chunk.id] = {\n                                isFirstReasoning: true,\n                                isFirstText: true,\n                                afterSwitch: false,\n                                isReasoning: startWithReasoning,\n                                buffer: \"\",\n                                idCounter: 0,\n                                textId: chunk.id\n                            };\n                        }\n                        const activeExtraction = reasoningExtractions[chunk.id];\n                        activeExtraction.buffer += chunk.delta;\n                        function publish(text2) {\n                            if (text2.length > 0) {\n                                const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                                if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                                    controller.enqueue({\n                                        type: \"reasoning-start\",\n                                        id: `reasoning-${activeExtraction.idCounter}`\n                                    });\n                                }\n                                if (activeExtraction.isReasoning) {\n                                    controller.enqueue({\n                                        type: \"reasoning-delta\",\n                                        delta: prefix + text2,\n                                        id: `reasoning-${activeExtraction.idCounter}`\n                                    });\n                                } else {\n                                    if (delayedTextStart) {\n                                        controller.enqueue(delayedTextStart);\n                                        delayedTextStart = void 0;\n                                    }\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        delta: prefix + text2,\n                                        id: activeExtraction.textId\n                                    });\n                                }\n                                activeExtraction.afterSwitch = false;\n                                if (activeExtraction.isReasoning) {\n                                    activeExtraction.isFirstReasoning = false;\n                                } else {\n                                    activeExtraction.isFirstText = false;\n                                }\n                            }\n                        }\n                        do {\n                            const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                            const startIndex = getPotentialStartIndex(activeExtraction.buffer, nextTag);\n                            if (startIndex == null) {\n                                publish(activeExtraction.buffer);\n                                activeExtraction.buffer = \"\";\n                                break;\n                            }\n                            publish(activeExtraction.buffer.slice(0, startIndex));\n                            const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                            if (foundFullMatch) {\n                                activeExtraction.buffer = activeExtraction.buffer.slice(startIndex + nextTag.length);\n                                if (activeExtraction.isReasoning) {\n                                    controller.enqueue({\n                                        type: \"reasoning-end\",\n                                        id: `reasoning-${activeExtraction.idCounter++}`\n                                    });\n                                }\n                                activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                                activeExtraction.afterSwitch = true;\n                            } else {\n                                activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                                break;\n                            }\n                        }while (true);\n                    }\n                })),\n                ...rest\n            };\n        }\n    };\n}\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n    return {\n        specificationVersion: \"v3\",\n        wrapStream: async ({ doGenerate })=>{\n            const result = await doGenerate();\n            let id = 0;\n            const simulatedStream = new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"stream-start\",\n                        warnings: result.warnings\n                    });\n                    controller.enqueue({\n                        type: \"response-metadata\",\n                        ...result.response\n                    });\n                    for (const part of result.content){\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    if (part.text.length > 0) {\n                                        controller.enqueue({\n                                            type: \"text-start\",\n                                            id: String(id)\n                                        });\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            id: String(id),\n                                            delta: part.text\n                                        });\n                                        controller.enqueue({\n                                            type: \"text-end\",\n                                            id: String(id)\n                                        });\n                                        id++;\n                                    }\n                                    break;\n                                }\n                            case \"reasoning\":\n                                {\n                                    controller.enqueue({\n                                        type: \"reasoning-start\",\n                                        id: String(id),\n                                        providerMetadata: part.providerMetadata\n                                    });\n                                    controller.enqueue({\n                                        type: \"reasoning-delta\",\n                                        id: String(id),\n                                        delta: part.text\n                                    });\n                                    controller.enqueue({\n                                        type: \"reasoning-end\",\n                                        id: String(id)\n                                    });\n                                    id++;\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(part);\n                                    break;\n                                }\n                        }\n                    }\n                    controller.enqueue({\n                        type: \"finish\",\n                        finishReason: result.finishReason,\n                        usage: result.usage,\n                        providerMetadata: result.providerMetadata\n                    });\n                    controller.close();\n                }\n            });\n            return {\n                stream: simulatedStream,\n                request: result.request,\n                response: result.response\n            };\n        }\n    };\n}\n// src/middleware/add-tool-input-examples-middleware.ts\nfunction defaultFormatExample(example) {\n    return JSON.stringify(example.input);\n}\nfunction addToolInputExamplesMiddleware({ prefix = \"Input Examples:\", format = defaultFormatExample, remove = true } = {}) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            var _a17;\n            if (!((_a17 = params.tools) == null ? void 0 : _a17.length)) {\n                return params;\n            }\n            const transformedTools = params.tools.map((tool2)=>{\n                var _a18;\n                if (tool2.type !== \"function\" || !((_a18 = tool2.inputExamples) == null ? void 0 : _a18.length)) {\n                    return tool2;\n                }\n                const formattedExamples = tool2.inputExamples.map((example, index)=>format(example, index)).join(\"\\n\");\n                const examplesSection = `${prefix}\n${formattedExamples}`;\n                const toolDescription = tool2.description ? `${tool2.description}\n\n${examplesSection}` : examplesSection;\n                return {\n                    ...tool2,\n                    description: toolDescription,\n                    inputExamples: remove ? void 0 : tool2.inputExamples\n                };\n            });\n            return {\n                ...params,\n                tools: transformedTools\n            };\n        }\n    };\n}\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap = ({ model, middleware: { transformParams, wrapGenerate, wrapStream, overrideProvider, overrideModelId, overrideSupportedUrls }, modelId, providerId })=>{\n    var _a17, _b, _c;\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type,\n            model\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v3\",\n        provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _a17 : model.provider,\n        modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _b : model.modelId,\n        supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({\n            model\n        })) != null ? _c : model.supportedUrls,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// src/middleware/wrap-embedding-model.ts\nvar wrapEmbeddingModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap2({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap2 = ({ model, middleware: { transformParams, wrapEmbed, overrideProvider, overrideModelId, overrideMaxEmbeddingsPerCall, overrideSupportsParallelCalls }, modelId, providerId })=>{\n    var _a17, _b, _c, _d;\n    async function doTransform({ params }) {\n        return transformParams ? await transformParams({\n            params,\n            model\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v3\",\n        provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _a17 : model.provider,\n        modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _b : model.modelId,\n        maxEmbeddingsPerCall: (_c = overrideMaxEmbeddingsPerCall == null ? void 0 : overrideMaxEmbeddingsPerCall({\n            model\n        })) != null ? _c : model.maxEmbeddingsPerCall,\n        supportsParallelCalls: (_d = overrideSupportsParallelCalls == null ? void 0 : overrideSupportsParallelCalls({\n            model\n        })) != null ? _d : model.supportsParallelCalls,\n        async doEmbed (params) {\n            const transformedParams = await doTransform({\n                params\n            });\n            const doEmbed = async ()=>model.doEmbed(transformedParams);\n            return wrapEmbed ? wrapEmbed({\n                doEmbed,\n                params: transformedParams,\n                model\n            }) : doEmbed();\n        }\n    };\n};\n// src/middleware/wrap-image-model.ts\nvar wrapImageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap3({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap3 = ({ model, middleware: { transformParams, wrapGenerate, overrideProvider, overrideModelId, overrideMaxImagesPerCall }, modelId, providerId })=>{\n    var _a17, _b, _c;\n    async function doTransform({ params }) {\n        return transformParams ? await transformParams({\n            params,\n            model\n        }) : params;\n    }\n    const maxImagesPerCallRaw = (_a17 = overrideMaxImagesPerCall == null ? void 0 : overrideMaxImagesPerCall({\n        model\n    })) != null ? _a17 : model.maxImagesPerCall;\n    const maxImagesPerCall = maxImagesPerCallRaw instanceof Function ? maxImagesPerCallRaw.bind(model) : maxImagesPerCallRaw;\n    return {\n        specificationVersion: \"v3\",\n        provider: (_b = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _b : model.provider,\n        modelId: (_c = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _c : model.modelId,\n        maxImagesPerCall,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        }\n    };\n};\n// src/model/as-provider-v3.ts\nfunction asProviderV3(provider) {\n    if (\"specificationVersion\" in provider && provider.specificationVersion === \"v3\") {\n        return provider;\n    }\n    const v2Provider = provider;\n    return {\n        specificationVersion: \"v3\",\n        languageModel: (modelId)=>asLanguageModelV3(v2Provider.languageModel(modelId)),\n        embeddingModel: (modelId)=>asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),\n        imageModel: (modelId)=>asImageModelV3(v2Provider.imageModel(modelId)),\n        transcriptionModel: v2Provider.transcriptionModel ? (modelId)=>asTranscriptionModelV3(v2Provider.transcriptionModel(modelId)) : void 0,\n        speechModel: v2Provider.speechModel ? (modelId)=>asSpeechModelV3(v2Provider.speechModel(modelId)) : void 0,\n        rerankingModel: void 0\n    };\n}\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({ provider, languageModelMiddleware, imageModelMiddleware }) {\n    const providerV3 = asProviderV3(provider);\n    return {\n        specificationVersion: \"v3\",\n        languageModel: (modelId)=>wrapLanguageModel({\n                model: providerV3.languageModel(modelId),\n                middleware: languageModelMiddleware\n            }),\n        embeddingModel: providerV3.embeddingModel,\n        imageModel: (modelId)=>{\n            let model = providerV3.imageModel(modelId);\n            if (imageModelMiddleware != null) {\n                model = wrapImageModel({\n                    model,\n                    middleware: imageModelMiddleware\n                });\n            }\n            return model;\n        },\n        transcriptionModel: providerV3.transcriptionModel,\n        speechModel: providerV3.speechModel,\n        rerankingModel: providerV3.rerankingModel\n    };\n}\n// src/registry/custom-provider.ts\n\nfunction customProvider({ languageModels, embeddingModels, imageModels, transcriptionModels, speechModels, rerankingModels, fallbackProvider: fallbackProviderArg }) {\n    const fallbackProvider = fallbackProviderArg ? asProviderV3(fallbackProviderArg) : void 0;\n    return {\n        specificationVersion: \"v3\",\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        embeddingModel (modelId) {\n            if (embeddingModels != null && modelId in embeddingModels) {\n                return embeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.embeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"embeddingModel\"\n            });\n        },\n        imageModel (modelId) {\n            if (imageModels != null && modelId in imageModels) {\n                return imageModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n                return fallbackProvider.imageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"imageModel\"\n            });\n        },\n        transcriptionModel (modelId) {\n            if (transcriptionModels != null && modelId in transcriptionModels) {\n                return transcriptionModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n                return fallbackProvider.transcriptionModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"transcriptionModel\"\n            });\n        },\n        speechModel (modelId) {\n            if (speechModels != null && modelId in speechModels) {\n                return speechModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n                return fallbackProvider.speechModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"speechModel\"\n            });\n        },\n        rerankingModel (modelId) {\n            if (rerankingModels != null && modelId in rerankingModels) {\n                return rerankingModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.rerankingModel) {\n                return fallbackProvider.rerankingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"rerankingModel\"\n            });\n        }\n    };\n}\nvar experimental_customProvider = customProvider;\n// src/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name16,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a16] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n    }\n};\n_a16 = symbol16;\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, { separator = \":\", languageModelMiddleware, imageModelMiddleware } = {}) {\n    const registry = new DefaultProviderRegistry({\n        separator,\n        languageModelMiddleware,\n        imageModelMiddleware\n    });\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor({ separator, languageModelMiddleware, imageModelMiddleware }){\n        this.providers = {};\n        this.separator = separator;\n        this.languageModelMiddleware = languageModelMiddleware;\n        this.imageModelMiddleware = imageModelMiddleware;\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id, modelType) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType,\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(this.separator);\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + this.separator.length)\n        ];\n    }\n    languageModel(id) {\n        var _a17, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        let model = (_b = (_a17 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(_a17, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        if (this.languageModelMiddleware != null) {\n            model = wrapLanguageModel({\n                model,\n                middleware: this.languageModelMiddleware\n            });\n        }\n        return model;\n    }\n    embeddingModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"embeddingModel\");\n        const provider = this.getProvider(providerId, \"embeddingModel\");\n        const model = (_a17 = provider.embeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"embeddingModel\"\n            });\n        }\n        return model;\n    }\n    imageModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"imageModel\");\n        const provider = this.getProvider(providerId, \"imageModel\");\n        let model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"imageModel\"\n            });\n        }\n        if (this.imageModelMiddleware != null) {\n            model = wrapImageModel({\n                model,\n                middleware: this.imageModelMiddleware\n            });\n        }\n        return model;\n    }\n    transcriptionModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n        const provider = this.getProvider(providerId, \"transcriptionModel\");\n        const model = (_a17 = provider.transcriptionModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"transcriptionModel\"\n            });\n        }\n        return model;\n    }\n    speechModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"speechModel\");\n        const provider = this.getProvider(providerId, \"speechModel\");\n        const model = (_a17 = provider.speechModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"speechModel\"\n            });\n        }\n        return model;\n    }\n    rerankingModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"rerankingModel\");\n        const provider = this.getProvider(providerId, \"rerankingModel\");\n        const model = (_a17 = provider.rerankingModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"rerankingModel\"\n            });\n        }\n        return model;\n    }\n};\n// src/rerank/rerank.ts\nasync function rerank({ model, documents, query, topN, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {\n    if (documents.length === 0) {\n        return new DefaultRerankResult({\n            originalDocuments: [],\n            ranking: [],\n            providerMetadata: void 0,\n            response: {\n                timestamp: /* @__PURE__ */ new Date(),\n                modelId: model.modelId\n            }\n        });\n    }\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const documentsToSend = typeof documents[0] === \"string\" ? {\n        type: \"text\",\n        values: documents\n    } : {\n        type: \"object\",\n        values: documents\n    };\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.rerank\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.rerank\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.documents\": {\n                    input: ()=>documents.map((document)=>JSON.stringify(document))\n                }\n            }\n        }),\n        tracer,\n        fn: async ()=>{\n            var _a17, _b;\n            const { ranking, response, providerMetadata, warnings } = await retry(()=>recordSpan({\n                    name: \"ai.rerank.doRerank\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.rerank.doRerank\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.documents\": {\n                                input: ()=>documents.map((document)=>JSON.stringify(document))\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doRerankSpan)=>{\n                        const modelResponse = await model.doRerank({\n                            documents: documentsToSend,\n                            query,\n                            topN,\n                            providerOptions,\n                            abortSignal,\n                            headers\n                        });\n                        const ranking2 = modelResponse.ranking;\n                        doRerankSpan.setAttributes(await selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.ranking.type\": documentsToSend.type,\n                                \"ai.ranking\": {\n                                    output: ()=>ranking2.map((ranking3)=>JSON.stringify(ranking3))\n                                }\n                            }\n                        }));\n                        return {\n                            ranking: ranking2,\n                            providerMetadata: modelResponse.providerMetadata,\n                            response: modelResponse.response,\n                            warnings: modelResponse.warnings\n                        };\n                    }\n                }));\n            logWarnings({\n                warnings: warnings != null ? warnings : [],\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultRerankResult({\n                originalDocuments: documents,\n                ranking: ranking.map((ranking2)=>({\n                        originalIndex: ranking2.index,\n                        score: ranking2.relevanceScore,\n                        document: documents[ranking2.index]\n                    })),\n                providerMetadata,\n                response: {\n                    id: response == null ? void 0 : response.id,\n                    timestamp: (_a17 = response == null ? void 0 : response.timestamp) != null ? _a17 : /* @__PURE__ */ new Date(),\n                    modelId: (_b = response == null ? void 0 : response.modelId) != null ? _b : model.modelId,\n                    headers: response == null ? void 0 : response.headers,\n                    body: response == null ? void 0 : response.body\n                }\n            });\n        }\n    });\n}\nvar DefaultRerankResult = class {\n    constructor(options){\n        this.originalDocuments = options.originalDocuments;\n        this.ranking = options.ranking;\n        this.response = options.response;\n        this.providerMetadata = options.providerMetadata;\n    }\n    get rerankedDocuments() {\n        return this.ranking.map((ranking)=>ranking.document);\n    }\n};\n// src/transcribe/transcribe.ts\n\n// src/error/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoTranscriptGeneratedError\",\n            message: \"No transcript generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// src/transcribe/transcribe.ts\nasync function transcribe({ model, audio, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    const resolvedModel = resolveTranscriptionModel(model);\n    if (!resolvedModel) {\n        throw new Error(\"Model could not be resolved\");\n    }\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const audioData = audio instanceof URL ? (await download({\n        url: audio\n    })).data : convertDataContentToUint8Array(audio);\n    const result = await retry(()=>{\n        var _a17;\n        return resolvedModel.doGenerate({\n            audio: audioData,\n            abortSignal,\n            headers: headersWithUserAgent,\n            providerOptions,\n            mediaType: (_a17 = detectMediaType({\n                data: audioData,\n                signatures: audioMediaTypeSignatures\n            })) != null ? _a17 : \"audio/wav\"\n        });\n    });\n    logWarnings({\n        warnings: result.warnings,\n        provider: resolvedModel.provider,\n        model: resolvedModel.modelId\n    });\n    if (!result.text) {\n        throw new NoTranscriptGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    return new DefaultTranscriptionResult({\n        text: result.text,\n        segments: result.segments,\n        language: result.language,\n        durationInSeconds: result.durationInSeconds,\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultTranscriptionResult = class {\n    constructor(options){\n        var _a17;\n        this.text = options.text;\n        this.segments = options.segments;\n        this.language = options.language;\n        this.durationInSeconds = options.durationInSeconds;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// src/ui/call-completion-api.ts\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({ stream, onTextPart }) {\n    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        await onTextPart(value);\n    }\n}\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = ()=>fetch;\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = \"data\", setCompletion, setLoading, setError, setAbortController, onFinish, onError, fetch: fetch2 = getOriginalFetch() }) {\n    var _a17;\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const response = await fetch2(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({\n                \"Content-Type\": \"application/json\",\n                ...headers\n            }, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (!response.ok) {\n            throw new Error((_a17 = await response.text()) != null ? _a17 : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        switch(streamProtocol){\n            case \"text\":\n                {\n                    await processTextStream({\n                        stream: response.body,\n                        onTextPart: (chunk)=>{\n                            result += chunk;\n                            setCompletion(result);\n                        }\n                    });\n                    break;\n                }\n            case \"data\":\n                {\n                    await consumeStream({\n                        stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n                            stream: response.body,\n                            schema: uiMessageChunkSchema\n                        }).pipeThrough(new TransformStream({\n                            async transform (part) {\n                                if (!part.success) {\n                                    throw part.error;\n                                }\n                                const streamPart = part.value;\n                                if (streamPart.type === \"text-delta\") {\n                                    result += streamPart.delta;\n                                    setCompletion(result);\n                                } else if (streamPart.type === \"error\") {\n                                    throw new Error(streamPart.errorText);\n                                }\n                            }\n                        })),\n                        onError: (error)=>{\n                            throw error;\n                        }\n                    });\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamProtocol;\n                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// src/ui/chat.ts\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n    if (files == null) {\n        return [];\n    }\n    if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n        throw new Error(\"FileList is not supported in the current environment\");\n    }\n    return Promise.all(Array.from(files).map(async (file)=>{\n        const { name: name17, type } = file;\n        const dataUrl = await new Promise((resolve3, reject)=>{\n            const reader = new FileReader();\n            reader.onload = (readerEvent)=>{\n                var _a17;\n                resolve3((_a17 = readerEvent.target) == null ? void 0 : _a17.result);\n            };\n            reader.onerror = (error)=>reject(error);\n            reader.readAsDataURL(file);\n        });\n        return {\n            type: \"file\",\n            mediaType: type,\n            filename: name17,\n            url: dataUrl\n        };\n    }));\n}\n// src/ui/default-chat-transport.ts\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n    constructor({ api = \"/api/chat\", credentials, headers, body, fetch: fetch2, prepareSendMessagesRequest, prepareReconnectToStreamRequest }){\n        this.api = api;\n        this.credentials = credentials;\n        this.headers = headers;\n        this.body = body;\n        this.fetch = fetch2;\n        this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n        this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n    }\n    async sendMessages({ abortSignal, ...options }) {\n        var _a17, _b, _c, _d, _e;\n        const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n        const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n        const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n        const baseHeaders = {\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n        };\n        const preparedRequest = await ((_a17 = this.prepareSendMessagesRequest) == null ? void 0 : _a17.call(this, {\n            api: this.api,\n            id: options.chatId,\n            messages: options.messages,\n            body: {\n                ...resolvedBody,\n                ...options.body\n            },\n            headers: baseHeaders,\n            credentials: resolvedCredentials,\n            requestMetadata: options.metadata,\n            trigger: options.trigger,\n            messageId: options.messageId\n        }));\n        const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n        const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n            ...resolvedBody,\n            ...options.body,\n            id: options.chatId,\n            messages: options.messages,\n            trigger: options.trigger,\n            messageId: options.messageId\n        };\n        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n        const response = await fetch2(api, {\n            method: \"POST\",\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({\n                \"Content-Type\": \"application/json\",\n                ...headers\n            }, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            body: JSON.stringify(body),\n            credentials,\n            signal: abortSignal\n        });\n        if (!response.ok) {\n            throw new Error((_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        return this.processResponseStream(response.body);\n    }\n    async reconnectToStream(options) {\n        var _a17, _b, _c, _d, _e;\n        const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n        const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n        const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n        const baseHeaders = {\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n        };\n        const preparedRequest = await ((_a17 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a17.call(this, {\n            api: this.api,\n            id: options.chatId,\n            body: {\n                ...resolvedBody,\n                ...options.body\n            },\n            headers: baseHeaders,\n            credentials: resolvedCredentials,\n            requestMetadata: options.metadata\n        }));\n        const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n        const response = await fetch2(api, {\n            method: \"GET\",\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            credentials\n        });\n        if (response.status === 204) {\n            return null;\n        }\n        if (!response.ok) {\n            throw new Error((_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        return this.processResponseStream(response.body);\n    }\n};\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n    constructor(options = {}){\n        super(options);\n    }\n    processResponseStream(stream) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream,\n            schema: uiMessageChunkSchema\n        }).pipeThrough(new TransformStream({\n            async transform (chunk, controller) {\n                if (!chunk.success) {\n                    throw chunk.error;\n                }\n                controller.enqueue(chunk.value);\n            }\n        }));\n    }\n};\n// src/ui/chat.ts\nvar AbstractChat = class {\n    constructor({ generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId, id = generateId2(), transport = new DefaultChatTransport(), messageMetadataSchema, dataPartSchemas, state, onError, onToolCall, onFinish, onData, sendAutomaticallyWhen }){\n        this.activeResponse = void 0;\n        this.jobExecutor = new SerialJobExecutor();\n        /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */ this.sendMessage = async (message, options)=>{\n            var _a17, _b, _c, _d;\n            if (message == null) {\n                await this.makeRequest({\n                    trigger: \"submit-message\",\n                    messageId: (_a17 = this.lastMessage) == null ? void 0 : _a17.id,\n                    ...options\n                });\n                return;\n            }\n            let uiMessage;\n            if (\"text\" in message || \"files\" in message) {\n                const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n                uiMessage = {\n                    parts: [\n                        ...fileParts,\n                        ...\"text\" in message && message.text != null ? [\n                            {\n                                type: \"text\",\n                                text: message.text\n                            }\n                        ] : []\n                    ]\n                };\n            } else {\n                uiMessage = message;\n            }\n            if (message.messageId != null) {\n                const messageIndex = this.state.messages.findIndex((m)=>m.id === message.messageId);\n                if (messageIndex === -1) {\n                    throw new Error(`message with id ${message.messageId} not found`);\n                }\n                if (this.state.messages[messageIndex].role !== \"user\") {\n                    throw new Error(`message with id ${message.messageId} is not a user message`);\n                }\n                this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n                this.state.replaceMessage(messageIndex, {\n                    ...uiMessage,\n                    id: message.messageId,\n                    role: (_b = uiMessage.role) != null ? _b : \"user\",\n                    metadata: message.metadata\n                });\n            } else {\n                this.state.pushMessage({\n                    ...uiMessage,\n                    id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n                    role: (_d = uiMessage.role) != null ? _d : \"user\",\n                    metadata: message.metadata\n                });\n            }\n            await this.makeRequest({\n                trigger: \"submit-message\",\n                messageId: message.messageId,\n                ...options\n            });\n        };\n        /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */ this.regenerate = async ({ messageId, ...options } = {})=>{\n            const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message)=>message.id === messageId);\n            if (messageIndex === -1) {\n                throw new Error(`message ${messageId} not found`);\n            }\n            this.state.messages = this.state.messages.slice(0, // if the message is a user message, we need to include it in the request:\n            this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1);\n            await this.makeRequest({\n                trigger: \"regenerate-message\",\n                messageId,\n                ...options\n            });\n        };\n        /**\n     * Attempt to resume an ongoing streaming response.\n     */ this.resumeStream = async (options = {})=>{\n            await this.makeRequest({\n                trigger: \"resume-stream\",\n                ...options\n            });\n        };\n        /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */ this.clearError = ()=>{\n            if (this.status === \"error\") {\n                this.state.error = void 0;\n                this.setStatus({\n                    status: \"ready\"\n                });\n            }\n        };\n        this.addToolApprovalResponse = async ({ id, approved, reason })=>this.jobExecutor.run(async ()=>{\n                var _a17, _b;\n                const messages = this.state.messages;\n                const lastMessage = messages[messages.length - 1];\n                const updatePart = (part)=>isToolUIPart(part) && part.state === \"approval-requested\" && part.approval.id === id ? {\n                        ...part,\n                        state: \"approval-responded\",\n                        approval: {\n                            id,\n                            approved,\n                            reason\n                        }\n                    } : part;\n                this.state.replaceMessage(messages.length - 1, {\n                    ...lastMessage,\n                    parts: lastMessage.parts.map(updatePart)\n                });\n                if (this.activeResponse) {\n                    this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n                }\n                if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, {\n                    messages: this.state.messages\n                }))) {\n                    this.makeRequest({\n                        trigger: \"submit-message\",\n                        messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n                    });\n                }\n            });\n        this.addToolOutput = async ({ state = \"output-available\", tool: tool2, toolCallId, output, errorText })=>this.jobExecutor.run(async ()=>{\n                var _a17, _b;\n                const messages = this.state.messages;\n                const lastMessage = messages[messages.length - 1];\n                const updatePart = (part)=>isToolUIPart(part) && part.toolCallId === toolCallId ? {\n                        ...part,\n                        state,\n                        output,\n                        errorText\n                    } : part;\n                this.state.replaceMessage(messages.length - 1, {\n                    ...lastMessage,\n                    parts: lastMessage.parts.map(updatePart)\n                });\n                if (this.activeResponse) {\n                    this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n                }\n                if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, {\n                    messages: this.state.messages\n                }))) {\n                    this.makeRequest({\n                        trigger: \"submit-message\",\n                        messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n                    });\n                }\n            });\n        /** @deprecated Use addToolOutput */ this.addToolResult = this.addToolOutput;\n        /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */ this.stop = async ()=>{\n            var _a17;\n            if (this.status !== \"streaming\" && this.status !== \"submitted\") return;\n            if ((_a17 = this.activeResponse) == null ? void 0 : _a17.abortController) {\n                this.activeResponse.abortController.abort();\n            }\n        };\n        this.id = id;\n        this.transport = transport;\n        this.generateId = generateId2;\n        this.messageMetadataSchema = messageMetadataSchema;\n        this.dataPartSchemas = dataPartSchemas;\n        this.state = state;\n        this.onError = onError;\n        this.onToolCall = onToolCall;\n        this.onFinish = onFinish;\n        this.onData = onData;\n        this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n    }\n    /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */ get status() {\n        return this.state.status;\n    }\n    setStatus({ status, error }) {\n        if (this.status === status) return;\n        this.state.status = status;\n        this.state.error = error;\n    }\n    get error() {\n        return this.state.error;\n    }\n    get messages() {\n        return this.state.messages;\n    }\n    get lastMessage() {\n        return this.state.messages[this.state.messages.length - 1];\n    }\n    set messages(messages) {\n        this.state.messages = messages;\n    }\n    async makeRequest({ trigger, metadata, headers, body, messageId }) {\n        var _a17, _b, _c, _d;\n        this.setStatus({\n            status: \"submitted\",\n            error: void 0\n        });\n        const lastMessage = this.lastMessage;\n        let isAbort = false;\n        let isDisconnect = false;\n        let isError = false;\n        try {\n            const activeResponse = {\n                state: createStreamingUIMessageState({\n                    lastMessage: this.state.snapshot(lastMessage),\n                    messageId: this.generateId()\n                }),\n                abortController: new AbortController()\n            };\n            activeResponse.abortController.signal.addEventListener(\"abort\", ()=>{\n                isAbort = true;\n            });\n            this.activeResponse = activeResponse;\n            let stream;\n            if (trigger === \"resume-stream\") {\n                const reconnect = await this.transport.reconnectToStream({\n                    chatId: this.id,\n                    metadata,\n                    headers,\n                    body\n                });\n                if (reconnect == null) {\n                    this.setStatus({\n                        status: \"ready\"\n                    });\n                    return;\n                }\n                stream = reconnect;\n            } else {\n                stream = await this.transport.sendMessages({\n                    chatId: this.id,\n                    messages: this.state.messages,\n                    abortSignal: activeResponse.abortController.signal,\n                    metadata,\n                    headers,\n                    body,\n                    trigger,\n                    messageId\n                });\n            }\n            const runUpdateMessageJob = (job)=>// serialize the job execution to avoid race conditions:\n                this.jobExecutor.run(()=>job({\n                        state: activeResponse.state,\n                        write: ()=>{\n                            var _a18;\n                            this.setStatus({\n                                status: \"streaming\"\n                            });\n                            const replaceLastMessage = activeResponse.state.message.id === ((_a18 = this.lastMessage) == null ? void 0 : _a18.id);\n                            if (replaceLastMessage) {\n                                this.state.replaceMessage(this.state.messages.length - 1, activeResponse.state.message);\n                            } else {\n                                this.state.pushMessage(activeResponse.state.message);\n                            }\n                        }\n                    }));\n            await consumeStream({\n                stream: processUIMessageStream({\n                    stream,\n                    onToolCall: this.onToolCall,\n                    onData: this.onData,\n                    messageMetadataSchema: this.messageMetadataSchema,\n                    dataPartSchemas: this.dataPartSchemas,\n                    runUpdateMessageJob,\n                    onError: (error)=>{\n                        throw error;\n                    }\n                }),\n                onError: (error)=>{\n                    throw error;\n                }\n            });\n            this.setStatus({\n                status: \"ready\"\n            });\n        } catch (err) {\n            if (isAbort || err.name === \"AbortError\") {\n                isAbort = true;\n                this.setStatus({\n                    status: \"ready\"\n                });\n                return null;\n            }\n            isError = true;\n            if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n                isDisconnect = true;\n            }\n            if (this.onError && err instanceof Error) {\n                this.onError(err);\n            }\n            this.setStatus({\n                status: \"error\",\n                error: err\n            });\n        } finally{\n            try {\n                (_b = this.onFinish) == null ? void 0 : _b.call(this, {\n                    message: this.activeResponse.state.message,\n                    messages: this.state.messages,\n                    isAbort,\n                    isDisconnect,\n                    isError,\n                    finishReason: (_a17 = this.activeResponse) == null ? void 0 : _a17.state.finishReason\n                });\n            } catch (err) {\n                console.error(err);\n            }\n            this.activeResponse = void 0;\n        }\n        if (((_c = this.sendAutomaticallyWhen) == null ? void 0 : _c.call(this, {\n            messages: this.state.messages\n        })) && !isError) {\n            await this.makeRequest({\n                trigger: \"submit-message\",\n                messageId: (_d = this.lastMessage) == null ? void 0 : _d.id,\n                metadata,\n                headers,\n                body\n            });\n        }\n    }\n};\n// src/ui/direct-chat-transport.ts\nvar DirectChatTransport = class {\n    constructor({ agent, options, ...uiMessageStreamOptions }){\n        this.agent = agent;\n        this.agentOptions = options;\n        this.uiMessageStreamOptions = uiMessageStreamOptions;\n    }\n    async sendMessages({ messages, abortSignal }) {\n        const validatedMessages = await validateUIMessages({\n            messages,\n            tools: this.agent.tools\n        });\n        const modelMessages = await convertToModelMessages(validatedMessages, {\n            tools: this.agent.tools\n        });\n        const result = await this.agent.stream({\n            prompt: modelMessages,\n            abortSignal,\n            ...this.agentOptions !== void 0 ? {\n                options: this.agentOptions\n            } : {}\n        });\n        return result.toUIMessageStream(this.uiMessageStreamOptions);\n    }\n    /**\n   * Direct transport does not support reconnection since there is no\n   * persistent server-side stream to reconnect to.\n   *\n   * @returns Always returns `null`\n   */ async reconnectToStream(_options) {\n        return null;\n    }\n};\n// src/ui/last-assistant-message-is-complete-with-approval-responses.ts\nfunction lastAssistantMessageIsCompleteWithApprovalResponses({ messages }) {\n    const message = messages[messages.length - 1];\n    if (!message) {\n        return false;\n    }\n    if (message.role !== \"assistant\") {\n        return false;\n    }\n    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{\n        return part.type === \"step-start\" ? index : lastIndex;\n    }, -1);\n    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part)=>!part.providerExecuted);\n    return(// has at least one tool approval response\n    lastStepToolInvocations.filter((part)=>part.state === \"approval-responded\").length > 0 && // all tool approvals must have a response\n    lastStepToolInvocations.every((part)=>part.state === \"output-available\" || part.state === \"output-error\" || part.state === \"approval-responded\"));\n}\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({ messages }) {\n    const message = messages[messages.length - 1];\n    if (!message) {\n        return false;\n    }\n    if (message.role !== \"assistant\") {\n        return false;\n    }\n    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{\n        return part.type === \"step-start\" ? index : lastIndex;\n    }, -1);\n    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part)=>!part.providerExecuted);\n    return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part)=>part.state === \"output-available\" || part.state === \"output-error\");\n}\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({ stream }) {\n    return stream.pipeThrough(new TransformStream({\n        start (controller) {\n            controller.enqueue({\n                type: \"start\"\n            });\n            controller.enqueue({\n                type: \"start-step\"\n            });\n            controller.enqueue({\n                type: \"text-start\",\n                id: \"text-1\"\n            });\n        },\n        async transform (part, controller) {\n            controller.enqueue({\n                type: \"text-delta\",\n                id: \"text-1\",\n                delta: part\n            });\n        },\n        async flush (controller) {\n            controller.enqueue({\n                type: \"text-end\",\n                id: \"text-1\"\n            });\n            controller.enqueue({\n                type: \"finish-step\"\n            });\n            controller.enqueue({\n                type: \"finish\"\n            });\n        }\n    }));\n}\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n    constructor(options = {}){\n        super(options);\n    }\n    processResponseStream(stream) {\n        return transformTextToUiMessageStream({\n            stream: stream.pipeThrough(new TextDecoderStream())\n        });\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFVBQVVELElBQ2pCTCxVQUFVSSxRQUFRRSxRQUFRO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsT0FBTztRQUFFRSxZQUFZO0lBQUs7QUFDbkU7QUFFQSxlQUFlO0FBQ3NEO0FBVXJDO0FBRWhDLHFDQUFxQztBQUtMO0FBRWhDLHFCQUFxQjtBQWVLO0FBRTFCLHNDQUFzQztBQUNRO0FBQzlDLElBQUlrQyxPQUFPO0FBQ1gsSUFBSUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFRCxLQUFLLENBQUM7QUFDdEMsSUFBSUUsU0FBU0MsT0FBT0MsR0FBRyxDQUFDSDtBQUN4QixJQUFJSTtBQUNKLElBQUlDLHVCQUF1QixjQUFjcEIsd0RBQVVBO0lBQ2pEcUIsWUFBWSxFQUNWQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsT0FBTyxFQUNSLENBQUU7UUFDRCxLQUFLLENBQUM7WUFDSlY7WUFDQVUsU0FBUyxDQUFDLCtCQUErQixFQUFFRixVQUFVLEVBQUUsRUFBRUUsUUFBUSxDQUFDO1FBQ3BFO1FBQ0EsSUFBSSxDQUFDTCxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNHLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2Y7SUFDQSxPQUFPRSxXQUFXQyxLQUFLLEVBQUU7UUFDdkIsT0FBTzFCLHdEQUFVQSxDQUFDMkIsU0FBUyxDQUFDRCxPQUFPWDtJQUNyQztBQUNGO0FBQ0FJLEtBQUtI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QSxPQUFPRSxXQUFXLENBQ3ZCLElBQUlDLGdCQUFnQjtRQUNsQm1zQixPQUFNanNCLFVBQVU7WUFDZEEsV0FBV0MsT0FBTyxDQUFDO2dCQUFFbEMsTUFBTTtZQUFRO1lBQ25DaUMsV0FBV0MsT0FBTyxDQUFDO2dCQUFFbEMsTUFBTTtZQUFhO1lBQ3hDaUMsV0FBV0MsT0FBTyxDQUFDO2dCQUFFbEMsTUFBTTtnQkFBY29OLElBQUk7WUFBUztRQUN4RDtRQUNBLE1BQU1wTCxXQUFVNEgsSUFBSSxFQUFFM0gsVUFBVTtZQUM5QkEsV0FBV0MsT0FBTyxDQUFDO2dCQUFFbEMsTUFBTTtnQkFBY29OLElBQUk7Z0JBQVVxYixPQUFPN2U7WUFBSztRQUNyRTtRQUNBLE1BQU00ZCxPQUFNdmxCLFVBQVU7WUFDcEJBLFdBQVdDLE9BQU8sQ0FBQztnQkFBRWxDLE1BQU07Z0JBQVlvTixJQUFJO1lBQVM7WUFDcERuTCxXQUFXQyxPQUFPLENBQUM7Z0JBQUVsQyxNQUFNO1lBQWM7WUFDekNpQyxXQUFXQyxPQUFPLENBQUM7Z0JBQUVsQyxNQUFNO1lBQVM7UUFDdEM7SUFDRjtBQUVKO0FBRUEsdUNBQXVDO0FBQ3ZDLElBQUlvMEMsMEJBQTBCLGNBQWNwRDtJQUMxQ2o1QyxZQUFZK0QsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN4QixLQUFLLENBQUNBO0lBQ1I7SUFDQTgxQyxzQkFBc0Jod0MsTUFBTSxFQUFFO1FBQzVCLE9BQU91eUMsK0JBQStCO1lBQ3BDdnlDLFFBQVFBLE9BQU9FLFdBQVcsQ0FBQyxJQUFJdXRDO1FBQ2pDO0lBQ0Y7QUFDRjtBQTBIRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Jzcy1haS1kaWdlc3QvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/ODFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxNyBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTE3LCB7IGdldDogYWxsW25hbWUxN10sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZUdhdGV3YXksIGdhdGV3YXkgYXMgZ2F0ZXdheTIgfSBmcm9tIFwiQGFpLXNkay9nYXRld2F5XCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTUsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNSxcbiAgZHluYW1pY1Rvb2wsXG4gIGdlbmVyYXRlSWQsXG4gIGpzb25TY2hlbWEsXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtIGFzIHBhcnNlSnNvbkV2ZW50U3RyZWFtMyxcbiAgdG9vbCxcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U1LFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXgyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9lcnJvci9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTgsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gc3JjL2Vycm9yL2ludmFsaWQtc3RyZWFtLXBhcnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9JbnZhbGlkU3RyZWFtUGFydEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVuayxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWFwcHJvdmFsLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZFRvb2xBcHByb3ZhbEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3IoeyBhcHByb3ZhbElkIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMyxcbiAgICAgIG1lc3NhZ2U6IGBUb29sIGFwcHJvdmFsIHJlc3BvbnNlIHJlZmVyZW5jZXMgdW5rbm93biBhcHByb3ZhbElkOiBcIiR7YXBwcm92YWxJZH1cIi4gTm8gbWF0Y2hpbmcgdG9vbC1hcHByb3ZhbC1yZXF1ZXN0IGZvdW5kIGluIG1lc3NhZ2UgaGlzdG9yeS5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLmFwcHJvdmFsSWQgPSBhcHByb3ZhbElkO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWlucHV0LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0LCBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkVG9vbElucHV0RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRUb29sSW5wdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbElucHV0LFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dCBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy50b29sSW5wdXQgPSB0b29sSW5wdXQ7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3IvdG9vbC1jYWxsLW5vdC1mb3VuZC1mb3ItYXBwcm92YWwtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU1ID0gXCJBSV9Ub29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I1IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xDYWxsSWQsXG4gICAgYXBwcm92YWxJZFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTUsXG4gICAgICBtZXNzYWdlOiBgVG9vbCBjYWxsIFwiJHt0b29sQ2FsbElkfVwiIG5vdCBmb3VuZCBmb3IgYXBwcm92YWwgcmVxdWVzdCBcIiR7YXBwcm92YWxJZH1cIi5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xDYWxsSWQgPSB0b29sQ2FsbElkO1xuICAgIHRoaXMuYXBwcm92YWxJZCA9IGFwcHJvdmFsSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvci9uby1pbWFnZS1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9Ob0ltYWdlR2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjYge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gaW1hZ2UgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHJlc3BvbnNlc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gc3JjL2Vycm9yL25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBvYmplY3QgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHRleHQ6IHRleHQyLFxuICAgIHJlc3BvbnNlLFxuICAgIHVzYWdlLFxuICAgIGZpbmlzaFJlYXNvblxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3Ivbm8tb3V0cHV0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX05vT3V0cHV0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIE5vT3V0cHV0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I4IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBvdXRwdXQgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIHNyYy9lcnJvci9uby1zcGVlY2gtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBOb1NwZWVjaEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vU3BlZWNoR2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gc3BlZWNoIGF1ZGlvIGdlbmVyYXRlZC5cIlxuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvci9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEwIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTm9TdWNoVG9vbEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sTmFtZSxcbiAgICBhdmFpbGFibGVUb29scyA9IHZvaWQgMCxcbiAgICBtZXNzYWdlID0gYE1vZGVsIHRyaWVkIHRvIGNhbGwgdW5hdmFpbGFibGUgdG9vbCAnJHt0b29sTmFtZX0nLiAke2F2YWlsYWJsZVRvb2xzID09PSB2b2lkIDAgPyBcIk5vIHRvb2xzIGFyZSBhdmFpbGFibGUuXCIgOiBgQXZhaWxhYmxlIHRvb2xzOiAke2F2YWlsYWJsZVRvb2xzLmpvaW4oXCIsIFwiKX0uYH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvci90b29sLWNhbGwtcmVwYWlyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMSwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMCA9IFwiQUlfVG9vbENhbGxSZXBhaXJFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBUb29sQ2FsbFJlcGFpckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTEge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2F1c2UsXG4gICAgb3JpZ2luYWxFcnJvcixcbiAgICBtZXNzYWdlID0gYEVycm9yIHJlcGFpcmluZyB0b29sIGNhbGw6ICR7Z2V0RXJyb3JNZXNzYWdlMihjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTAsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3IvdW5zdXBwb3J0ZWQtbW9kZWwtdmVyc2lvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX1Vuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCBtb2RlbCB2ZXJzaW9uICR7b3B0aW9ucy52ZXJzaW9ufSBmb3IgcHJvdmlkZXIgXCIke29wdGlvbnMucHJvdmlkZXJ9XCIgYW5kIG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIuIEFJIFNESyA1IG9ubHkgc3VwcG9ydHMgbW9kZWxzIHRoYXQgaW1wbGVtZW50IHNwZWNpZmljYXRpb24gdmVyc2lvbiBcInYyXCIuYFxuICAgIH0pO1xuICAgIHRoaXMudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLm1vZGVsSWQgPSBvcHRpb25zLm1vZGVsSWQ7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvci91aS1tZXNzYWdlLXN0cmVhbS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMSA9IFwiQUlfVUlNZXNzYWdlU3RyZWFtRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgVUlNZXNzYWdlU3RyZWFtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVua1R5cGUsXG4gICAgY2h1bmtJZCxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLmNodW5rVHlwZSA9IGNodW5rVHlwZTtcbiAgICB0aGlzLmNodW5rSWQgPSBjaHVua0lkO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMiA9IFwiQUlfSW52YWxpZERhdGFDb250ZW50RXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRhIGNvbnRlbnQuIEV4cGVjdGVkIGEgYmFzZTY0IHN0cmluZywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEJ1ZmZlciwgYnV0IGdvdCAke3R5cGVvZiBjb250ZW50fS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTMgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEzfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEzXSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE0ID0gXCJBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE0fWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0O1xudmFyIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2UsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTQsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvZXJyb3IvaW5kZXgudHNcbmltcG9ydCB7IERvd25sb2FkRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlcjE1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNX1gO1xudmFyIHN5bWJvbDE1ID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG52YXIgX2ExNTtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTVdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpO1xuICB9XG59O1xuX2ExNSA9IHN5bWJvbDE1O1xuXG4vLyBzcmMvbG9nZ2VyL2xvZy13YXJuaW5ncy50c1xuZnVuY3Rpb24gZm9ybWF0V2FybmluZyh7XG4gIHdhcm5pbmcsXG4gIHByb3ZpZGVyLFxuICBtb2RlbFxufSkge1xuICBjb25zdCBwcmVmaXggPSBgQUkgU0RLIFdhcm5pbmcgKCR7cHJvdmlkZXJ9IC8gJHttb2RlbH0pOmA7XG4gIHN3aXRjaCAod2FybmluZy50eXBlKSB7XG4gICAgY2FzZSBcInVuc3VwcG9ydGVkXCI6IHtcbiAgICAgIGxldCBtZXNzYWdlID0gYCR7cHJlZml4fSBUaGUgZmVhdHVyZSBcIiR7d2FybmluZy5mZWF0dXJlfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYDtcbiAgICAgIGlmICh3YXJuaW5nLmRldGFpbHMpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgICR7d2FybmluZy5kZXRhaWxzfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgY2FzZSBcImNvbXBhdGliaWxpdHlcIjoge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSBmZWF0dXJlIFwiJHt3YXJuaW5nLmZlYXR1cmV9XCIgaXMgdXNlZCBpbiBhIGNvbXBhdGliaWxpdHkgbW9kZS5gO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgJHt3YXJuaW5nLmRldGFpbHN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBjYXNlIFwib3RoZXJcIjoge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0gJHt3YXJuaW5nLm1lc3NhZ2V9YDtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0gJHtKU09OLnN0cmluZ2lmeSh3YXJuaW5nLCBudWxsLCAyKX1gO1xuICAgIH1cbiAgfVxufVxudmFyIEZJUlNUX1dBUk5JTkdfSU5GT19NRVNTQUdFID0gXCJBSSBTREsgV2FybmluZyBTeXN0ZW06IFRvIHR1cm4gb2ZmIHdhcm5pbmcgbG9nZ2luZywgc2V0IHRoZSBBSV9TREtfTE9HX1dBUk5JTkdTIGdsb2JhbCB0byBmYWxzZS5cIjtcbnZhciBoYXNMb2dnZWRCZWZvcmUgPSBmYWxzZTtcbnZhciBsb2dXYXJuaW5ncyA9IChvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLndhcm5pbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsb2dnZXIgPSBnbG9iYWxUaGlzLkFJX1NES19MT0dfV0FSTklOR1M7XG4gIGlmIChsb2dnZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgbG9nZ2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsb2dnZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaGFzTG9nZ2VkQmVmb3JlKSB7XG4gICAgaGFzTG9nZ2VkQmVmb3JlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmluZm8oRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UpO1xuICB9XG4gIGZvciAoY29uc3Qgd2FybmluZyBvZiBvcHRpb25zLndhcm5pbmdzKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgZm9ybWF0V2FybmluZyh7XG4gICAgICAgIHdhcm5pbmcsXG4gICAgICAgIHByb3ZpZGVyOiBvcHRpb25zLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbFxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbW9kZWwvcmVzb2x2ZS1tb2RlbC50c1xuaW1wb3J0IHsgZ2F0ZXdheSB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcblxuLy8gc3JjL3V0aWwvbG9nLXYyLWNvbXBhdGliaWxpdHktd2FybmluZy50c1xuZnVuY3Rpb24gbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gIHByb3ZpZGVyLFxuICBtb2RlbElkXG59KSB7XG4gIGxvZ1dhcm5pbmdzKHtcbiAgICB3YXJuaW5nczogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImNvbXBhdGliaWxpdHlcIixcbiAgICAgICAgZmVhdHVyZTogXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiLFxuICAgICAgICBkZXRhaWxzOiBgVXNpbmcgdjIgc3BlY2lmaWNhdGlvbiBjb21wYXRpYmlsaXR5IG1vZGUuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCBiZSBhdmFpbGFibGUuYFxuICAgICAgfVxuICAgIF0sXG4gICAgcHJvdmlkZXIsXG4gICAgbW9kZWw6IG1vZGVsSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1lbWJlZGRpbmctbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzRW1iZWRkaW5nTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1pbWFnZS1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNJbWFnZU1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiKVxuICAgICAgICByZXR1cm4gXCJ2M1wiO1xuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtbGFuZ3VhZ2UtbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzTGFuZ3VhZ2VNb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiOlxuICAgICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICAgIGNhc2UgXCJkb0dlbmVyYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuZG9HZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjb252ZXJ0VjJGaW5pc2hSZWFzb25Ub1YzKHJlc3VsdC5maW5pc2hSZWFzb24pLFxuICAgICAgICAgICAgICB1c2FnZTogY29udmVydFYyVXNhZ2VUb1YzKHJlc3VsdC51c2FnZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImRvU3RyZWFtXCI6XG4gICAgICAgICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuZG9TdHJlYW0oLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHN0cmVhbTogY29udmVydFYyU3RyZWFtVG9WMyhyZXN1bHQuc3RyZWFtKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWMlN0cmVhbVRvVjMoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udmVydFYyRmluaXNoUmVhc29uVG9WMyhjaHVuay5maW5pc2hSZWFzb24pLFxuICAgICAgICAgICAgICB1c2FnZTogY29udmVydFYyVXNhZ2VUb1YzKGNodW5rLnVzYWdlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWMkZpbmlzaFJlYXNvblRvVjMoZmluaXNoUmVhc29uKSB7XG4gIHJldHVybiB7XG4gICAgdW5pZmllZDogZmluaXNoUmVhc29uID09PSBcInVua25vd25cIiA/IFwib3RoZXJcIiA6IGZpbmlzaFJlYXNvbixcbiAgICByYXc6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFYyVXNhZ2VUb1YzKHVzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IHtcbiAgICAgIHRvdGFsOiB1c2FnZS5pbnB1dFRva2VucyxcbiAgICAgIG5vQ2FjaGU6IHZvaWQgMCxcbiAgICAgIGNhY2hlUmVhZDogdXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICBjYWNoZVdyaXRlOiB2b2lkIDBcbiAgICB9LFxuICAgIG91dHB1dFRva2Vuczoge1xuICAgICAgdG90YWw6IHVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgIHJlYXNvbmluZzogdXNhZ2UucmVhc29uaW5nVG9rZW5zXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtc3BlZWNoLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc1NwZWVjaE1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiKVxuICAgICAgICByZXR1cm4gXCJ2M1wiO1xuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbW9kZWwvYXMtdHJhbnNjcmlwdGlvbi1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9yZXNvbHZlLW1vZGVsLnRzXG5mdW5jdGlvbiByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzTGFuZ3VhZ2VNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gZ2V0R2xvYmFsUHJvdmlkZXIoKS5sYW5ndWFnZU1vZGVsKG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzRW1iZWRkaW5nTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIGdldEdsb2JhbFByb3ZpZGVyKCkuZW1iZWRkaW5nTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbCkge1xuICB2YXIgX2ExNywgX2I7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIChfYiA9IChfYTE3ID0gZ2V0R2xvYmFsUHJvdmlkZXIoKSkudHJhbnNjcmlwdGlvbk1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTE3LCBtb2RlbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlU3BlZWNoTW9kZWwobW9kZWwpIHtcbiAgdmFyIF9hMTcsIF9iO1xuICBpZiAodHlwZW9mIG1vZGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIgJiYgbW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWRNb2RlbCA9IG1vZGVsO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiB1bnN1cHBvcnRlZE1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgICBwcm92aWRlcjogdW5zdXBwb3J0ZWRNb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzU3BlZWNoTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIChfYiA9IChfYTE3ID0gZ2V0R2xvYmFsUHJvdmlkZXIoKSkuc3BlZWNoTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMTcsIG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVJbWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNJbWFnZU1vZGVsVjMobW9kZWwpO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmltYWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsUHJvdmlkZXIoKSB7XG4gIHZhciBfYTE3O1xuICByZXR1cm4gKF9hMTcgPSBnbG9iYWxUaGlzLkFJX1NES19ERUZBVUxUX1BST1ZJREVSKSAhPSBudWxsID8gX2ExNyA6IGdhdGV3YXk7XG59XG5cbi8vIHNyYy9wcm9tcHQvY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gZ2V0VG90YWxUaW1lb3V0TXModGltZW91dCkge1xuICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGltZW91dDtcbiAgfVxuICByZXR1cm4gdGltZW91dC50b3RhbE1zO1xufVxuZnVuY3Rpb24gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0ID09IG51bGwgfHwgdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB0aW1lb3V0LnN0ZXBNcztcbn1cbmZ1bmN0aW9uIGdldENodW5rVGltZW91dE1zKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQgPT0gbnVsbCB8fCB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXQuY2h1bmtNcztcbn1cblxuLy8gc3JjL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuaW1wb3J0IHtcbiAgaXNVcmxTdXBwb3J0ZWRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvZGV0ZWN0LW1lZGlhLXR5cGUudHNcbmltcG9ydCB7IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9naWZcIixcbiAgICBieXRlc1ByZWZpeDogWzcxLCA3MywgNzBdXG4gICAgLy8gR0lGXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdXG4gICAgLy8gUE5HXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvanBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMTZdXG4gICAgLy8gSlBFR1xuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3dlYnBcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgODIsXG4gICAgICA3MyxcbiAgICAgIDcwLFxuICAgICAgNzAsXG4gICAgICAvLyBcIlJJRkZcIlxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZpbGUgc2l6ZSAodmFyaWFibGUpXG4gICAgICA4NyxcbiAgICAgIDY5LFxuICAgICAgNjYsXG4gICAgICA4MFxuICAgICAgLy8gXCJXRUJQXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvYm1wXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs2NiwgNzddXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzMsIDczLCA0MiwgMF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3NywgNzcsIDAsIDQyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9oZWljXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgMTA0LFxuICAgICAgMTAxLFxuICAgICAgMTA1LFxuICAgICAgOTlcbiAgICBdXG4gIH1cbl07XG52YXIgYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUxXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUwXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjQzXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjQyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI3XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI2XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL3dhdlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICA4MixcbiAgICAgIC8vIFJcbiAgICAgIDczLFxuICAgICAgLy8gSVxuICAgICAgNzAsXG4gICAgICAvLyBGXG4gICAgICA3MCxcbiAgICAgIC8vIEZcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICA4NyxcbiAgICAgIC8vIFdcbiAgICAgIDY1LFxuICAgICAgLy8gQVxuICAgICAgODYsXG4gICAgICAvLyBWXG4gICAgICA2OVxuICAgICAgLy8gRVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9vZ2dcIixcbiAgICBieXRlc1ByZWZpeDogWzc5LCAxMDMsIDEwMywgODNdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vZmxhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCA3NiwgOTcsIDY3XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL2FhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjQsIDIxLCAwLCAwXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCAxMTYsIDEyMSwgMTEyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL3dlYm1cIixcbiAgICBieXRlc1ByZWZpeDogWzI2LCA2OSwgMjIzLCAxNjNdXG4gIH1cbl07XG52YXIgc3RyaXBJRDMgPSAoZGF0YSkgPT4ge1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydEJhc2U2NFRvVWludDhBcnJheShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IGlkM1NpemUgPSAoYnl0ZXNbNl0gJiAxMjcpIDw8IDIxIHwgKGJ5dGVzWzddICYgMTI3KSA8PCAxNCB8IChieXRlc1s4XSAmIDEyNykgPDwgNyB8IGJ5dGVzWzldICYgMTI3O1xuICByZXR1cm4gYnl0ZXMuc2xpY2UoaWQzU2l6ZSArIDEwKTtcbn07XG5mdW5jdGlvbiBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSkge1xuICBjb25zdCBoYXNJZDMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJTVVF6XCIpIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICYmIGRhdGEubGVuZ3RoID4gMTAgJiYgZGF0YVswXSA9PT0gNzMgJiYgLy8gJ0knXG4gIGRhdGFbMV0gPT09IDY4ICYmIC8vICdEJ1xuICBkYXRhWzJdID09PSA1MTtcbiAgcmV0dXJuIGhhc0lkMyA/IHN0cmlwSUQzKGRhdGEpIDogZGF0YTtcbn1cbmZ1bmN0aW9uIGRldGVjdE1lZGlhVHlwZSh7XG4gIGRhdGEsXG4gIHNpZ25hdHVyZXNcbn0pIHtcbiAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKTtcbiAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgcHJvY2Vzc2VkRGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoXG4gICAgcHJvY2Vzc2VkRGF0YS5zdWJzdHJpbmcoMCwgTWF0aC5taW4ocHJvY2Vzc2VkRGF0YS5sZW5ndGgsIDI0KSlcbiAgKSA6IHByb2Nlc3NlZERhdGE7XG4gIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHNpZ25hdHVyZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID49IHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5sZW5ndGggJiYgc2lnbmF0dXJlLmJ5dGVzUHJlZml4LmV2ZXJ5KFxuICAgICAgKGJ5dGUsIGluZGV4KSA9PiBieXRlID09PSBudWxsIHx8IGJ5dGVzW2luZGV4XSA9PT0gYnl0ZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC9kb3dubG9hZC50c1xuaW1wb3J0IHsgRG93bmxvYWRFcnJvciBhcyBEb3dubG9hZEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQge1xuICB3aXRoVXNlckFnZW50U3VmZml4LFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gdHJ1ZSA/IFwiNi4wLjQyXCIgOiBcIjAuMC4wLXRlc3RcIjtcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQvZG93bmxvYWQudHNcbnZhciBkb3dubG9hZCA9IGFzeW5jICh7IHVybCB9KSA9PiB7XG4gIHZhciBfYTE3O1xuICBjb25zdCB1cmxUZXh0ID0gdXJsLnRvU3RyaW5nKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmxUZXh0LCB7XG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4KFxuICAgICAgICB7fSxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50KClcbiAgICAgIClcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcjIoe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9hMTcgOiB2b2lkIDBcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChEb3dubG9hZEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yMih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC9kb3dubG9hZC1mdW5jdGlvbi50c1xudmFyIGNyZWF0ZURlZmF1bHREb3dubG9hZEZ1bmN0aW9uID0gKGRvd25sb2FkMiA9IGRvd25sb2FkKSA9PiAocmVxdWVzdGVkRG93bmxvYWRzKSA9PiBQcm9taXNlLmFsbChcbiAgcmVxdWVzdGVkRG93bmxvYWRzLm1hcChcbiAgICBhc3luYyAocmVxdWVzdGVkRG93bmxvYWQpID0+IHJlcXVlc3RlZERvd25sb2FkLmlzVXJsU3VwcG9ydGVkQnlNb2RlbCA/IG51bGwgOiBkb3dubG9hZDIocmVxdWVzdGVkRG93bmxvYWQpXG4gIClcbik7XG5cbi8vIHNyYy9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyLFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvcHJvbXB0L3NwbGl0LWRhdGEtdXJsLnRzXG5mdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiB2b2lkIDAsXG4gICAgICBiYXNlNjRDb250ZW50OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG52YXIgZGF0YUNvbnRlbnRTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5zdHJpbmcoKSxcbiAgei5pbnN0YW5jZW9mKFVpbnQ4QXJyYXkpLFxuICB6Lmluc3RhbmNlb2YoQXJyYXlCdWZmZXIpLFxuICB6LmN1c3RvbShcbiAgICAvLyBCdWZmZXIgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGVudmlyb25tZW50cyBzdWNoIGFzIENsb3VkRmxhcmU6XG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hMTcgPSBnbG9iYWxUaGlzLkJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuaXNCdWZmZXIodmFsdWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIHsgbWVzc2FnZTogXCJNdXN0IGJlIGEgQnVmZmVyXCIgfVxuICApXG5dKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWM0RhdGFDb250ZW50KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHsgZGF0YTogY29udGVudCwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgZGF0YTogbmV3IFVpbnQ4QXJyYXkoY29udGVudCksIG1lZGlhVHlwZTogdm9pZCAwIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnQgPSBuZXcgVVJMKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMICYmIGNvbnRlbnQucHJvdG9jb2wgPT09IFwiZGF0YTpcIikge1xuICAgIGNvbnN0IHsgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoXG4gICAgICBjb250ZW50LnRvU3RyaW5nKClcbiAgICApO1xuICAgIGlmIChkYXRhVXJsTWVkaWFUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQUlTREtFcnJvcjE5KHtcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gY29udGVudCAke2NvbnRlbnQudG9TdHJpbmcoKX1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogYmFzZTY0Q29udGVudCwgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlIH07XG4gIH1cbiAgcmV0dXJuIHsgZGF0YTogY29udGVudCwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KG5ldyBVaW50OEFycmF5KGNvbnRlbnQpKTtcbiAgfVxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheTIoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8vIHNyYy91dGlsL2FzLWFycmF5LnRzXG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLy8gc3JjL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgc3VwcG9ydGVkVXJscyxcbiAgZG93bmxvYWQ6IGRvd25sb2FkMiA9IGNyZWF0ZURlZmF1bHREb3dubG9hZEZ1bmN0aW9uKClcbn0pIHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZDIsXG4gICAgc3VwcG9ydGVkVXJsc1xuICApO1xuICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyB0eXBlb2YgcHJvbXB0LnN5c3RlbSA9PT0gXCJzdHJpbmdcIiA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBhc0FycmF5KHByb21wdC5zeXN0ZW0pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgfSkpIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSh7IG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMgfSlcbiAgICApXG4gIF07XG4gIGNvbnN0IGNvbWJpbmVkTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgIGNvbWJpbmVkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q29tYmluZWRNZXNzYWdlID0gY29tYmluZWRNZXNzYWdlcy5hdCgtMSk7XG4gICAgaWYgKChsYXN0Q29tYmluZWRNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0Q29tYmluZWRNZXNzYWdlLnJvbGUpID09PSBcInRvb2xcIikge1xuICAgICAgbGFzdENvbWJpbmVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4ubWVzc2FnZS5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYmluZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tYmluZWRNZXNzYWdlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHtcbiAgbWVzc2FnZSxcbiAgZG93bmxvYWRlZEFzc2V0c1xufSkge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCIpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHMgKG5vIHRleHQsIGFuZCBubyBwcm92aWRlciBvcHRpb25zKTpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCIgfHwgcGFydC5wcm92aWRlck9wdGlvbnMgIT0gbnVsbFxuICAgICAgICApLmZpbHRlcihcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gcGFydC5wcm92aWRlck9wdGlvbnM7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBtZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWM0RhdGFDb250ZW50KFxuICAgICAgICAgICAgICAgIHBhcnQuZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIG91dHB1dDogbWFwVG9vbFJlc3VsdE91dHB1dChwYXJ0Lm91dHB1dCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gT25seSBpbmNsdWRlIHRvb2wtYXBwcm92YWwtcmVzcG9uc2UgZm9yIHByb3ZpZGVyLWV4ZWN1dGVkIHRvb2xzXG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIgfHwgcGFydC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IG1hcFRvb2xSZXN1bHRPdXRwdXQocGFydC5vdXRwdXQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHBhcnQuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBwYXJ0LnJlYXNvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQXNzZXRzKG1lc3NhZ2VzLCBkb3dubG9hZDIsIHN1cHBvcnRlZFVybHMpIHtcbiAgY29uc3QgcGxhbm5lZERvd25sb2FkcyA9IG1lc3NhZ2VzLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5yb2xlID09PSBcInVzZXJcIikubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQpLmZpbHRlcihcbiAgICAoY29udGVudCkgPT4gQXJyYXkuaXNBcnJheShjb250ZW50KVxuICApLmZsYXQoKS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJmaWxlXCJcbiAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBtZWRpYVR5cGUgPSAoX2ExNyA9IHBhcnQubWVkaWFUeXBlKSAhPSBudWxsID8gX2ExNyA6IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiID8gXCJpbWFnZS8qXCIgOiB2b2lkIDA7XG4gICAgbGV0IGRhdGEgPSBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IHBhcnQuaW1hZ2UgOiBwYXJ0LmRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gbmV3IFVSTChkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWVkaWFUeXBlLCBkYXRhIH07XG4gIH0pLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC5kYXRhIGluc3RhbmNlb2YgVVJMXG4gICkubWFwKChwYXJ0KSA9PiAoe1xuICAgIHVybDogcGFydC5kYXRhLFxuICAgIGlzVXJsU3VwcG9ydGVkQnlNb2RlbDogcGFydC5tZWRpYVR5cGUgIT0gbnVsbCAmJiBpc1VybFN1cHBvcnRlZCh7XG4gICAgICB1cmw6IHBhcnQuZGF0YS50b1N0cmluZygpLFxuICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgIHN1cHBvcnRlZFVybHNcbiAgICB9KVxuICB9KSk7XG4gIGNvbnN0IGRvd25sb2FkZWRGaWxlcyA9IGF3YWl0IGRvd25sb2FkMihwbGFubmVkRG93bmxvYWRzKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb3dubG9hZGVkRmlsZXMubWFwKFxuICAgICAgKGZpbGUsIGluZGV4KSA9PiBmaWxlID09IG51bGwgPyBudWxsIDogW1xuICAgICAgICBwbGFubmVkRG93bmxvYWRzW2luZGV4XS51cmwudG9TdHJpbmcoKSxcbiAgICAgICAgeyBkYXRhOiBmaWxlLmRhdGEsIG1lZGlhVHlwZTogZmlsZS5tZWRpYVR5cGUgfVxuICAgICAgXVxuICAgICkuZmlsdGVyKChmaWxlKSA9PiBmaWxlICE9IG51bGwpXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykge1xuICB2YXIgX2ExNztcbiAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgfTtcbiAgfVxuICBsZXQgb3JpZ2luYWxEYXRhO1xuICBjb25zdCB0eXBlID0gcGFydC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuaW1hZ2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgb3JpZ2luYWxEYXRhID0gcGFydC5kYXRhO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgY29uc3QgeyBkYXRhOiBjb252ZXJ0ZWREYXRhLCBtZWRpYVR5cGU6IGNvbnZlcnRlZE1lZGlhVHlwZSB9ID0gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYzRGF0YUNvbnRlbnQob3JpZ2luYWxEYXRhKTtcbiAgbGV0IG1lZGlhVHlwZSA9IGNvbnZlcnRlZE1lZGlhVHlwZSAhPSBudWxsID8gY29udmVydGVkTWVkaWFUeXBlIDogcGFydC5tZWRpYVR5cGU7XG4gIGxldCBkYXRhID0gY29udmVydGVkRGF0YTtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGRvd25sb2FkZWRBc3NldHNbZGF0YS50b1N0cmluZygpXTtcbiAgICBpZiAoZG93bmxvYWRlZEZpbGUpIHtcbiAgICAgIGRhdGEgPSBkb3dubG9hZGVkRmlsZS5kYXRhO1xuICAgICAgbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBtZWRpYVR5cGUgPSBkb3dubG9hZGVkRmlsZS5tZWRpYVR5cGU7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gKF9hMTcgPSBkZXRlY3RNZWRpYVR5cGUoeyBkYXRhLCBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgfSkpICE9IG51bGwgPyBfYTE3IDogbWVkaWFUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBcImltYWdlLypcIixcbiAgICAgICAgLy8gYW55IGltYWdlXG4gICAgICAgIGZpbGVuYW1lOiB2b2lkIDAsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgIGlmIChtZWRpYVR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lZGlhIHR5cGUgaXMgbWlzc2luZyBmb3IgZmlsZSBwYXJ0YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgbWVkaWFUeXBlLFxuICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcFRvb2xSZXN1bHRPdXRwdXQob3V0cHV0KSB7XG4gIGlmIChvdXRwdXQudHlwZSAhPT0gXCJjb250ZW50XCIpIHtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IG91dHB1dC52YWx1ZS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnR5cGUgIT09IFwibWVkaWFcIikge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLm1lZGlhVHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJpbWFnZS1kYXRhXCIsXG4gICAgICAgICAgZGF0YTogaXRlbS5kYXRhLFxuICAgICAgICAgIG1lZGlhVHlwZTogaXRlbS5tZWRpYVR5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZS1kYXRhXCIsXG4gICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgbWVkaWFUeXBlOiBpdGVtLm1lZGlhVHlwZVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvcHJvbXB0L2NyZWF0ZS10b29sLW1vZGVsLW91dHB1dC50c1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgdG9vbENhbGxJZCxcbiAgaW5wdXQsXG4gIG91dHB1dCxcbiAgdG9vbDogdG9vbDIsXG4gIGVycm9yTW9kZVxufSkge1xuICBpZiAoZXJyb3JNb2RlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3ItdGV4dFwiLCB2YWx1ZTogZ2V0RXJyb3JNZXNzYWdlMyhvdXRwdXQpIH07XG4gIH0gZWxzZSBpZiAoZXJyb3JNb2RlID09PSBcImpzb25cIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3ItanNvblwiLCB2YWx1ZTogdG9KU09OVmFsdWUob3V0cHV0KSB9O1xuICB9XG4gIGlmICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudG9Nb2RlbE91dHB1dCkge1xuICAgIHJldHVybiBhd2FpdCB0b29sMi50b01vZGVsT3V0cHV0KHsgdG9vbENhbGxJZCwgaW5wdXQsIG91dHB1dCB9KTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBvdXRwdXQgfSA6IHsgdHlwZTogXCJqc29uXCIsIHZhbHVlOiB0b0pTT05WYWx1ZShvdXRwdXQpIH07XG59XG5mdW5jdGlvbiB0b0pTT05WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IG51bGwgOiB2YWx1ZTtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhPdXRwdXRUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICB0b3BLLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHNlZWQsXG4gIHN0b3BTZXF1ZW5jZXNcbn0pIHtcbiAgaWYgKG1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heE91dHB1dFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4T3V0cHV0VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heE91dHB1dFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heE91dHB1dFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcEsgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BLXCIsXG4gICAgICAgIHZhbHVlOiB0b3BLLFxuICAgICAgICBtZXNzYWdlOiBcInRvcEsgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICB0b3BLLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHN0b3BTZXF1ZW5jZXMsXG4gICAgc2VlZFxuICB9O1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QudHNcbmZ1bmN0aW9uIGlzTm9uRW1wdHlPYmplY3Qob2JqZWN0Mikge1xuICByZXR1cm4gb2JqZWN0MiAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdDIpLmxlbmd0aCA+IDA7XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTddKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTcpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxUb29scyA9IFtdO1xuICBmb3IgKGNvbnN0IFtuYW1lMTcsIHRvb2wyXSBvZiBmaWx0ZXJlZFRvb2xzKSB7XG4gICAgY29uc3QgdG9vbFR5cGUgPSB0b29sMi50eXBlO1xuICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgY2FzZSBcImR5bmFtaWNcIjpcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBsYW5ndWFnZU1vZGVsVG9vbHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IGF3YWl0IGFzU2NoZW1hKHRvb2wyLmlucHV0U2NoZW1hKS5qc29uU2NoZW1hLFxuICAgICAgICAgIC4uLnRvb2wyLmlucHV0RXhhbXBsZXMgIT0gbnVsbCA/IHsgaW5wdXRFeGFtcGxlczogdG9vbDIuaW5wdXRFeGFtcGxlcyB9IDoge30sXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0b29sMi5wcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgLi4udG9vbDIuc3RyaWN0ICE9IG51bGwgPyB7IHN0cmljdDogdG9vbDIuc3RyaWN0IH0gOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJvdmlkZXJcIjpcbiAgICAgICAgbGFuZ3VhZ2VNb2RlbFRvb2xzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXJcIixcbiAgICAgICAgICBuYW1lOiBuYW1lMTcsXG4gICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgIGFyZ3M6IHRvb2wyLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b29sIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRvb2xzOiBsYW5ndWFnZU1vZGVsVG9vbHMsXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIHNhZmVWYWxpZGF0ZVR5cGVzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvcHJvbXB0L21lc3NhZ2UudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xuaW1wb3J0IHsgeiBhcyB6MyB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEub3B0aW9uYWwoKSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG52YXIgcHJvdmlkZXJNZXRhZGF0YVNjaGVtYSA9IHozLnJlY29yZChcbiAgejMuc3RyaW5nKCksXG4gIHozLnJlY29yZCh6My5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hLm9wdGlvbmFsKCkpXG4pO1xuXG4vLyBzcmMvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xuaW1wb3J0IHsgeiBhcyB6NCB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGltYWdlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgaW1hZ2U6IHo0LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejQuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1lZGlhVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo0LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejQuaW5zdGFuY2VvZihVUkwpXSksXG4gIGZpbGVuYW1lOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgcmVhc29uaW5nUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gIHRleHQ6IHo0LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejQuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NC5zdHJpbmcoKSxcbiAgaW5wdXQ6IHo0LnVua25vd24oKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyRXhlY3V0ZWQ6IHo0LmJvb2xlYW4oKS5vcHRpb25hbCgpXG59KTtcbnZhciBvdXRwdXRTY2hlbWEgPSB6NC5kaXNjcmltaW5hdGVkVW5pb24oXG4gIFwidHlwZVwiLFxuICBbXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICAgICAgdmFsdWU6IHo0LnN0cmluZygpLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImpzb25cIiksXG4gICAgICB2YWx1ZToganNvblZhbHVlU2NoZW1hLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImV4ZWN1dGlvbi1kZW5pZWRcIiksXG4gICAgICByZWFzb246IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZXJyb3ItdGV4dFwiKSxcbiAgICAgIHZhbHVlOiB6NC5zdHJpbmcoKSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJlcnJvci1qc29uXCIpLFxuICAgICAgdmFsdWU6IGpzb25WYWx1ZVNjaGVtYSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJjb250ZW50XCIpLFxuICAgICAgdmFsdWU6IHo0LmFycmF5KFxuICAgICAgICB6NC51bmlvbihbXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICAgICAgICAgICAgdGV4dDogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwibWVkaWFcIiksXG4gICAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImZpbGUtZGF0YVwiKSxcbiAgICAgICAgICAgIGRhdGE6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImZpbGUtdXJsXCIpLFxuICAgICAgICAgICAgdXJsOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlLWlkXCIpLFxuICAgICAgICAgICAgZmlsZUlkOiB6NC51bmlvbihbejQuc3RyaW5nKCksIHo0LnJlY29yZCh6NC5zdHJpbmcoKSwgejQuc3RyaW5nKCkpXSksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2UtZGF0YVwiKSxcbiAgICAgICAgICAgIGRhdGE6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZS11cmxcIiksXG4gICAgICAgICAgICB1cmw6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlLWZpbGUtaWRcIiksXG4gICAgICAgICAgICBmaWxlSWQ6IHo0LnVuaW9uKFt6NC5zdHJpbmcoKSwgejQucmVjb3JkKHo0LnN0cmluZygpLCB6NC5zdHJpbmcoKSldKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJjdXN0b21cIiksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgfSlcbiAgXVxuKTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejQuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NC5zdHJpbmcoKSxcbiAgb3V0cHV0OiBvdXRwdXRTY2hlbWEsXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sQXBwcm92YWxSZXF1ZXN0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSxcbiAgYXBwcm92YWxJZDogejQuc3RyaW5nKCksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpXG59KTtcbnZhciB0b29sQXBwcm92YWxSZXNwb25zZVNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIpLFxuICBhcHByb3ZhbElkOiB6NC5zdHJpbmcoKSxcbiAgYXBwcm92ZWQ6IHo0LmJvb2xlYW4oKSxcbiAgcmVhc29uOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KFxuICB7XG4gICAgcm9sZTogejUubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgICBjb250ZW50OiB6NS5zdHJpbmcoKSxcbiAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9XG4pO1xudmFyIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwidXNlclwiKSxcbiAgY29udGVudDogejUudW5pb24oW1xuICAgIHo1LnN0cmluZygpLFxuICAgIHo1LmFycmF5KHo1LnVuaW9uKFt0ZXh0UGFydFNjaGVtYSwgaW1hZ2VQYXJ0U2NoZW1hLCBmaWxlUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo1LnVuaW9uKFtcbiAgICB6NS5zdHJpbmcoKSxcbiAgICB6NS5hcnJheShcbiAgICAgIHo1LnVuaW9uKFtcbiAgICAgICAgdGV4dFBhcnRTY2hlbWEsXG4gICAgICAgIGZpbGVQYXJ0U2NoZW1hLFxuICAgICAgICByZWFzb25pbmdQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sQ2FsbFBhcnRTY2hlbWEsXG4gICAgICAgIHRvb2xSZXN1bHRQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sQXBwcm92YWxSZXF1ZXN0U2NoZW1hXG4gICAgICBdKVxuICAgIClcbiAgXSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sTW9kZWxNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo1LmFycmF5KHo1LnVuaW9uKFt0b29sUmVzdWx0UGFydFNjaGVtYSwgdG9vbEFwcHJvdmFsUmVzcG9uc2VTY2hlbWFdKSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBtb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS51bmlvbihbXG4gIHN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgYXNzaXN0YW50TW9kZWxNZXNzYWdlU2NoZW1hLFxuICB0b29sTW9kZWxNZXNzYWdlU2NoZW1hXG5dKTtcblxuLy8gc3JjL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIHN0YW5kYXJkaXplUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIgJiYgIWFzQXJyYXkocHJvbXB0LnN5c3RlbSkuZXZlcnkoXG4gICAgKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJyb2xlXCIgaW4gbWVzc2FnZSAmJiBtZXNzYWdlLnJvbGUgPT09IFwic3lzdGVtXCJcbiAgKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmcsIFN5c3RlbU1vZGVsTWVzc2FnZSwgb3IgYXJyYXkgb2YgU3lzdGVtTW9kZWxNZXNzYWdlXCJcbiAgICB9KTtcbiAgfVxuICBsZXQgbWVzc2FnZXM7XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5wcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBtZXNzYWdlcyA9IFt7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBwcm9tcHQucHJvbXB0IH1dO1xuICB9IGVsc2UgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHByb21wdC5wcm9tcHQpKSB7XG4gICAgbWVzc2FnZXMgPSBwcm9tcHQucHJvbXB0O1xuICB9IGVsc2UgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgbWVzc2FnZXMgPSBwcm9tcHQubWVzc2FnZXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkXCJcbiAgICB9KTtcbiAgfVxuICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IG5vdCBiZSBlbXB0eVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICB2YWx1ZTogbWVzc2FnZXMsXG4gICAgc2NoZW1hOiB6Ni5hcnJheShtb2RlbE1lc3NhZ2VTY2hlbWEpXG4gIH0pO1xuICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwiVGhlIG1lc3NhZ2VzIGRvIG5vdCBtYXRjaCB0aGUgTW9kZWxNZXNzYWdlW10gc2NoZW1hLlwiLFxuICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzLFxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9O1xufVxuXG4vLyBzcmMvcHJvbXB0L3dyYXAtZ2F0ZXdheS1lcnJvci50c1xuaW1wb3J0IHsgR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9nYXRld2F5XCI7XG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiB3cmFwR2F0ZXdheUVycm9yKGVycm9yKSB7XG4gIGlmICghR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpXG4gICAgcmV0dXJuIGVycm9yO1xuICBjb25zdCBpc1Byb2R1Y3Rpb25FbnYgPSAocHJvY2VzcyA9PSBudWxsID8gdm9pZCAwIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYpID09PSBcInByb2R1Y3Rpb25cIjtcbiAgY29uc3QgbW9yZUluZm9VUkwgPSBcImh0dHBzOi8vYWktc2RrLmRldi91bmF1dGhlbnRpY2F0ZWQtYWktZ2F0ZXdheVwiO1xuICBpZiAoaXNQcm9kdWN0aW9uRW52KSB7XG4gICAgcmV0dXJuIG5ldyBBSVNES0Vycm9yMjAoe1xuICAgICAgbmFtZTogXCJHYXRld2F5RXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IGBVbmF1dGhlbnRpY2F0ZWQuIENvbmZpZ3VyZSBBSV9HQVRFV0FZX0FQSV9LRVkgb3IgdXNlIGEgcHJvdmlkZXIgbW9kdWxlLiBMZWFybiBtb3JlOiAke21vcmVJbmZvVVJMfWBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICBuZXcgRXJyb3IoYFxceDFCWzFtXFx4MUJbMzFtVW5hdXRoZW50aWNhdGVkIHJlcXVlc3QgdG8gQUkgR2F0ZXdheS5cXHgxQlswbVxuXG5UbyBhdXRoZW50aWNhdGUsIHNldCB0aGUgXFx4MUJbMzNtQUlfR0FURVdBWV9BUElfS0VZXFx4MUJbMG0gZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCB5b3VyIEFQSSBrZXkuXG5cbkFsdGVybmF0aXZlbHksIHlvdSBjYW4gdXNlIGEgcHJvdmlkZXIgbW9kdWxlIGluc3RlYWQgb2YgdGhlIEFJIEdhdGV3YXkuXG5cbkxlYXJuIG1vcmU6IFxceDFCWzM0bSR7bW9yZUluZm9VUkx9XFx4MUJbMG1cblxuYCksXG4gICAgeyBuYW1lOiBcIkdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yXCIgfVxuICApO1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2Fzc2VtYmxlLW9wZXJhdGlvbi1uYW1lLnRzXG5mdW5jdGlvbiBhc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICBvcGVyYXRpb25JZCxcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIHJldHVybiB7XG4gICAgLy8gc3RhbmRhcmRpemVkIG9wZXJhdGlvbiBhbmQgcmVzb3VyY2UgbmFtZTpcbiAgICBcIm9wZXJhdGlvbi5uYW1lXCI6IGAke29wZXJhdGlvbklkfSR7KHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQpICE9IG51bGwgPyBgICR7dGVsZW1ldHJ5LmZ1bmN0aW9uSWR9YCA6IFwiXCJ9YCxcbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICAvLyBkZXRhaWxlZCwgQUkgU0RLIHNwZWNpZmljIGRhdGE6XG4gICAgXCJhaS5vcGVyYXRpb25JZFwiOiBvcGVyYXRpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWRcbiAgfTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNztcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwidGltZW91dFwiKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsVGltZW91dE1zID0gZ2V0VG90YWxUaW1lb3V0TXMoXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRvdGFsVGltZW91dE1zICE9IG51bGwpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHRvdGFsVGltZW91dE1zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTE3ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBzcmMvdGVsZW1ldHJ5L25vb3AtdHJhY2VyLnRzXG52YXIgbm9vcFRyYWNlciA9IHtcbiAgc3RhcnRTcGFuKCkge1xuICAgIHJldHVybiBub29wU3BhbjtcbiAgfSxcbiAgc3RhcnRBY3RpdmVTcGFuKG5hbWUxNywgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMShub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMihub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMyhub29wU3Bhbik7XG4gICAgfVxuICB9XG59O1xudmFyIG5vb3BTcGFuID0ge1xuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gbm9vcFNwYW5Db250ZXh0O1xuICB9LFxuICBzZXRBdHRyaWJ1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB1cGRhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVjb3JkRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vb3BTcGFuQ29udGV4dCA9IHtcbiAgdHJhY2VJZDogXCJcIixcbiAgc3BhbklkOiBcIlwiLFxuICB0cmFjZUZsYWdzOiAwXG59O1xuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmZ1bmN0aW9uIGdldFRyYWNlcih7XG4gIGlzRW5hYmxlZCA9IGZhbHNlLFxuICB0cmFjZXJcbn0gPSB7fSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0cmFjZXIpIHtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHtcbiAgU3BhblN0YXR1c0NvZGUsXG4gIGNvbnRleHRcbn0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuYXN5bmMgZnVuY3Rpb24gcmVjb3JkU3Bhbih7XG4gIG5hbWU6IG5hbWUxNyxcbiAgdHJhY2VyLFxuICBhdHRyaWJ1dGVzLFxuICBmbixcbiAgZW5kV2hlbkRvbmUgPSB0cnVlXG59KSB7XG4gIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKFxuICAgIG5hbWUxNyxcbiAgICB7IGF0dHJpYnV0ZXM6IGF3YWl0IGF0dHJpYnV0ZXMgfSxcbiAgICBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gY29udGV4dC5hY3RpdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRleHQud2l0aChjdHgsICgpID0+IGZuKHNwYW4pKTtcbiAgICAgICAgaWYgKGVuZFdoZW5Eb25lKSB7XG4gICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWNvcmRFcnJvck9uU3BhbihzcGFuLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiByZWNvcmRFcnJvck9uU3BhbihzcGFuLCBlcnJvcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKHtcbiAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgfSk7XG4gICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgfVxufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L3NlbGVjdC10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuYXN5bmMgZnVuY3Rpb24gc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIHRlbGVtZXRyeSxcbiAgYXR0cmlidXRlc1xufSkge1xuICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0QXR0cmlidXRlcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWx1ZS5pbnB1dCgpO1xuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdEF0dHJpYnV0ZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlLm91dHB1dCgpO1xuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdEF0dHJpYnV0ZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0QXR0cmlidXRlcztcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9zdHJpbmdpZnktZm9yLXRlbGVtZXRyeS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgcHJvbXB0Lm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBjb250ZW50OiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiID8gbWVzc2FnZS5jb250ZW50IDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJmaWxlXCIgPyB7XG4gICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICBkYXRhOiBwYXJ0LmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcocGFydC5kYXRhKSA6IHBhcnQuZGF0YVxuICAgICAgICB9IDogcGFydFxuICAgICAgKVxuICAgIH0pKVxuICApO1xufVxuXG4vLyBzcmMvdHlwZXMvdXNhZ2UudHNcbmZ1bmN0aW9uIGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IHVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgIGlucHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICBub0NhY2hlVG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy5ub0NhY2hlLFxuICAgICAgY2FjaGVSZWFkVG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy5jYWNoZVJlYWQsXG4gICAgICBjYWNoZVdyaXRlVG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy5jYWNoZVdyaXRlXG4gICAgfSxcbiAgICBvdXRwdXRUb2tlbnM6IHVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICBvdXRwdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIHRleHRUb2tlbnM6IHVzYWdlLm91dHB1dFRva2Vucy50ZXh0LFxuICAgICAgcmVhc29uaW5nVG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMucmVhc29uaW5nXG4gICAgfSxcbiAgICB0b3RhbFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgIHVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICksXG4gICAgcmF3OiB1c2FnZS5yYXcsXG4gICAgcmVhc29uaW5nVG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMucmVhc29uaW5nLFxuICAgIGNhY2hlZElucHV0VG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy5jYWNoZVJlYWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICBpbnB1dFRva2VuRGV0YWlsczoge1xuICAgICAgbm9DYWNoZVRva2Vuczogdm9pZCAwLFxuICAgICAgY2FjaGVSZWFkVG9rZW5zOiB2b2lkIDAsXG4gICAgICBjYWNoZVdyaXRlVG9rZW5zOiB2b2lkIDBcbiAgICB9LFxuICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgIG91dHB1dFRva2VuRGV0YWlsczoge1xuICAgICAgdGV4dFRva2Vuczogdm9pZCAwLFxuICAgICAgcmVhc29uaW5nVG9rZW5zOiB2b2lkIDBcbiAgICB9LFxuICAgIHRvdGFsVG9rZW5zOiB2b2lkIDAsXG4gICAgcmF3OiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZTEsIHVzYWdlMikge1xuICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLmlucHV0VG9rZW5zLCB1c2FnZTIuaW5wdXRUb2tlbnMpLFxuICAgIGlucHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICBub0NhY2hlVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9hMTcgPSB1c2FnZTEuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vQ2FjaGVUb2tlbnMsXG4gICAgICAgIChfYiA9IHVzYWdlMi5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5vQ2FjaGVUb2tlbnNcbiAgICAgICksXG4gICAgICBjYWNoZVJlYWRUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2MgPSB1c2FnZTEuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWNoZVJlYWRUb2tlbnMsXG4gICAgICAgIChfZCA9IHVzYWdlMi5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhY2hlUmVhZFRva2Vuc1xuICAgICAgKSxcbiAgICAgIGNhY2hlV3JpdGVUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2UgPSB1c2FnZTEuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWNoZVdyaXRlVG9rZW5zLFxuICAgICAgICAoX2YgPSB1c2FnZTIuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jYWNoZVdyaXRlVG9rZW5zXG4gICAgICApXG4gICAgfSxcbiAgICBvdXRwdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5vdXRwdXRUb2tlbnMsIHVzYWdlMi5vdXRwdXRUb2tlbnMpLFxuICAgIG91dHB1dFRva2VuRGV0YWlsczoge1xuICAgICAgdGV4dFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfZyA9IHVzYWdlMS5vdXRwdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy50ZXh0VG9rZW5zLFxuICAgICAgICAoX2ggPSB1c2FnZTIub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2gudGV4dFRva2Vuc1xuICAgICAgKSxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfaSA9IHVzYWdlMS5vdXRwdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfaS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgIChfaiA9IHVzYWdlMi5vdXRwdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfai5yZWFzb25pbmdUb2tlbnNcbiAgICAgIClcbiAgICB9LFxuICAgIHRvdGFsVG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEudG90YWxUb2tlbnMsIHVzYWdlMi50b3RhbFRva2VucyksXG4gICAgcmVhc29uaW5nVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlMS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICB1c2FnZTIucmVhc29uaW5nVG9rZW5zXG4gICAgKSxcbiAgICBjYWNoZWRJbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZTEuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICB1c2FnZTIuY2FjaGVkSW5wdXRUb2tlbnNcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBhZGRUb2tlbkNvdW50cyh0b2tlbkNvdW50MSwgdG9rZW5Db3VudDIpIHtcbiAgcmV0dXJuIHRva2VuQ291bnQxID09IG51bGwgJiYgdG9rZW5Db3VudDIgPT0gbnVsbCA/IHZvaWQgMCA6ICh0b2tlbkNvdW50MSAhPSBudWxsID8gdG9rZW5Db3VudDEgOiAwKSArICh0b2tlbkNvdW50MiAhPSBudWxsID8gdG9rZW5Db3VudDIgOiAwKTtcbn1cbmZ1bmN0aW9uIGFkZEltYWdlTW9kZWxVc2FnZSh1c2FnZTEsIHVzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEuaW5wdXRUb2tlbnMsIHVzYWdlMi5pbnB1dFRva2VucyksXG4gICAgb3V0cHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEub3V0cHV0VG9rZW5zLCB1c2FnZTIub3V0cHV0VG9rZW5zKSxcbiAgICB0b3RhbFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLnRvdGFsVG9rZW5zLCB1c2FnZTIudG90YWxUb2tlbnMpXG4gIH07XG59XG5cbi8vIHNyYy91dGlsL21lcmdlLW9iamVjdHMudHNcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhiYXNlLCBvdmVycmlkZXMpIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCAmJiBvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBvdmVycmlkZXM7XG4gIH1cbiAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0geyAuLi5iYXNlIH07XG4gIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGVzLCBrZXkpKSB7XG4gICAgICBjb25zdCBvdmVycmlkZXNWYWx1ZSA9IG92ZXJyaWRlc1trZXldO1xuICAgICAgaWYgKG92ZXJyaWRlc1ZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0ga2V5IGluIGJhc2UgPyBiYXNlW2tleV0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBpc1NvdXJjZU9iamVjdCA9IG92ZXJyaWRlc1ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvdmVycmlkZXNWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShvdmVycmlkZXNWYWx1ZSkgJiYgIShvdmVycmlkZXNWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEob3ZlcnJpZGVzVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgY29uc3QgaXNUYXJnZXRPYmplY3QgPSBiYXNlVmFsdWUgIT09IG51bGwgJiYgYmFzZVZhbHVlICE9PSB2b2lkIDAgJiYgdHlwZW9mIGJhc2VWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShiYXNlVmFsdWUpICYmICEoYmFzZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgIShiYXNlVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgaWYgKGlzU291cmNlT2JqZWN0ICYmIGlzVGFyZ2V0T2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgIGJhc2VWYWx1ZSxcbiAgICAgICAgICBvdmVycmlkZXNWYWx1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvdmVycmlkZXNWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBkZWxheSwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTQsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5SW5Ncyh7XG4gIGVycm9yLFxuICBleHBvbmVudGlhbEJhY2tvZmZEZWxheVxufSkge1xuICBjb25zdCBoZWFkZXJzID0gZXJyb3IucmVzcG9uc2VIZWFkZXJzO1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIGV4cG9uZW50aWFsQmFja29mZkRlbGF5O1xuICBsZXQgbXM7XG4gIGNvbnN0IHJldHJ5QWZ0ZXJNcyA9IGhlYWRlcnNbXCJyZXRyeS1hZnRlci1tc1wiXTtcbiAgaWYgKHJldHJ5QWZ0ZXJNcykge1xuICAgIGNvbnN0IHRpbWVvdXRNcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlck1zKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0TXMpKSB7XG4gICAgICBtcyA9IHRpbWVvdXRNcztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmV0cnlBZnRlciA9IGhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgaWYgKHJldHJ5QWZ0ZXIgJiYgbXMgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0U2Vjb25kcykpIHtcbiAgICAgIG1zID0gdGltZW91dFNlY29uZHMgKiAxZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVyKSAtIERhdGUubm93KCk7XG4gICAgfVxuICB9XG4gIGlmIChtcyAhPSBudWxsICYmICFOdW1iZXIuaXNOYU4obXMpICYmIDAgPD0gbXMgJiYgKG1zIDwgNjAgKiAxZTMgfHwgbXMgPCBleHBvbmVudGlhbEJhY2tvZmZEZWxheSkpIHtcbiAgICByZXR1cm4gbXM7XG4gIH1cbiAgcmV0dXJuIGV4cG9uZW50aWFsQmFja29mZkRlbGF5O1xufVxudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZlJlc3BlY3RpbmdSZXRyeUhlYWRlcnMgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDIsXG4gIGFib3J0U2lnbmFsXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yLFxuICBhYm9ydFNpZ25hbFxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yLFxuICBhYm9ydFNpZ25hbFxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U0KGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KFxuICAgICAgICBnZXRSZXRyeURlbGF5SW5Ncyh7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk6IGRlbGF5SW5Nc1xuICAgICAgICB9KSxcbiAgICAgICAgeyBhYm9ydFNpZ25hbCB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHtcbiAgICAgICAgICBtYXhSZXRyaWVzLFxuICAgICAgICAgIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcyxcbiAgICAgICAgICBiYWNrb2ZmRmFjdG9yLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0sXG4gICAgICAgIG5ld0Vycm9yc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiBcImVycm9yTm90UmV0cnlhYmxlXCIsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL3ByZXBhcmUtcmV0cmllcy50c1xuZnVuY3Rpb24gcHJlcGFyZVJldHJpZXMoe1xuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgPj0gMFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4UmV0cmllc1Jlc3VsdCA9IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyO1xuICByZXR1cm4ge1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgcmV0cnk6IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZlJlc3BlY3RpbmdSZXRyeUhlYWRlcnMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc1Jlc3VsdCxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSlcbiAgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvY29sbGVjdC10b29sLWFwcHJvdmFscy50c1xuZnVuY3Rpb24gY29sbGVjdFRvb2xBcHByb3ZhbHMoe1xuICBtZXNzYWdlc1xufSkge1xuICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzLmF0KC0xKTtcbiAgaWYgKChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgIT0gXCJ0b29sXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXBwcm92ZWRUb29sQXBwcm92YWxzOiBbXSxcbiAgICAgIGRlbmllZFRvb2xBcHByb3ZhbHM6IFtdXG4gICAgfTtcbiAgfVxuICBjb25zdCB0b29sQ2FsbHNCeVRvb2xDYWxsSWQgPSB7fTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgIHRvb2xDYWxsc0J5VG9vbENhbGxJZFtwYXJ0LnRvb2xDYWxsSWRdID0gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCB0b29sQXBwcm92YWxSZXF1ZXN0c0J5QXBwcm92YWxJZCA9IHt9O1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSB7XG4gICAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdHNCeUFwcHJvdmFsSWRbcGFydC5hcHByb3ZhbElkXSA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdG9vbFJlc3VsdHMgPSB7fTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGxhc3RNZXNzYWdlLmNvbnRlbnQpIHtcbiAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgIHRvb2xSZXN1bHRzW3BhcnQudG9vbENhbGxJZF0gPSBwYXJ0O1xuICAgIH1cbiAgfVxuICBjb25zdCBhcHByb3ZlZFRvb2xBcHByb3ZhbHMgPSBbXTtcbiAgY29uc3QgZGVuaWVkVG9vbEFwcHJvdmFscyA9IFtdO1xuICBjb25zdCBhcHByb3ZhbFJlc3BvbnNlcyA9IGxhc3RNZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiXG4gICk7XG4gIGZvciAoY29uc3QgYXBwcm92YWxSZXNwb25zZSBvZiBhcHByb3ZhbFJlc3BvbnNlcykge1xuICAgIGNvbnN0IGFwcHJvdmFsUmVxdWVzdCA9IHRvb2xBcHByb3ZhbFJlcXVlc3RzQnlBcHByb3ZhbElkW2FwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZF07XG4gICAgaWYgKGFwcHJvdmFsUmVxdWVzdCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcHByb3ZhbEVycm9yKHtcbiAgICAgICAgYXBwcm92YWxJZDogYXBwcm92YWxSZXNwb25zZS5hcHByb3ZhbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRvb2xSZXN1bHRzW2FwcHJvdmFsUmVxdWVzdC50b29sQ2FsbElkXSAhPSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdG9vbENhbGwgPSB0b29sQ2FsbHNCeVRvb2xDYWxsSWRbYXBwcm92YWxSZXF1ZXN0LnRvb2xDYWxsSWRdO1xuICAgIGlmICh0b29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICB0b29sQ2FsbElkOiBhcHByb3ZhbFJlcXVlc3QudG9vbENhbGxJZCxcbiAgICAgICAgYXBwcm92YWxJZDogYXBwcm92YWxSZXF1ZXN0LmFwcHJvdmFsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcHByb3ZhbCA9IHtcbiAgICAgIGFwcHJvdmFsUmVxdWVzdCxcbiAgICAgIGFwcHJvdmFsUmVzcG9uc2UsXG4gICAgICB0b29sQ2FsbFxuICAgIH07XG4gICAgaWYgKGFwcHJvdmFsUmVzcG9uc2UuYXBwcm92ZWQpIHtcbiAgICAgIGFwcHJvdmVkVG9vbEFwcHJvdmFscy5wdXNoKGFwcHJvdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVuaWVkVG9vbEFwcHJvdmFscy5wdXNoKGFwcHJvdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgYXBwcm92ZWRUb29sQXBwcm92YWxzLCBkZW5pZWRUb29sQXBwcm92YWxzIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2V4ZWN1dGUtdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBleGVjdXRlVG9vbCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBvblByZWxpbWluYXJ5VG9vbFJlc3VsdFxufSkge1xuICBjb25zdCB7IHRvb2xOYW1lLCB0b29sQ2FsbElkLCBpbnB1dCB9ID0gdG9vbENhbGw7XG4gIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xOYW1lLFxuICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsSWQsXG4gICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShpbnB1dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGxldCBvdXRwdXQ7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBleGVjdXRlVG9vbCh7XG4gICAgICAgICAgZXhlY3V0ZTogdG9vbDIuZXhlY3V0ZS5iaW5kKHRvb2wyKSxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHN0cmVhbSkge1xuICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicHJlbGltaW5hcnlcIikge1xuICAgICAgICAgICAgb25QcmVsaW1pbmFyeVRvb2xSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUHJlbGltaW5hcnlUb29sUmVzdWx0KHtcbiAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBwYXJ0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGR5bmFtaWM6IHRvb2wyLnR5cGUgPT09IFwiZHluYW1pY1wiLFxuICAgICAgICAgIC4uLnRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIGR5bmFtaWM6IHRvb2wyLnR5cGUgPT09IFwiZHluYW1pY1wiLFxuICAgICAgICAuLi50b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2V4dHJhY3QtdGV4dC1jb250ZW50LnRzXG5mdW5jdGlvbiBleHRyYWN0VGV4dENvbnRlbnQoY29udGVudCkge1xuICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuZmlsdGVyKFxuICAgIChjb250ZW50MikgPT4gY29udGVudDIudHlwZSA9PT0gXCJ0ZXh0XCJcbiAgKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLm1hcCgoY29udGVudDIpID0+IGNvbnRlbnQyLnRleHQpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlZC1maWxlLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkzLFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IGFzIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgY29uc3QgaXNVaW50OEFycmF5ID0gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgdGhpcy5iYXNlNjREYXRhID0gaXNVaW50OEFycmF5ID8gdm9pZCAwIDogZGF0YTtcbiAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gaXNVaW50OEFycmF5ID8gZGF0YSA6IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhVHlwZSA9IG1lZGlhVHlwZTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCBiYXNlNjQoKSB7XG4gICAgaWYgKHRoaXMuYmFzZTY0RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJhc2U2NERhdGEgPSBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0Mih0aGlzLnVpbnQ4QXJyYXlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZTY0RGF0YTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCB1aW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnVpbnQ4QXJyYXlEYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMudWludDhBcnJheURhdGEgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Myh0aGlzLmJhc2U2NERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50OEFycmF5RGF0YTtcbiAgfVxufTtcbnZhciBEZWZhdWx0R2VuZXJhdGVkRmlsZVdpdGhUeXBlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnR5cGUgPSBcImZpbGVcIjtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvaXMtYXBwcm92YWwtbmVlZGVkLnRzXG5hc3luYyBmdW5jdGlvbiBpc0FwcHJvdmFsTmVlZGVkKHtcbiAgdG9vbDogdG9vbDIsXG4gIHRvb2xDYWxsLFxuICBtZXNzYWdlcyxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHRcbn0pIHtcbiAgaWYgKHRvb2wyLm5lZWRzQXBwcm92YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHRvb2wyLm5lZWRzQXBwcm92YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRvb2wyLm5lZWRzQXBwcm92YWw7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRvb2wyLm5lZWRzQXBwcm92YWwodG9vbENhbGwuaW5wdXQsIHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIG1lc3NhZ2VzLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciBvdXRwdXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQob3V0cHV0X2V4cG9ydHMsIHtcbiAgYXJyYXk6ICgpID0+IGFycmF5LFxuICBjaG9pY2U6ICgpID0+IGNob2ljZSxcbiAganNvbjogKCkgPT4ganNvbixcbiAgb2JqZWN0OiAoKSA9PiBvYmplY3QsXG4gIHRleHQ6ICgpID0+IHRleHRcbn0pO1xuaW1wb3J0IHtcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEyLFxuICByZXNvbHZlLFxuICBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvZml4LWpzb24udHNcbmZ1bmN0aW9uIGZpeEpzb24oaW5wdXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXCJST09UXCJdO1xuICBsZXQgbGFzdFZhbGlkSW5kZXggPSAtMTtcbiAgbGV0IGxpdGVyYWxTdGFydCA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIHN3YXBTdGF0ZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGNhc2UgXCJuXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9MSVRFUkFMXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIntcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgY2FzZSBcIlJPT1RcIjpcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJGSU5JU0hcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCI6XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdfRVNDQVBFXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX05VTUJFUlwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBjYXNlIFwiLlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGkgKyAxKTtcbiAgICAgICAgaWYgKCFcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGlucHV0LnNsaWNlKDAsIGxhc3RWYWxpZEluZGV4ICsgMSk7XG4gIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhY2tbaV07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICByZXN1bHQgKz0gJ1wiJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBpZiAoXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJ0cnVlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJmYWxzZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJudWxsXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24oanNvblRleHQpIHtcbiAgaWYgKGpzb25UZXh0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJ1bmRlZmluZWQtaW5wdXRcIiB9O1xuICB9XG4gIGxldCByZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDoganNvblRleHQgfSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIHN0YXRlOiBcInN1Y2Nlc3NmdWwtcGFyc2VcIiB9O1xuICB9XG4gIHJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBmaXhKc29uKGpzb25UZXh0KSB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIiB9O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcImZhaWxlZC1wYXJzZVwiIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIHRleHQgPSAoKSA9PiAoe1xuICBuYW1lOiBcInRleHRcIixcbiAgcmVzcG9uc2VGb3JtYXQ6IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwidGV4dFwiIH0pLFxuICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfSxcbiAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgbmFtZTogbmFtZTE3LFxuICBkZXNjcmlwdGlvblxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTIoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6IHJlc29sdmUoc2NoZW1hLmpzb25TY2hlbWEpLnRoZW4oKGpzb25TY2hlbWEyKSA9PiAoe1xuICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICBzY2hlbWE6IGpzb25TY2hlbWEyLFxuICAgICAgLi4ubmFtZTE3ICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMTcgfSxcbiAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgfSkpLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgdmFsdWU6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBzY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xufTtcbnZhciBhcnJheSA9ICh7XG4gIGVsZW1lbnQ6IGlucHV0RWxlbWVudFNjaGVtYSxcbiAgbmFtZTogbmFtZTE3LFxuICBkZXNjcmlwdGlvblxufSkgPT4ge1xuICBjb25zdCBlbGVtZW50U2NoZW1hID0gYXNTY2hlbWEyKGlucHV0RWxlbWVudFNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJhcnJheVwiLFxuICAgIC8vIEpTT04gc2NoZW1hIHRoYXQgZGVzY3JpYmVzIGFuIGFycmF5IG9mIGVsZW1lbnRzOlxuICAgIHJlc3BvbnNlRm9ybWF0OiByZXNvbHZlKGVsZW1lbnRTY2hlbWEuanNvblNjaGVtYSkudGhlbigoanNvblNjaGVtYTIpID0+IHtcbiAgICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0ganNvblNjaGVtYTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFtcImVsZW1lbnRzXCJdLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAuLi5uYW1lMTcgIT0gbnVsbCAmJiB7IG5hbWU6IG5hbWUxNyB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgICAgfTtcbiAgICB9KSxcbiAgICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dDIpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHBhcnNlUmVzdWx0LnZhbHVlO1xuICAgICAgaWYgKG91dGVyVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZWxlbWVudHNcIiBpbiBvdXRlclZhbHVlKSB8fCAhQXJyYXkuaXNBcnJheShvdXRlclZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICBjYXVzZTogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlOiBvdXRlclZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwicmVzcG9uc2UgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhbiBlbGVtZW50cyBhcnJheVwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBvdXRlclZhbHVlLmVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgIHZhbHVlOiBlbGVtZW50LFxuICAgICAgICAgIHNjaGVtYTogZWxlbWVudFNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRlclZhbHVlLmVsZW1lbnRzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICBjb25zdCBvdXRlclZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgIGlmIChvdXRlclZhbHVlID09IG51bGwgfHwgdHlwZW9mIG91dGVyVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImVsZW1lbnRzXCIgaW4gb3V0ZXJWYWx1ZSkgfHwgIUFycmF5LmlzQXJyYXkob3V0ZXJWYWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJhd0VsZW1lbnRzID0gcmVzdWx0LnN0YXRlID09PSBcInJlcGFpcmVkLXBhcnNlXCIgJiYgb3V0ZXJWYWx1ZS5lbGVtZW50cy5sZW5ndGggPiAwID8gb3V0ZXJWYWx1ZS5lbGVtZW50cy5zbGljZSgwLCAtMSkgOiBvdXRlclZhbHVlLmVsZW1lbnRzO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCByYXdFbGVtZW50IG9mIHJhd0VsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJhd0VsZW1lbnQsXG4gICAgICAgICAgICAgIHNjaGVtYTogZWxlbWVudFNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnRzLnB1c2godmFsaWRhdGlvblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHBhcnRpYWw6IHBhcnNlZEVsZW1lbnRzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAocGFydGlhbE91dHB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBwYXJ0aWFsT3V0cHV0Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydGlhbE91dHB1dFtwdWJsaXNoZWRFbGVtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBjaG9pY2UgPSAoe1xuICBvcHRpb25zOiBjaG9pY2VPcHRpb25zLFxuICBuYW1lOiBuYW1lMTcsXG4gIGRlc2NyaXB0aW9uXG59KSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJjaG9pY2VcIixcbiAgICAvLyBKU09OIHNjaGVtYSB0aGF0IGRlc2NyaWJlcyBhbiBlbnVtZXJhdGlvbjpcbiAgICByZXNwb25zZUZvcm1hdDogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgc2NoZW1hOiB7XG4gICAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogY2hvaWNlT3B0aW9ucyB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbXCJyZXN1bHRcIl0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIC4uLm5hbWUxNyAhPSBudWxsICYmIHsgbmFtZTogbmFtZTE3IH0sXG4gICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgIH0pLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRlclZhbHVlID0gcGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyZXN1bHRcIiBpbiBvdXRlclZhbHVlKSB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIgfHwgIWNob2ljZU9wdGlvbnMuaW5jbHVkZXMob3V0ZXJWYWx1ZS5yZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWU6IG91dGVyVmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJyZXNwb25zZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgY2hvaWNlIHZhbHVlLlwiXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRlclZhbHVlLnJlc3VsdDtcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyZXN1bHRcIiBpbiBvdXRlclZhbHVlKSB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvdGVudGlhbE1hdGNoZXMgPSBjaG9pY2VPcHRpb25zLmZpbHRlcihcbiAgICAgICAgICAgIChjaG9pY2VPcHRpb24pID0+IGNob2ljZU9wdGlvbi5zdGFydHNXaXRoKG91dGVyVmFsdWUucmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxNYXRjaGVzLmluY2x1ZGVzKG91dGVyVmFsdWUucmVzdWx0KSA/IHsgcGFydGlhbDogb3V0ZXJWYWx1ZS5yZXN1bHQgfSA6IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoID09PSAxID8geyBwYXJ0aWFsOiBwb3RlbnRpYWxNYXRjaGVzWzBdIH0gOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH07XG59O1xudmFyIGpzb24gPSAoe1xuICBuYW1lOiBuYW1lMTcsXG4gIGRlc2NyaXB0aW9uXG59ID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImpzb25cIixcbiAgICByZXNwb25zZUZvcm1hdDogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgLi4ubmFtZTE3ICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMTcgfSxcbiAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgfSksXG4gICAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQyKSB7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogeyBwYXJ0aWFsOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTMsXG4gIHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjMsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29scyxcbiAgcmVwYWlyVG9vbENhbGwsXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIHRyeSB7XG4gICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgIGlmICh0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkICYmIHRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlUHJvdmlkZXJFeGVjdXRlZER5bmFtaWNUb29sQ2FsbCh0b29sQ2FsbCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGRvUGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsLCB0b29scyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHJlcGFpclRvb2xDYWxsID09IG51bGwgfHwgIShOb1N1Y2hUb29sRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgSW52YWxpZFRvb2xJbnB1dEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGxldCByZXBhaXJlZFRvb2xDYWxsID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcGFpcmVkVG9vbENhbGwgPSBhd2FpdCByZXBhaXJUb29sQ2FsbCh7XG4gICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IGFzeW5jICh7IHRvb2xOYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5wdXRTY2hlbWEgfSA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhc1NjaGVtYTMoaW5wdXRTY2hlbWEpLmpzb25TY2hlbWE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChyZXBhaXJFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbENhbGxSZXBhaXJFcnJvcih7XG4gICAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGFpcmVkVG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBkb1BhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogcmVwYWlyZWRUb29sQ2FsbCwgdG9vbHMgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHBhcnNlZElucHV0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCB9KTtcbiAgICBjb25zdCBpbnB1dCA9IHBhcnNlZElucHV0LnN1Y2Nlc3MgPyBwYXJzZWRJbnB1dC52YWx1ZSA6IHRvb2xDYWxsLmlucHV0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGlucHV0LFxuICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgIGludmFsaWQ6IHRydWUsXG4gICAgICBlcnJvcixcbiAgICAgIHRpdGxlOiAoX2ExNyA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sQ2FsbC50b29sTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnRpdGxlLFxuICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGFcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwodG9vbENhbGwpIHtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5pbnB1dC50cmltKCkgPT09IFwiXCIgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7fSB9IDogYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sSW5wdXRFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICB0b29sSW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgIGR5bmFtaWM6IHRydWUsXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZG9QYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIGlmICh0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkICYmIHRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwodG9vbENhbGwpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTModG9vbDIuaW5wdXRTY2hlbWEpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmlucHV0LnRyaW0oKSA9PT0gXCJcIiA/IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMyh7IHZhbHVlOiB7fSwgc2NoZW1hIH0pIDogYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCwgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xJbnB1dEVycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbElucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b29sMi50eXBlID09PSBcImR5bmFtaWNcIiA/IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgZHluYW1pYzogdHJ1ZSxcbiAgICB0aXRsZTogdG9vbDIudGl0bGVcbiAgfSA6IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgaW5wdXQ6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSxcbiAgICB0aXRsZTogdG9vbDIudGl0bGVcbiAgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RlcC1yZXN1bHQudHNcbnZhciBEZWZhdWx0U3RlcFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgZmluaXNoUmVhc29uLFxuICAgIHJhd0ZpbmlzaFJlYXNvbixcbiAgICB1c2FnZSxcbiAgICB3YXJuaW5ncyxcbiAgICByZXF1ZXN0LFxuICAgIHJlc3BvbnNlLFxuICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgfSkge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBmaW5pc2hSZWFzb247XG4gICAgdGhpcy5yYXdGaW5pc2hSZWFzb24gPSByYXdGaW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYXNvbmluZy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB0aGlzLnJlYXNvbmluZy5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpLm1hcCgocGFydCkgPT4gcGFydC5maWxlKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInNvdXJjZVwiKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbENhbGxzLmZpbHRlcihcbiAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwuZHluYW1pYyAhPT0gdHJ1ZVxuICAgICk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbENhbGxzLmZpbHRlcihcbiAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwuZHluYW1pYyA9PT0gdHJ1ZVxuICAgICk7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIik7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAgICh0b29sUmVzdWx0KSA9PiB0b29sUmVzdWx0LmR5bmFtaWMgIT09IHRydWVcbiAgICApO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgICAgKHRvb2xSZXN1bHQpID0+IHRvb2xSZXN1bHQuZHluYW1pYyA9PT0gdHJ1ZVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0b3AtY29uZGl0aW9uLnRzXG5mdW5jdGlvbiBzdGVwQ291bnRJcyhzdGVwQ291bnQpIHtcbiAgcmV0dXJuICh7IHN0ZXBzIH0pID0+IHN0ZXBzLmxlbmd0aCA9PT0gc3RlcENvdW50O1xufVxuZnVuY3Rpb24gaGFzVG9vbENhbGwodG9vbE5hbWUpIHtcbiAgcmV0dXJuICh7IHN0ZXBzIH0pID0+IHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2ExNyA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zb21lKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC50b29sTmFtZSA9PT0gdG9vbE5hbWVcbiAgICApKSAhPSBudWxsID8gX2MgOiBmYWxzZTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzU3RvcENvbmRpdGlvbk1ldCh7XG4gIHN0b3BDb25kaXRpb25zLFxuICBzdGVwc1xufSkge1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHN0b3BDb25kaXRpb25zLm1hcCgoY29uZGl0aW9uKSA9PiBjb25kaXRpb24oeyBzdGVwcyB9KSkpKS5zb21lKChyZXN1bHQpID0+IHJlc3VsdCk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3RvLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5hc3luYyBmdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICBjb250ZW50OiBpbnB1dENvbnRlbnQsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgY29uc3QgY29udGVudCA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgaW5wdXRDb250ZW50KSB7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikgJiYgIXBhcnQucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiICYmIHBhcnQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZGF0YTogcGFydC5maWxlLmJhc2U2NCxcbiAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbcGFydC50b29sTmFtZV0sXG4gICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICBlcnJvck1vZGU6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgIG91dHB1dDogcGFydC5lcnJvcixcbiAgICAgICAgICBlcnJvck1vZGU6IFwianNvblwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWxJZCxcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdG9vbFJlc3VsdENvbnRlbnQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGlucHV0Q29udGVudCkge1xuICAgIGlmICghKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIpIHx8IHBhcnQucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXSxcbiAgICAgIG91dHB1dDogcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgPyBwYXJ0Lm91dHB1dCA6IHBhcnQuZXJyb3IsXG4gICAgICBlcnJvck1vZGU6IHBhcnQudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIgPyBcInRleHRcIiA6IFwibm9uZVwiXG4gICAgfSk7XG4gICAgdG9vbFJlc3VsdENvbnRlbnQucHVzaCh7XG4gICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICB9KTtcbiAgfVxuICBpZiAodG9vbFJlc3VsdENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIHNyYy91dGlsL21lcmdlLWFib3J0LXNpZ25hbHMudHNcbmZ1bmN0aW9uIG1lcmdlQWJvcnRTaWduYWxzKC4uLnNpZ25hbHMpIHtcbiAgY29uc3QgdmFsaWRTaWduYWxzID0gc2lnbmFscy5maWx0ZXIoXG4gICAgKHNpZ25hbCkgPT4gc2lnbmFsICE9IG51bGxcbiAgKTtcbiAgaWYgKHZhbGlkU2lnbmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh2YWxpZFNpZ25hbHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbGlkU2lnbmFsc1swXTtcbiAgfVxuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBmb3IgKGNvbnN0IHNpZ25hbCBvZiB2YWxpZFNpZ25hbHMpIHtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSxcbiAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcih7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoe1xuICBtb2RlbDogbW9kZWxBcmcsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICB0aW1lb3V0LFxuICBoZWFkZXJzLFxuICBzdG9wV2hlbiA9IHN0ZXBDb3VudElzKDEpLFxuICBleHBlcmltZW50YWxfb3V0cHV0LFxuICBvdXRwdXQgPSBleHBlcmltZW50YWxfb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBhY3RpdmVUb29scyA9IGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgZXhwZXJpbWVudGFsX3ByZXBhcmVTdGVwLFxuICBwcmVwYXJlU3RlcCA9IGV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcCxcbiAgZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsOiByZXBhaXJUb29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBfaW50ZXJuYWw6IHsgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBvcmlnaW5hbEdlbmVyYXRlSWQgfSA9IHt9LFxuICBvblN0ZXBGaW5pc2gsXG4gIG9uRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3Qgc3RvcENvbmRpdGlvbnMgPSBhc0FycmF5KHN0b3BXaGVuKTtcbiAgY29uc3QgdG90YWxUaW1lb3V0TXMgPSBnZXRUb3RhbFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcFRpbWVvdXRNcyA9IGdldFN0ZXBUaW1lb3V0TXModGltZW91dCk7XG4gIGNvbnN0IHN0ZXBBYm9ydENvbnRyb2xsZXIgPSBzdGVwVGltZW91dE1zICE9IG51bGwgPyBuZXcgQWJvcnRDb250cm9sbGVyKCkgOiB2b2lkIDA7XG4gIGNvbnN0IG1lcmdlZEFib3J0U2lnbmFsID0gbWVyZ2VBYm9ydFNpZ25hbHMoXG4gICAgYWJvcnRTaWduYWwsXG4gICAgdG90YWxUaW1lb3V0TXMgIT0gbnVsbCA/IEFib3J0U2lnbmFsLnRpbWVvdXQodG90YWxUaW1lb3V0TXMpIDogdm9pZCAwLFxuICAgIHN0ZXBBYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsOiBtZXJnZWRBYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDIoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgc2V0dGluZ3M6IHsgLi4uY2FsbFNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlc1xuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBtb2RlbDpcbiAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlcyA9IGluaXRpYWxQcm9tcHQubWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBhcHByb3ZlZFRvb2xBcHByb3ZhbHMsIGRlbmllZFRvb2xBcHByb3ZhbHMgfSA9IGNvbGxlY3RUb29sQXBwcm92YWxzKHsgbWVzc2FnZXM6IGluaXRpYWxNZXNzYWdlcyB9KTtcbiAgICAgICAgY29uc3QgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMgPSBhcHByb3ZlZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICF0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVuaWVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwIHx8IGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0b29sT3V0cHV0cyA9IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICB0b29sQ2FsbHM6IGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLm1hcChcbiAgICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzLFxuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB0b29sQ29udGVudCA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0MiBvZiB0b29sT3V0cHV0cykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIGlucHV0OiBvdXRwdXQyLmlucHV0LFxuICAgICAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbb3V0cHV0Mi50b29sTmFtZV0sXG4gICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgPyBvdXRwdXQyLm91dHB1dCA6IG91dHB1dDIuZXJyb3IsXG4gICAgICAgICAgICAgIGVycm9yTW9kZTogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtZXJyb3JcIiA/IFwianNvblwiIDogXCJub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3V0cHV0Mi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogb3V0cHV0Mi50b29sTmFtZSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBtb2RlbE91dHB1dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdG9vbEFwcHJvdmFsIG9mIGRlbmllZFRvb2xBcHByb3ZhbHMpIHtcbiAgICAgICAgICAgIHRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGlvbi1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAvLyBGb3IgcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHMsIGluY2x1ZGUgYXBwcm92YWxJZCBzbyBwcm92aWRlciBjYW4gY29ycmVsYXRlXG4gICAgICAgICAgICAgICAgLi4udG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgJiYge1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5haToge1xuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRvb2xDb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMgPSBbXG4gICAgICAgICAgLi4uYXBwcm92ZWRUb29sQXBwcm92YWxzLFxuICAgICAgICAgIC4uLmRlbmllZFRvb2xBcHByb3ZhbHNcbiAgICAgICAgXS5maWx0ZXIoKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzLm1hcChcbiAgICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZhbElkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbFNldHRpbmdzMiA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gICAgICAgIGxldCBjbGllbnRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgICAgIGNvbnN0IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjb25zdCBzdGVwVGltZW91dElkID0gc3RlcFRpbWVvdXRNcyAhPSBudWxsID8gc2V0VGltZW91dCgoKSA9PiBzdGVwQWJvcnRDb250cm9sbGVyLmFib3J0KCksIHN0ZXBUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFsuLi5pbml0aWFsTWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgIHN0ZXBzLFxuICAgICAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgICAoX2ExNyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tb2RlbCkgIT0gbnVsbCA/IF9hMTcgOiBtb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICAgIHN5c3RlbTogKF9iID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnN5c3RlbSkgIT0gbnVsbCA/IF9iIDogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9jIDogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgc3RlcE1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQgPSAoX2QgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuZXhwZXJpbWVudGFsX2NvbnRleHQpICE9IG51bGwgPyBfZCA6IGV4cGVyaW1lbnRhbF9jb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSwgdG9vbHM6IHN0ZXBUb29scyB9ID0gYXdhaXQgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICB0b29sQ2hvaWNlOiAoX2UgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQudG9vbENob2ljZSkgIT0gbnVsbCA/IF9lIDogdG9vbENob2ljZSxcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbHM6IChfZiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5hY3RpdmVUb29scykgIT0gbnVsbCA/IF9mIDogYWN0aXZlVG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwuaWRcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogKF9hMTggPSBzZXR0aW5ncy50ZW1wZXJhdHVyZSkgIT0gbnVsbCA/IF9hMTggOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTksIF9iMiwgX2MyLCBfZDIsIF9lMiwgX2YyLCBfZzIsIF9oMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFByb3ZpZGVyT3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGVwTW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uY2FsbFNldHRpbmdzMixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sczogc3RlcFRvb2xzLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBhd2FpdCAob3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQpLFxuICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBzdGVwUHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiBtZXJnZWRBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTkgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE5LmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kMiA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZjIgPSAoX2UyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UyLm1vZGVsSWQpICE9IG51bGwgPyBfZjIgOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiAoX2cyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cyLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgYm9keTogKF9oMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oMi5ib2R5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdC5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGV4dHJhY3RUZXh0Q29udGVudChyZXN1bHQuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gYXNUb29sQ2FsbHMocmVzdWx0LmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxscyA9PSBudWxsID8gdm9pZCAwIDogSlNPTi5zdHJpbmdpZnkodG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdC51c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5vdXRwdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5maW5pc2hSZWFzb24udW5pZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5vdXRwdXRUb2tlbnMudG90YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIlxuICAgICAgICAgICAgICApLm1hcChcbiAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xBcHByb3ZhbFJlcXVlc3RzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHN0ZXBUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICAgICAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIub25JbnB1dEF2YWlsYWJsZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRBdmFpbGFibGUoe1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiBtZXJnZWRBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGF3YWl0IGlzQXBwcm92YWxOZWVkZWQoe1xuICAgICAgICAgICAgICAgIHRvb2w6IHRvb2wyLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzW3Rvb2xDYWxsLnRvb2xDYWxsSWRdID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbHMgPSBzdGVwVG9vbENhbGxzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC5pbnZhbGlkICYmIHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjbGllbnRUb29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBpbnZhbGlkVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZ2V0RXJyb3JNZXNzYWdlNSh0b29sQ2FsbC5lcnJvciksXG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+ICF0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMucHVzaChcbiAgICAgICAgICAgICAgICAuLi5hd2FpdCBleGVjdXRlVG9vbHMoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBjbGllbnRUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+ICF0b29sQ2FsbC5pbnZhbGlkICYmIHRvb2xBcHByb3ZhbFJlcXVlc3RzW3Rvb2xDYWxsLnRvb2xDYWxsSWRdID09IG51bGxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiBtZXJnZWRBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgICBpZiAoIXRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Jlc3VsdEluUmVzcG9uc2UgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50LnNvbWUoXG4gICAgICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgJiYgcGFydC50b29sQ2FsbElkID09PSB0b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Jlc3VsdEluUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zZXQodG9vbENhbGwudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLmRlbGV0ZShwYXJ0LnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGVwQ29udGVudCA9IGFzQ29udGVudCh7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQsXG4gICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgdG9vbE91dHB1dHM6IGNsaWVudFRvb2xPdXRwdXRzLFxuICAgICAgICAgICAgICB0b29sQXBwcm92YWxSZXF1ZXN0czogT2JqZWN0LnZhbHVlcyh0b29sQXBwcm92YWxSZXF1ZXN0cyksXG4gICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgLi4uYXdhaXQgdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgICAgICB0b29sc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgICAgY29udGVudDogc3RlcENvbnRlbnQsXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLnJhdyxcbiAgICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlKSxcbiAgICAgICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICByZXF1ZXN0OiAoX2cgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXF1ZXN0KSAhPSBudWxsID8gX2cgOiB7fSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lIG1zZ3MgdG8gYXZvaWQgbXV0YXRpbmcgcGFzdCBtZXNzYWdlcyBpbiBtdWx0aS1zdGVwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdHJ1Y3R1cmVkQ2xvbmUocmVzcG9uc2VNZXNzYWdlcylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgICAgIHdhcm5pbmdzOiAoX2ggPSBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncykgIT0gbnVsbCA/IF9oIDogW10sXG4gICAgICAgICAgICAgIHByb3ZpZGVyOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIG1vZGVsOiBzdGVwTW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoc3RlcFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGVwVGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgIC8vIENvbnRpbnVlIGlmOlxuICAgICAgICAgIC8vIDEuIFRoZXJlIGFyZSBjbGllbnQgdG9vbCBjYWxscyB0aGF0IGhhdmUgYWxsIGJlZW4gZXhlY3V0ZWQsIE9SXG4gICAgICAgICAgLy8gMi4gVGhlcmUgYXJlIHBlbmRpbmcgZGVmZXJyZWQgcmVzdWx0cyBmcm9tIHByb3ZpZGVyLWV4ZWN1dGVkIHRvb2xzXG4gICAgICAgICAgKGNsaWVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIGNsaWVudFRvb2xPdXRwdXRzLmxlbmd0aCA9PT0gY2xpZW50VG9vbENhbGxzLmxlbmd0aCB8fCBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuc2l6ZSA+IDApICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICFhd2FpdCBpc1N0b3BDb25kaXRpb25NZXQoeyBzdG9wQ29uZGl0aW9ucywgc3RlcHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGV4dHJhY3RUZXh0Q29udGVudChjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0b29sQ2FsbHMgPT0gbnVsbCA/IHZvaWQgMCA6IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXAgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHN0ZXBzLnJlZHVjZShcbiAgICAgICAgICAodG90YWxVc2FnZTIsIHN0ZXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodG90YWxVc2FnZTIsIHN0ZXAudXNhZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHJlYXNvbmluZ1Rva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBsYXN0U3RlcC5yYXdGaW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGxhc3RTdGVwLnVzYWdlLFxuICAgICAgICAgIGNvbnRlbnQ6IGxhc3RTdGVwLmNvbnRlbnQsXG4gICAgICAgICAgdGV4dDogbGFzdFN0ZXAudGV4dCxcbiAgICAgICAgICByZWFzb25pbmdUZXh0OiBsYXN0U3RlcC5yZWFzb25pbmdUZXh0LFxuICAgICAgICAgIHJlYXNvbmluZzogbGFzdFN0ZXAucmVhc29uaW5nLFxuICAgICAgICAgIGZpbGVzOiBsYXN0U3RlcC5maWxlcyxcbiAgICAgICAgICBzb3VyY2VzOiBsYXN0U3RlcC5zb3VyY2VzLFxuICAgICAgICAgIHRvb2xDYWxsczogbGFzdFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgIHN0YXRpY1Rvb2xDYWxsczogbGFzdFN0ZXAuc3RhdGljVG9vbENhbGxzLFxuICAgICAgICAgIGR5bmFtaWNUb29sQ2FsbHM6IGxhc3RTdGVwLmR5bmFtaWNUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGxhc3RTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgIHN0YXRpY1Rvb2xSZXN1bHRzOiBsYXN0U3RlcC5zdGF0aWNUb29sUmVzdWx0cyxcbiAgICAgICAgICBkeW5hbWljVG9vbFJlc3VsdHM6IGxhc3RTdGVwLmR5bmFtaWNUb29sUmVzdWx0cyxcbiAgICAgICAgICByZXF1ZXN0OiBsYXN0U3RlcC5yZXF1ZXN0LFxuICAgICAgICAgIHJlc3BvbnNlOiBsYXN0U3RlcC5yZXNwb25zZSxcbiAgICAgICAgICB3YXJuaW5nczogbGFzdFN0ZXAud2FybmluZ3MsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbGFzdFN0ZXAucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IHJlc29sdmVkT3V0cHV0O1xuICAgICAgICBpZiAobGFzdFN0ZXAuZmluaXNoUmVhc29uID09PSBcInN0b3BcIikge1xuICAgICAgICAgIGNvbnN0IG91dHB1dFNwZWNpZmljYXRpb24gPSBvdXRwdXQgIT0gbnVsbCA/IG91dHB1dCA6IHRleHQoKTtcbiAgICAgICAgICByZXNvbHZlZE91dHB1dCA9IGF3YWl0IG91dHB1dFNwZWNpZmljYXRpb24ucGFyc2VDb21wbGV0ZU91dHB1dChcbiAgICAgICAgICAgIHsgdGV4dDogbGFzdFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXNwb25zZTogbGFzdFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHVzYWdlOiBsYXN0U3RlcC51c2FnZSxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgdG90YWxVc2FnZSxcbiAgICAgICAgICBvdXRwdXQ6IHJlc29sdmVkT3V0cHV0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IHdyYXBHYXRld2F5RXJyb3IoZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICBleHBlcmltZW50YWxfY29udGV4dFxufSkge1xuICBjb25zdCB0b29sT3V0cHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoXG4gICAgICBhc3luYyAodG9vbENhbGwpID0+IGV4ZWN1dGVUb29sQ2FsbCh7XG4gICAgICAgIHRvb2xDYWxsLFxuICAgICAgICB0b29scyxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICByZXR1cm4gdG9vbE91dHB1dHMuZmlsdGVyKFxuICAgIChvdXRwdXQpID0+IG91dHB1dCAhPSBudWxsXG4gICk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuX291dHB1dCA9IG9wdGlvbnMub3V0cHV0O1xuICAgIHRoaXMudG90YWxVc2FnZSA9IG9wdGlvbnMudG90YWxVc2FnZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzW3RoaXMuc3RlcHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmNvbnRlbnQ7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRleHQ7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5maWxlcztcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVhc29uaW5nVGV4dDtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZWFzb25pbmc7XG4gIH1cbiAgZ2V0IHRvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudG9vbENhbGxzO1xuICB9XG4gIGdldCBzdGF0aWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnN0YXRpY1Rvb2xDYWxscztcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZHluYW1pY1Rvb2xDYWxscztcbiAgfVxuICBnZXQgdG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBzdGF0aWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc3RhdGljVG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zb3VyY2VzO1xuICB9XG4gIGdldCBmaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmZpbmlzaFJlYXNvbjtcbiAgfVxuICBnZXQgcmF3RmluaXNoUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yYXdGaW5pc2hSZWFzb247XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC53YXJuaW5ncztcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlc3BvbnNlO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZXF1ZXN0O1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudXNhZ2U7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9vdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICB9XG4gIGdldCBvdXRwdXQoKSB7XG4gICAgaWYgKHRoaXMuX291dHB1dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0O1xuICB9XG59O1xuZnVuY3Rpb24gYXNUb29sQ2FsbHMoY29udGVudCkge1xuICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCJcbiAgKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLm1hcCgodG9vbENhbGwpID0+ICh7XG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGFzQ29udGVudCh7XG4gIGNvbnRlbnQsXG4gIHRvb2xDYWxscyxcbiAgdG9vbE91dHB1dHMsXG4gIHRvb2xBcHByb3ZhbFJlcXVlc3RzLFxuICB0b29sc1xufSkge1xuICBjb25zdCBjb250ZW50UGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjpcbiAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY29udGVudFBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHBhcnQpLFxuICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICBjb250ZW50UGFydHMucHVzaChcbiAgICAgICAgICB0b29sQ2FsbHMuZmluZCgodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXTtcbiAgICAgICAgICBjb25zdCBzdXBwb3J0c0RlZmVycmVkUmVzdWx0cyA9ICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cztcbiAgICAgICAgICBpZiAoIXN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgY2FsbCAke3BhcnQudG9vbENhbGxJZH0gbm90IGZvdW5kLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBlcnJvcjogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHBhcnQuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICBkeW5hbWljOiBwYXJ0LmR5bmFtaWNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIGVycm9yOiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICBkeW5hbWljOiB0b29sQ2FsbC5keW5hbWljXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjoge1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5jb250ZW50UGFydHMsIC4uLnRvb2xPdXRwdXRzLCAuLi50b29sQXBwcm92YWxSZXF1ZXN0c107XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5pbXBvcnQge1xuICBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlNyxcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIsXG4gIERlbGF5ZWRQcm9taXNlLFxuICBpc0Fib3J0RXJyb3IgYXMgaXNBYm9ydEVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKSB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRIZWFkZXJzKSkge1xuICAgIGlmICghcmVzcG9uc2VIZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzcG9uc2VIZWFkZXJzO1xufVxuXG4vLyBzcmMvdGV4dC1zdHJlYW0vY3JlYXRlLXRleHQtc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgIHN0YXR1czogc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICBjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDA7XG4gIGlmIChzdGF0dXNUZXh0ICE9PSB2b2lkIDApIHtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCwgaGVhZGVycyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IGNhbkNvbnRpbnVlID0gcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgICBpZiAoIWNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUzKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZS5vbmNlKFwiZHJhaW5cIiwgcmVzb2x2ZTMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gc3JjL3RleHQtc3RyZWFtL3BpcGUtdGV4dC1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogdGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgfSk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9qc29uLXRvLXNzZS10cmFuc2Zvcm0tc3RyZWFtLnRzXG52YXIgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2Zvcm0ocGFydCwgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkocGFydCl9XG5cbmApO1xuICAgICAgfSxcbiAgICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFwiZGF0YTogW0RPTkVdXFxuXFxuXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1zdHJlYW0taGVhZGVycy50c1xudmFyIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMgPSB7XG4gIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgXCJjYWNoZS1jb250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgY29ubmVjdGlvbjogXCJrZWVwLWFsaXZlXCIsXG4gIFwieC12ZXJjZWwtYWktdWktbWVzc2FnZS1zdHJlYW1cIjogXCJ2MVwiLFxuICBcIngtYWNjZWwtYnVmZmVyaW5nXCI6IFwibm9cIlxuICAvLyBkaXNhYmxlIG5naW54IGJ1ZmZlcmluZ1xufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbSxcbiAgY29uc3VtZVNzZVN0cmVhbVxufSkge1xuICBsZXQgc3NlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIGlmIChjb25zdW1lU3NlU3RyZWFtKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gc3NlU3RyZWFtLnRlZSgpO1xuICAgIHNzZVN0cmVhbSA9IHN0cmVhbTE7XG4gICAgY29uc3VtZVNzZVN0cmVhbSh7IHN0cmVhbTogc3RyZWFtMiB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKHNzZVN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTKVxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2dldC1yZXNwb25zZS11aS1tZXNzYWdlLWlkLnRzXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVJTWVzc2FnZUlkKHtcbiAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgcmVzcG9uc2VNZXNzYWdlSWRcbn0pIHtcbiAgaWYgKG9yaWdpbmFsTWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2VzW29yaWdpbmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiID8gbGFzdE1lc3NhZ2UuaWQgOiB0eXBlb2YgcmVzcG9uc2VNZXNzYWdlSWQgPT09IFwiZnVuY3Rpb25cIiA/IHJlc3BvbnNlTWVzc2FnZUlkKCkgOiByZXNwb25zZU1lc3NhZ2VJZDtcbn1cblxuLy8gc3JjL3VpL3Byb2Nlc3MtdWktbWVzc2FnZS1zdHJlYW0udHNcbmltcG9ydCB7IHZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1jaHVua3MudHNcbmltcG9ydCB7IHogYXMgejcgfSBmcm9tIFwiem9kL3Y0XCI7XG5pbXBvcnQgeyBsYXp5U2NoZW1hLCB6b2RTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIHVpTWVzc2FnZUNodW5rU2NoZW1hID0gbGF6eVNjaGVtYShcbiAgKCkgPT4gem9kU2NoZW1hKFxuICAgIHo3LnVuaW9uKFtcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LXN0YXJ0XCIpLFxuICAgICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1kZWx0YVwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1lbmRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJlcnJvclwiKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1zdGFydFwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWRlbHRhXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgaW5wdXRUZXh0RGVsdGE6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgaW5wdXQ6IHo3LnVua25vd24oKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWVycm9yXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSxcbiAgICAgICAgYXBwcm92YWxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLW91dHB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBvdXRwdXQ6IHo3LnVua25vd24oKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBwcmVsaW1pbmFyeTogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWVycm9yXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLW91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctc3RhcnRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctZGVsdGFcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZGVsdGE6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1lbmRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzb3VyY2UtdXJsXCIpLFxuICAgICAgICBzb3VyY2VJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgICAgICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBtZWRpYVR5cGU6IHo3LnN0cmluZygpLFxuICAgICAgICB0aXRsZTogejcuc3RyaW5nKCksXG4gICAgICAgIGZpbGVuYW1lOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImZpbGVcIiksXG4gICAgICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5jdXN0b20oXG4gICAgICAgICAgKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICAgICAgICAgIHsgbWVzc2FnZTogJ1R5cGUgbXVzdCBzdGFydCB3aXRoIFwiZGF0YS1cIicgfVxuICAgICAgICApLFxuICAgICAgICBpZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZGF0YTogejcudW5rbm93bigpLFxuICAgICAgICB0cmFuc2llbnQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzdGFydC1zdGVwXCIpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2gtc3RlcFwiKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwic3RhcnRcIiksXG4gICAgICAgIG1lc3NhZ2VJZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmluaXNoXCIpLFxuICAgICAgICBmaW5pc2hSZWFzb246IHo3LmVudW0oW1xuICAgICAgICAgIFwic3RvcFwiLFxuICAgICAgICAgIFwibGVuZ3RoXCIsXG4gICAgICAgICAgXCJjb250ZW50LWZpbHRlclwiLFxuICAgICAgICAgIFwidG9vbC1jYWxsc1wiLFxuICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICBcIm90aGVyXCJcbiAgICAgICAgXSkub3B0aW9uYWwoKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiYWJvcnRcIiksXG4gICAgICAgIHJlYXNvbjogejcuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwibWVzc2FnZS1tZXRhZGF0YVwiKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKClcbiAgICAgIH0pXG4gICAgXSlcbiAgKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVVJTWVzc2FnZUNodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKTtcbn1cblxuLy8gc3JjL3VpL3VpLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBpc0RhdGFVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiO1xufVxuZnVuY3Rpb24gaXNGaWxlVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmaWxlXCI7XG59XG5mdW5jdGlvbiBpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCI7XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiO1xufVxuZnVuY3Rpb24gaXNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIGlzU3RhdGljVG9vbFVJUGFydChwYXJ0KSB8fCBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpO1xufVxudmFyIGlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQgPSBpc1Rvb2xVSVBhcnQ7XG5mdW5jdGlvbiBnZXRTdGF0aWNUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3BsaXQoXCItXCIpLnNsaWNlKDEpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbE5hbWUocGFydCkge1xuICByZXR1cm4gaXNEeW5hbWljVG9vbFVJUGFydChwYXJ0KSA/IHBhcnQudG9vbE5hbWUgOiBnZXRTdGF0aWNUb29sTmFtZShwYXJ0KTtcbn1cbnZhciBnZXRUb29sT3JEeW5hbWljVG9vbE5hbWUgPSBnZXRUb29sTmFtZTtcblxuLy8gc3JjL3VpL3Byb2Nlc3MtdWktbWVzc2FnZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgbGFzdE1lc3NhZ2UsXG4gIG1lc3NhZ2VJZFxufSkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCIgPyBsYXN0TWVzc2FnZSA6IHtcbiAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICBtZXRhZGF0YTogdm9pZCAwLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIHBhcnRzOiBbXVxuICAgIH0sXG4gICAgYWN0aXZlVGV4dFBhcnRzOiB7fSxcbiAgICBhY3RpdmVSZWFzb25pbmdQYXJ0czoge30sXG4gICAgcGFydGlhbFRvb2xDYWxsczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgZGF0YVBhcnRTY2hlbWFzLFxuICBydW5VcGRhdGVNZXNzYWdlSm9iLFxuICBvbkVycm9yLFxuICBvblRvb2xDYWxsLFxuICBvbkRhdGFcbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBhd2FpdCBydW5VcGRhdGVNZXNzYWdlSm9iKGFzeW5jICh7IHN0YXRlLCB3cml0ZSB9KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VG9vbEludm9jYXRpb24odG9vbENhbGxJZCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gdG9vbEludm9jYXRpb25zLmZpbmQoXG4gICAgICAgICAgICAgIChpbnZvY2F0aW9uKSA9PiBpbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbEludm9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgICAgICAgICBjaHVua0lkOiB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyB0b29sIGludm9jYXRpb24gZm91bmQgZm9yIHRvb2wgY2FsbCBJRCBcIiR7dG9vbENhbGxJZH1cIi5gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwYXJ0MikgPT4gaXNTdGF0aWNUb29sVUlQYXJ0KHBhcnQyKSAmJiBwYXJ0Mi50b29sQ2FsbElkID09PSBvcHRpb25zLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBhbnlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGFueVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJ0LnN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcbiAgICAgICAgICAgICAgYW55UGFydC5pbnB1dCA9IGFueU9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQub3V0cHV0ID0gYW55T3B0aW9ucy5vdXRwdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQuZXJyb3JUZXh0ID0gYW55T3B0aW9ucy5lcnJvclRleHQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucmF3SW5wdXQgPSBhbnlPcHRpb25zLnJhd0lucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByZWxpbWluYXJ5ID0gYW55T3B0aW9ucy5wcmVsaW1pbmFyeTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGFueVBhcnQudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFueVBhcnQucHJvdmlkZXJFeGVjdXRlZCA9IChfYTE4ID0gYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkKSAhPSBudWxsID8gX2ExOCA6IHBhcnQucHJvdmlkZXJFeGVjdXRlZDtcbiAgICAgICAgICAgICAgaWYgKGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSA9IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBgdG9vbC0ke29wdGlvbnMudG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICByYXdJbnB1dDogYW55T3B0aW9ucy5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2ExOCwgX2IyO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBwYXJ0Mi50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LnRvb2xOYW1lID0gb3B0aW9ucy50b29sTmFtZTtcbiAgICAgICAgICAgICAgYW55UGFydC5pbnB1dCA9IGFueU9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQub3V0cHV0ID0gYW55T3B0aW9ucy5vdXRwdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQuZXJyb3JUZXh0ID0gYW55T3B0aW9ucy5lcnJvclRleHQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucmF3SW5wdXQgPSAoX2ExOCA9IGFueU9wdGlvbnMucmF3SW5wdXQpICE9IG51bGwgPyBfYTE4IDogYW55UGFydC5yYXdJbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5wcmVsaW1pbmFyeSA9IGFueU9wdGlvbnMucHJlbGltaW5hcnk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBhbnlQYXJ0LnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbnlQYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPSAoX2IyID0gYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkKSAhPSBudWxsID8gX2IyIDogcGFydC5wcm92aWRlckV4ZWN1dGVkO1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhID0gYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pYy10b29sXCIsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IG9wdGlvbnMudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3B0aW9ucy50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0OiBhbnlPcHRpb25zLmlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dDogYW55T3B0aW9ucy5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBhbnlPcHRpb25zLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICAgICAgLi4uYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IGNhbGxQcm92aWRlck1ldGFkYXRhOiBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVNZXNzYWdlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lcmdlZE1ldGFkYXRhID0gc3RhdGUubWVzc2FnZS5tZXRhZGF0YSAhPSBudWxsID8gbWVyZ2VPYmplY3RzKHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEsIG1ldGFkYXRhKSA6IG1ldGFkYXRhO1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZU1ldGFkYXRhU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXJnZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogbWVzc2FnZU1ldGFkYXRhU2NoZW1hXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5tZXRhZGF0YSA9IG1lcmdlZE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcInN0cmVhbWluZ1wiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF0gPSB0ZXh0UGFydDtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0ID0gc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgaWYgKHRleHRQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRleHQtZGVsdGEgZm9yIG1pc3NpbmcgdGV4dCBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInRleHQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0ZXh0LWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0UGFydC50ZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAodGV4dFBhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRleHQtZW5kIGZvciBtaXNzaW5nIHRleHQgcGFydCB3aXRoIElEIFwiJHtjaHVuay5pZH1cIi4gRW5zdXJlIGEgXCJ0ZXh0LXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwidGV4dC1lbmRcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2IgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2IgOiB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF0gPSByZWFzb25pbmdQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2gocmVhc29uaW5nUGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgcmVhc29uaW5nLWRlbHRhIGZvciBtaXNzaW5nIHJlYXNvbmluZyBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInJlYXNvbmluZy1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInJlYXNvbmluZy1kZWx0YVwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC50ZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2MgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2MgOiByZWFzb25pbmdQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmdQYXJ0ID0gc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCByZWFzb25pbmctZW5kIGZvciBtaXNzaW5nIHJlYXNvbmluZyBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInJlYXNvbmluZy1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInJlYXNvbmluZy1lbmRcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfZCA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfZCA6IHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5zdGF0ZSA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IGNodW5rLnVybFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlLXVybFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtdXJsXCIsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGNodW5rLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtZG9jdW1lbnRcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlLWRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGNodW5rLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogY2h1bmsuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKGlzU3RhdGljVG9vbFVJUGFydCk7XG4gICAgICAgICAgICAgIHN0YXRlLnBhcnRpYWxUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRvb2xJbnZvY2F0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZHluYW1pYzogY2h1bmsuZHluYW1pYyxcbiAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGUsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGUsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxUb29sQ2FsbCA9IHN0YXRlLnBhcnRpYWxUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF07XG4gICAgICAgICAgICAgIGlmIChwYXJ0aWFsVG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidG9vbC1pbnB1dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCB0b29sLWlucHV0LWRlbHRhIGZvciBtaXNzaW5nIHRvb2wgY2FsbCB3aXRoIElEIFwiJHtjaHVuay50b29sQ2FsbElkfVwiLiBFbnN1cmUgYSBcInRvb2wtaW5wdXQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0b29sLWlucHV0LWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSBjaHVuay5pbnB1dFRleHREZWx0YTtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbC5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydGlhbEFyZ3MsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydGlhbFRvb2xDYWxsLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0aWFsQXJncyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0aWFsVG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBpZiAob25Ub29sQ2FsbCAmJiAhY2h1bmsucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLnN0YXRlID0gXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIjtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uYXBwcm92YWwgPSB7IGlkOiBjaHVuay5hcHByb3ZhbElkIH07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLnN0YXRlID0gXCJvdXRwdXQtZGVuaWVkXCI7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbi50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEludm9jYXRpb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbEludm9jYXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6IGNodW5rLm91dHB1dCxcbiAgICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBjaHVuay5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogdG9vbEludm9jYXRpb24udGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFN0YXRpY1Rvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogY2h1bmsub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBjaHVuay5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sSW52b2NhdGlvbi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBnZXRTdGF0aWNUb29sTmFtZSh0b29sSW52b2NhdGlvbiksXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIHJhd0lucHV0OiB0b29sSW52b2NhdGlvbi5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0YXJ0LXN0ZXBcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goeyB0eXBlOiBcInN0ZXAtc3RhcnRcIiB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoLXN0ZXBcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0UGFydHMgPSB7fTtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHMgPSB7fTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLmlkID0gY2h1bmsubWVzc2FnZUlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShjaHVuay5tZXNzYWdlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZUlkICE9IG51bGwgfHwgY2h1bmsubWVzc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5maW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKG5ldyBFcnJvcihjaHVuay5lcnJvclRleHQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGlmIChpc0RhdGFVSU1lc3NhZ2VDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGFQYXJ0U2NoZW1hcyA9PSBudWxsID8gdm9pZCAwIDogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDaHVuay50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVSVBhcnQgPSBkYXRhQ2h1bmsuaWQgIT0gbnVsbCA/IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgICAgIChjaHVua0FyZykgPT4gZGF0YUNodW5rLnR5cGUgPT09IGNodW5rQXJnLnR5cGUgJiYgZGF0YUNodW5rLmlkID09PSBjaHVua0FyZy5pZFxuICAgICAgICAgICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVUlQYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVUlQYXJ0LmRhdGEgPSBkYXRhQ2h1bmsuZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vaGFuZGxlLXVpLW1lc3NhZ2Utc3RyZWFtLWZpbmlzaC50c1xuZnVuY3Rpb24gaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgbWVzc2FnZUlkLFxuICBvcmlnaW5hbE1lc3NhZ2VzID0gW10sXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBzdHJlYW1cbn0pIHtcbiAgbGV0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsID8gdm9pZCAwIDogb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIGxhc3RNZXNzYWdlID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICB9XG4gIGxldCBpc0Fib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgaWRJbmplY3RlZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGlmIChzdGFydENodW5rLm1lc3NhZ2VJZCA9PSBudWxsICYmIG1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydENodW5rLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgIGlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAob25GaW5pc2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBpZEluamVjdGVkU3RyZWFtO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB2b2lkIDAsXG4gICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQgIT0gbnVsbCA/IG1lc3NhZ2VJZCA6IFwiXCJcbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0cmVhbVxuICB9KTtcbiAgY29uc3QgcnVuVXBkYXRlTWVzc2FnZUpvYiA9IGFzeW5jIChqb2IpID0+IHtcbiAgICBhd2FpdCBqb2IoeyBzdGF0ZSwgd3JpdGU6ICgpID0+IHtcbiAgICB9IH0pO1xuICB9O1xuICBsZXQgZmluaXNoQ2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGNhbGxPbkZpbmlzaCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoZmluaXNoQ2FsbGVkIHx8ICFvbkZpbmlzaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5pc2hDYWxsZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQ29udGludWF0aW9uID0gc3RhdGUubWVzc2FnZS5pZCA9PT0gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5pZCk7XG4gICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNDb250aW51YXRpb24sXG4gICAgICByZXNwb25zZU1lc3NhZ2U6IHN0YXRlLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAuLi5pc0NvbnRpbnVhdGlvbiA/IG9yaWdpbmFsTWVzc2FnZXMuc2xpY2UoMCwgLTEpIDogb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgc3RhdGUubWVzc2FnZVxuICAgICAgXSxcbiAgICAgIGZpbmlzaFJlYXNvbjogc3RhdGUuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICBzdHJlYW06IGlkSW5qZWN0ZWRTdHJlYW0sXG4gICAgcnVuVXBkYXRlTWVzc2FnZUpvYixcbiAgICBvbkVycm9yXG4gIH0pLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW5jZWwgaXMgc3RpbGwgbmV3IGFuZCBtaXNzaW5nIGZyb20gdHlwZXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zZm9ybVN0cmVhbSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgY2FsbE9uRmluaXNoKCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGF3YWl0IGNhbGxPbkZpbmlzaCgpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9waXBlLXVpLW1lc3NhZ2Utc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbSxcbiAgY29uc3VtZVNzZVN0cmVhbVxufSkge1xuICBsZXQgc3NlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIGlmIChjb25zdW1lU3NlU3RyZWFtKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gc3NlU3RyZWFtLnRlZSgpO1xuICAgIHNzZVN0cmVhbSA9IHN0cmVhbTE7XG4gICAgY29uc3VtZVNzZVN0cmVhbSh7IHN0cmVhbTogc3RyZWFtMiB9KTtcbiAgfVxuICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMpLmVudHJpZXMoKVxuICAgICksXG4gICAgc3RyZWFtOiBzc2VTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBhc3luYyBmdW5jdGlvbiBjbGVhbnVwKGNhbmNlbFN0cmVhbSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjYW5jZWxTdHJlYW0pIHtcbiAgICAgICAgICBhd2FpdCAoKF9hMTcgPSByZWFkZXIuY2FuY2VsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHJlYWRlcikpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogUmVhZHMgdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV4dCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBNYXkgYmUgY2FsbGVkIG9uIGVhcmx5IGV4aXQgKGUuZy4sIGJyZWFrIGZyb20gZm9yLWF3YWl0KSBvciBhZnRlciBjb21wbGV0aW9uLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZC5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSBjb21wbGV0ZWQgSXRlcmF0b3JSZXN1bHQuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIG9uIGVhcmx5IGV4aXQgd2l0aCBlcnJvci5cbiAgICAgICAqIEVuc3VyZXMgdGhlIHN0cmVhbSBpcyBjYW5jZWxsZWQgYW5kIHJlc291cmNlcyBhcmUgcmVsZWFzZWQsIHRoZW4gcmV0aHJvd3MgdGhlIGVycm9yLlxuICAgICAgICogQHBhcmFtIGVyciBUaGUgZXJyb3IgdG8gdGhyb3cuXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZWplY3RzIHdpdGggdGhlIHByb3ZpZGVkIGVycm9yLlxuICAgICAgICovXG4gICAgICBhc3luYyB0aHJvdyhlcnIpIHtcbiAgICAgICAgYXdhaXQgY2xlYW51cCh0cnVlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8vIHNyYy91dGlsL2NvbnN1bWUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvbkVycm9yXG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmUzO1xuICBsZXQgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZTMgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUzLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBjb25zdCB0ZXJtaW5hdGUgPSAoKSA9PiB7XG4gICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgIGlubmVyU3RyZWFtUmVhZGVycy5mb3JFYWNoKChyZWFkZXIpID0+IHJlYWRlci5jYW5jZWwoKSk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTmV3U3RyZWFtLnByb21pc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzc1B1bGwoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDAgJiYgaXNDbG9zZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIHRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJQYXJhbTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBwcm9jZXNzUHVsbCxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgaW5uZXJTdHJlYW1SZWFkZXJzKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICAgICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSksXG4gICAgYWRkU3RyZWFtOiAoaW5uZXJTdHJlYW0pID0+IHtcbiAgICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGlubmVyIHN0cmVhbTogb3V0ZXIgc3RyZWFtIGlzIGNsb3NlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5wdXNoKGlubmVyU3RyZWFtLmdldFJlYWRlcigpKTtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR3JhY2VmdWxseSBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLiBUaGlzIHdpbGwgbGV0IHRoZSBpbm5lciBzdHJlYW1zXG4gICAgICogZmluaXNoIHByb2Nlc3NpbmcgYW5kIHRoZW4gY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLiBUaGlzIHdpbGwgY2FuY2VsIGFsbCBpbm5lciBzdHJlYW1zXG4gICAgICogYW5kIGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uXG4gICAgICovXG4gICAgdGVybWluYXRlXG4gIH07XG59XG5cbi8vIHNyYy91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExNywgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9ydW4tdG9vbHMtdHJhbnNmb3JtYXRpb24udHNcbmltcG9ydCB7XG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U2XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgdG9vbHMsXG4gIGdlbmVyYXRvclN0cmVhbSxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICByZXBhaXJUb29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG59KSB7XG4gIGxldCB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICBjb25zdCB0b29sUmVzdWx0c1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9vbElucHV0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRvb2xDYWxsc0J5VG9vbENhbGxJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBjYW5DbG9zZSA9IGZhbHNlO1xuICBsZXQgZmluaXNoQ2h1bmsgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGF0dGVtcHRDbG9zZSgpIHtcbiAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoZmluaXNoQ2h1bmsgIT0gbnVsbCkge1xuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShmaW5pc2hDaHVuayk7XG4gICAgICB9XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJlYW0tc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOlxuICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lbmRcIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGZpbGU6IG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZVdpdGhUeXBlKHtcbiAgICAgICAgICAgICAgZGF0YTogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgICAgbWVkaWFUeXBlOiBjaHVuay5tZWRpYVR5cGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgZmluaXNoQ2h1bmsgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLnJhdyxcbiAgICAgICAgICAgIHVzYWdlOiBhc0xhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSksXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxsc0J5VG9vbENhbGxJZC5nZXQoY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IFRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IGNodW5rLmFwcHJvdmFsSWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgYXBwcm92YWxJZDogY2h1bmsuYXBwcm92YWxJZCxcbiAgICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gYXdhaXQgcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvb2xDYWxsc0J5VG9vbENhbGxJZC5zZXQodG9vbENhbGwudG9vbENhbGxJZCwgdG9vbENhbGwpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGlmICh0b29sQ2FsbC5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGdldEVycm9yTWVzc2FnZTYodG9vbENhbGwuZXJyb3IpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xDYWxsLnRpdGxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvb2wyLm9uSW5wdXRBdmFpbGFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBhd2FpdCB0b29sMi5vbklucHV0QXZhaWxhYmxlKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhd2FpdCBpc0FwcHJvdmFsTmVlZGVkKHtcbiAgICAgICAgICAgICAgdG9vbDogdG9vbDIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbElucHV0cy5zZXQodG9vbENhbGwudG9vbENhbGxJZCwgdG9vbENhbGwuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCAmJiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQyKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIGV4ZWN1dGVUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgICAgICAgICBvblByZWxpbWluYXJ5VG9vbFJlc3VsdDogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAoY2h1bmsuaXNFcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGNodW5rLnJlc3VsdCxcbiAgICAgICAgICAgICAgZHluYW1pYzogY2h1bmsuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IGNodW5rLmR5bmFtaWNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgdGltZW91dCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dCxcbiAgb3V0cHV0ID0gZXhwZXJpbWVudGFsX291dHB1dCxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBwcmVwYXJlU3RlcCxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGFjdGl2ZVRvb2xzID0gZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICBpbmNsdWRlUmF3Q2h1bmtzID0gZmFsc2UsXG4gIG9uQ2h1bmssXG4gIG9uRXJyb3IgPSAoeyBlcnJvciB9KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH0sXG4gIG9uRmluaXNoLFxuICBvbkFib3J0LFxuICBvblN0ZXBGaW5pc2gsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBfaW50ZXJuYWw6IHsgbm93OiBub3cyID0gbm93LCBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDIgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwVGltZW91dE1zID0gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3QgY2h1bmtUaW1lb3V0TXMgPSBnZXRDaHVua1RpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcEFib3J0Q29udHJvbGxlciA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHZvaWQgMDtcbiAgY29uc3QgY2h1bmtBYm9ydENvbnRyb2xsZXIgPSBjaHVua1RpbWVvdXRNcyAhPSBudWxsID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICBtb2RlbDogcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWwpLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWw6IG1lcmdlQWJvcnRTaWduYWxzKFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICB0b3RhbFRpbWVvdXRNcyAhPSBudWxsID8gQWJvcnRTaWduYWwudGltZW91dCh0b3RhbFRpbWVvdXRNcykgOiB2b2lkIDAsXG4gICAgICBzdGVwQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBzdGVwQWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGNodW5rQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjaHVua0Fib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApLFxuICAgIHN0ZXBUaW1lb3V0TXMsXG4gICAgc3RlcEFib3J0Q29udHJvbGxlcixcbiAgICBjaHVua1RpbWVvdXRNcyxcbiAgICBjaHVua0Fib3J0Q29udHJvbGxlcixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zOiBhc0FycmF5KHN0b3BXaGVuKSxcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHByZXBhcmVTdGVwLFxuICAgIGluY2x1ZGVSYXdDaHVua3MsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCkge1xuICBsZXQgZmlyc3RUZXh0Q2h1bmtJZCA9IHZvaWQgMDtcbiAgbGV0IHRleHQyID0gXCJcIjtcbiAgbGV0IHRleHRDaHVuayA9IFwiXCI7XG4gIGxldCB0ZXh0UHJvdmlkZXJNZXRhZGF0YSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDoge1xuICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgaWQ6IGZpcnN0VGV4dENodW5rSWQsXG4gICAgICAgIHRleHQ6IHRleHRDaHVuayxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogdGV4dFByb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH0sXG4gICAgICBwYXJ0aWFsT3V0cHV0XG4gICAgfSk7XG4gICAgdGV4dENodW5rID0gXCJcIjtcbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcImZpbmlzaC1zdGVwXCIgJiYgdGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LXN0YXJ0XCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFRleHRDaHVua0lkID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RUZXh0Q2h1bmtJZCA9IGNodW5rLmlkO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5pZCAhPT0gZmlyc3RUZXh0Q2h1bmtJZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZXh0MiArPSBjaHVuay50ZXh0O1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHQ7XG4gICAgICB0ZXh0UHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB0ZXh0UHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG91dHB1dC5wYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5wYXJ0aWFsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRKc29uICE9PSBsYXN0UHVibGlzaGVkSnNvbikge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBwYXJ0aWFsT3V0cHV0OiByZXN1bHQucGFydGlhbCB9KTtcbiAgICAgICAgICBsYXN0UHVibGlzaGVkSnNvbiA9IGN1cnJlbnRKc29uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3RlcFRpbWVvdXRNcyxcbiAgICBzdGVwQWJvcnRDb250cm9sbGVyLFxuICAgIGNodW5rVGltZW91dE1zLFxuICAgIGNodW5rQWJvcnRDb250cm9sbGVyLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZSxcbiAgICB0cmFuc2Zvcm1zLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zLFxuICAgIG91dHB1dCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcHJlcGFyZVN0ZXAsXG4gICAgaW5jbHVkZVJhd0NodW5rcyxcbiAgICBub3c6IG5vdzIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgfSkge1xuICAgIHRoaXMuX3RvdGFsVXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9yYXdGaW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9zdGVwcyA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMub3V0cHV0U3BlY2lmaWNhdGlvbiA9IG91dHB1dDtcbiAgICB0aGlzLmluY2x1ZGVSYXdDaHVua3MgPSBpbmNsdWRlUmF3Q2h1bmtzO1xuICAgIHRoaXMudG9vbHMgPSB0b29scztcbiAgICBsZXQgc3RlcEZpbmlzaDtcbiAgICBsZXQgcmVjb3JkZWRDb250ZW50ID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgbGV0IHJlY29yZGVkRmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFJhd0ZpbmlzaFJlYXNvbiA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRUb3RhbFVzYWdlID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFJlcXVlc3QgPSB7fTtcbiAgICBsZXQgcmVjb3JkZWRXYXJuaW5ncyA9IFtdO1xuICAgIGNvbnN0IHJlY29yZGVkU3RlcHMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290U3BhbjtcbiAgICBsZXQgYWN0aXZlVGV4dENvbnRlbnQgPSB7fTtcbiAgICBsZXQgYWN0aXZlUmVhc29uaW5nQ29udGVudCA9IHt9O1xuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGNvbnN0IHsgcGFydCB9ID0gY2h1bms7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZGVsdGFcIiB8fCBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWlucHV0LXN0YXJ0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtaW5wdXQtZGVsdGFcIiB8fCBwYXJ0LnR5cGUgPT09IFwicmF3XCIpIHtcbiAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rOiBwYXJ0IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBhd2FpdCBvbkVycm9yKHsgZXJyb3I6IHdyYXBHYXRld2F5RXJyb3IocGFydC5lcnJvcikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2goYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlVGV4dCA9IGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGB0ZXh0IHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVRleHQudGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgYWN0aXZlVGV4dC5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDogYWN0aXZlVGV4dC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVRleHQgPSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgdGV4dCBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2IgPSBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYiA6IGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBkZWxldGUgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctc3RhcnRcIikge1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2goYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVJlYXNvbmluZyA9IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgcmVhc29uaW5nIHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfYyA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9jIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZW5kXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVSZWFzb25pbmcgPSBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHJlYXNvbmluZyBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfZCA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9kIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgZGVsZXRlIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaCh7IHR5cGU6IFwiZmlsZVwiLCBmaWxlOiBwYXJ0LmZpbGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgJiYgIXBhcnQucHJlbGltaW5hcnkpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInN0YXJ0LXN0ZXBcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudCA9IFtdO1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnQgPSB7fTtcbiAgICAgICAgICBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgICAgICAgIHJlY29yZGVkUmVxdWVzdCA9IHBhcnQucmVxdWVzdDtcbiAgICAgICAgICByZWNvcmRlZFdhcm5pbmdzID0gcGFydC53YXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbmlzaC1zdGVwXCIpIHtcbiAgICAgICAgICBjb25zdCBzdGVwTWVzc2FnZXMgPSBhd2FpdCB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgY29udGVudDogcmVjb3JkZWRDb250ZW50LFxuICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IG5ldyBEZWZhdWx0U3RlcFJlc3VsdCh7XG4gICAgICAgICAgICBjb250ZW50OiByZWNvcmRlZENvbnRlbnQsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBwYXJ0LnJhd0ZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiBwYXJ0LnVzYWdlLFxuICAgICAgICAgICAgd2FybmluZ3M6IHJlY29yZGVkV2FybmluZ3MsXG4gICAgICAgICAgICByZXF1ZXN0OiByZWNvcmRlZFJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAuLi5wYXJ0LnJlc3BvbnNlLFxuICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcywgLi4uc3RlcE1lc3NhZ2VzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZWNvcmRlZFdhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLnN0ZXBNZXNzYWdlcyk7XG4gICAgICAgICAgc3RlcEZpbmlzaC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgIHJlY29yZGVkVG90YWxVc2FnZSA9IHBhcnQudG90YWxVc2FnZTtcbiAgICAgICAgICByZWNvcmRlZEZpbmlzaFJlYXNvbiA9IHBhcnQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHJlY29yZGVkUmF3RmluaXNoUmVhc29uID0gcGFydC5yYXdGaW5pc2hSZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJlY29yZGVkU3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IChhYm9ydFNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkgPyBhYm9ydFNpZ25hbC5yZWFzb24gOiBuZXcgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC4gQ2hlY2sgdGhlIHN0cmVhbSBmb3IgZXJyb3JzLlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuX2ZpbmlzaFJlYXNvbi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fcmF3RmluaXNoUmVhc29uLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBzZWxmLl90b3RhbFVzYWdlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBzZWxmLl9zdGVwcy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaW5pc2hSZWFzb24gPSByZWNvcmRlZEZpbmlzaFJlYXNvbiAhPSBudWxsID8gcmVjb3JkZWRGaW5pc2hSZWFzb24gOiBcIm90aGVyXCI7XG4gICAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHJlY29yZGVkVG90YWxVc2FnZSAhPSBudWxsID8gcmVjb3JkZWRUb3RhbFVzYWdlIDogY3JlYXRlTnVsbExhbmd1YWdlTW9kZWxVc2FnZSgpO1xuICAgICAgICAgIHNlbGYuX2ZpbmlzaFJlYXNvbi5yZXNvbHZlKGZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgc2VsZi5fcmF3RmluaXNoUmVhc29uLnJlc29sdmUocmVjb3JkZWRSYXdGaW5pc2hSZWFzb24pO1xuICAgICAgICAgIHNlbGYuX3RvdGFsVXNhZ2UucmVzb2x2ZSh0b3RhbFVzYWdlKTtcbiAgICAgICAgICBzZWxmLl9zdGVwcy5yZXNvbHZlKHJlY29yZGVkU3RlcHMpO1xuICAgICAgICAgIGNvbnN0IGZpbmFsU3RlcCA9IHJlY29yZGVkU3RlcHNbcmVjb3JkZWRTdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogZmluYWxTdGVwLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogZmluYWxTdGVwLnJhd0ZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHRvdGFsVXNhZ2UsXG4gICAgICAgICAgICB1c2FnZTogZmluYWxTdGVwLnVzYWdlLFxuICAgICAgICAgICAgY29udGVudDogZmluYWxTdGVwLmNvbnRlbnQsXG4gICAgICAgICAgICB0ZXh0OiBmaW5hbFN0ZXAudGV4dCxcbiAgICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IGZpbmFsU3RlcC5yZWFzb25pbmdUZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nOiBmaW5hbFN0ZXAucmVhc29uaW5nLFxuICAgICAgICAgICAgZmlsZXM6IGZpbmFsU3RlcC5maWxlcyxcbiAgICAgICAgICAgIHNvdXJjZXM6IGZpbmFsU3RlcC5zb3VyY2VzLFxuICAgICAgICAgICAgdG9vbENhbGxzOiBmaW5hbFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgICAgc3RhdGljVG9vbENhbGxzOiBmaW5hbFN0ZXAuc3RhdGljVG9vbENhbGxzLFxuICAgICAgICAgICAgZHluYW1pY1Rvb2xDYWxsczogZmluYWxTdGVwLmR5bmFtaWNUb29sQ2FsbHMsXG4gICAgICAgICAgICB0b29sUmVzdWx0czogZmluYWxTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgc3RhdGljVG9vbFJlc3VsdHM6IGZpbmFsU3RlcC5zdGF0aWNUb29sUmVzdWx0cyxcbiAgICAgICAgICAgIGR5bmFtaWNUb29sUmVzdWx0czogZmluYWxTdGVwLmR5bmFtaWNUb29sUmVzdWx0cyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZpbmFsU3RlcC5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IGZpbmFsU3RlcC5yZXNwb25zZSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiBmaW5hbFN0ZXAud2FybmluZ3MsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBmaW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmaW5hbFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2ExNyA9IGZpbmFsU3RlcC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeShmaW5hbFN0ZXAudG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIGZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogdG90YWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiB0b3RhbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IHRvdGFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogdG90YWxVc2FnZS5jYWNoZWRJbnB1dFRva2Vuc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdGl0Y2hhYmxlU3RyZWFtID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIHRoaXMuYWRkU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW07XG4gICAgdGhpcy5jbG9zZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uY2xvc2U7XG4gICAgY29uc3QgcmVhZGVyID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgbGV0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnRcIiB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgb25BYm9ydCA9PSBudWxsID8gdm9pZCAwIDogb25BYm9ydCh7IHN0ZXBzOiByZWNvcmRlZFN0ZXBzIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImFib3J0XCIsXG4gICAgICAgICAgICAvLyBUaGUgYHJlYXNvbmAgaXMgdXN1YWxseSBvZiB0eXBlIERPTUV4Y2VwdGlvbiwgYnV0IGl0IGNhbiBhbHNvIGJlIG9mIGFueSB0eXBlLFxuICAgICAgICAgICAgLy8gc28gd2UgdXNlIGdldEVycm9yTWVzc2FnZSBmb3Igc2VyaWFsaXphdGlvbiBiZWNhdXNlIGl0IGlzIGFscmVhZHkgZGVzaWduZWQgdG8gYWNjZXB0IHZhbHVlcyBvZiB0aGUgdW5rbm93biB0eXBlLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWwvcmVhc29uXG4gICAgICAgICAgICAuLi4oYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlYXNvbikgIT09IHZvaWQgMCA/IHsgcmVhc29uOiBnZXRFcnJvck1lc3NhZ2U3KGFib3J0U2lnbmFsLnJlYXNvbikgfSA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGlzQWJvcnRFcnJvcjIoZXJyb3IpICYmIChhYm9ydFNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtIG9mIHRyYW5zZm9ybXMpIHtcbiAgICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgdHJhbnNmb3JtKHtcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBzdG9wU3RyZWFtKCkge1xuICAgICAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCAhPSBudWxsID8gb3V0cHV0IDogdGV4dCgpKSkucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uY2FsbFNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgICB9KTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbkFyZykgPT4ge1xuICAgICAgICByb290U3BhbiA9IHJvb3RTcGFuQXJnO1xuICAgICAgICBjb25zdCBpbml0aWFsUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlcyA9IGluaXRpYWxQcm9tcHQubWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICAgIGNvbnN0IHsgYXBwcm92ZWRUb29sQXBwcm92YWxzLCBkZW5pZWRUb29sQXBwcm92YWxzIH0gPSBjb2xsZWN0VG9vbEFwcHJvdmFscyh7IG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMgfSk7XG4gICAgICAgIGlmIChkZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDAgfHwgYXBwcm92ZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyA9IFtcbiAgICAgICAgICAgIC4uLmFwcHJvdmVkVG9vbEFwcHJvdmFscyxcbiAgICAgICAgICAgIC4uLmRlbmllZFRvb2xBcHByb3ZhbHNcbiAgICAgICAgICBdLmZpbHRlcigodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCk7XG4gICAgICAgICAgY29uc3QgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMgPSBhcHByb3ZlZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gIXRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMgPSBkZW5pZWRUb29sQXBwcm92YWxzLmZpbHRlcihcbiAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICF0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZGVuaWVkUHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMgPSBkZW5pZWRUb29sQXBwcm92YWxzLmZpbHRlcihcbiAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+IHRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbSh0b29sRXhlY3V0aW9uU3RlcFN0cmVhbSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbEFwcHJvdmFsIG9mIFtcbiAgICAgICAgICAgICAgLi4ubG9jYWxEZW5pZWRUb29sQXBwcm92YWxzLFxuICAgICAgICAgICAgICAuLi5kZW5pZWRQcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFsc1xuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWRlbmllZFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzLm1hcChhc3luYyAodG9vbEFwcHJvdmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsOiB0b29sQXBwcm92YWwudG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgb25QcmVsaW1pbmFyeVRvb2xSZXN1bHQ6IChyZXN1bHQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyLmVucXVldWUocmVzdWx0Mik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB0b29sT3V0cHV0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzLm1hcChcbiAgICAgICAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZhbElkLFxuICAgICAgICAgICAgICAgICAgICBhcHByb3ZlZDogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbE91dHB1dHMubGVuZ3RoID4gMCB8fCBsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhbFRvb2xDb250ZW50ID0gW107XG4gICAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0MiBvZiB0b29sT3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGxvY2FsVG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogb3V0cHV0Mi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3V0cHV0Mi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogb3V0cHV0Mi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW291dHB1dDIudG9vbE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gb3V0cHV0Mi5vdXRwdXQgOiBvdXRwdXQyLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIgPyBcImpzb25cIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbEFwcHJvdmFsIG9mIGxvY2FsRGVuaWVkVG9vbEFwcHJvdmFscykge1xuICAgICAgICAgICAgICAgIGxvY2FsVG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJleGVjdXRpb24tZGVuaWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5pdGlhbFJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogbG9jYWxUb29sQ29udGVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzLnB1c2goLi4uaW5pdGlhbFJlc3BvbnNlTWVzc2FnZXMpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdGVwKHtcbiAgICAgICAgICBjdXJyZW50U3RlcCxcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlXG4gICAgICAgIH0pIHtcbiAgICAgICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgIGNvbnN0IGluY2x1ZGVSYXdDaHVua3MyID0gc2VsZi5pbmNsdWRlUmF3Q2h1bmtzO1xuICAgICAgICAgIGNvbnN0IHN0ZXBUaW1lb3V0SWQgPSBzdGVwVGltZW91dE1zICE9IG51bGwgPyBzZXRUaW1lb3V0KCgpID0+IHN0ZXBBYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgc3RlcFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgICAgICAgbGV0IGNodW5rVGltZW91dElkID0gdm9pZCAwO1xuICAgICAgICAgIGZ1bmN0aW9uIHJlc2V0Q2h1bmtUaW1lb3V0KCkge1xuICAgICAgICAgICAgaWYgKGNodW5rVGltZW91dE1zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmtUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNodW5rVGltZW91dElkID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiBjaHVua0Fib3J0Q29udHJvbGxlci5hYm9ydCgpLFxuICAgICAgICAgICAgICAgIGNodW5rVGltZW91dE1zXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyQ2h1bmtUaW1lb3V0KCkge1xuICAgICAgICAgICAgaWYgKGNodW5rVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rVGltZW91dElkKTtcbiAgICAgICAgICAgICAgY2h1bmtUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyU3RlcFRpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAoc3RlcFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGVwVGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RlcEZpbmlzaCA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gWy4uLmluaXRpYWxNZXNzYWdlcywgLi4ucmVzcG9uc2VNZXNzYWdlc107XG4gICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHMsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgKF9hMTcgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubW9kZWwpICE9IG51bGwgPyBfYTE3IDogbW9kZWxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiAoX2IgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2IgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9jIDogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBzdGVwTW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBhd2FpdCBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbENob2ljZTogKF9kID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnRvb2xDaG9pY2UpICE9IG51bGwgPyBfZCA6IHRvb2xDaG9pY2UsXG4gICAgICAgICAgICBhY3RpdmVUb29sczogKF9lID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmFjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2UgOiBhY3RpdmVUb29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0ID0gKF9mID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmV4cGVyaW1lbnRhbF9jb250ZXh0KSAhPSBudWxsID8gX2YgOiBleHBlcmltZW50YWxfY29udGV4dDtcbiAgICAgICAgICBjb25zdCBzdGVwUHJvdmlkZXJPcHRpb25zID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbTogc3RyZWFtMiwgcmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLmlkXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgbGFuZ3VhZ2UgbW9kZWwgbGV2ZWwgdG9vbHM6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogY2FsbFNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogY2FsbFNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IHN0ZXBNb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICB0b29sczogc3RlcFRvb2xzLFxuICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogYXdhaXQgKG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LnJlc3BvbnNlRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHN0ZXBQcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlUmF3Q2h1bmtzOiBpbmNsdWRlUmF3Q2h1bmtzMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtV2l0aFRvb2xSZXN1bHRzID0gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSByZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge307XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgICBjb25zdCBhY3RpdmVUb29sQ2FsbFRvb2xOYW1lcyA9IHt9O1xuICAgICAgICAgIGxldCBzdGVwRmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgICAgICAgIGxldCBzdGVwUmF3RmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgICAgICAgIGxldCBzdGVwVXNhZ2UgPSBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCk7XG4gICAgICAgICAgbGV0IHN0ZXBQcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgbGV0IHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBhY3RpdmVUZXh0ID0gXCJcIjtcbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgICAgIHN0cmVhbVdpdGhUb29sUmVzdWx0cy5waXBlVGhyb3VnaChcbiAgICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzIsIF9kMiwgX2UyO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaHVua1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gY2h1bmsud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0LXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MgIT0gbnVsbCA/IHdhcm5pbmdzIDogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5kZWx0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rLnByZWxpbWluYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbE91dHB1dHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sT3V0cHV0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExOCA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExOCA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iMiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iMiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MyID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jMiA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVXNhZ2UgPSBjaHVuay51c2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSYXdGaW5pc2hSZWFzb24gPSBjaHVuay5yYXdGaW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z091dHB1dFRva2Vuc1BlclNlY29uZFwiOiAxZTMgKiAoKF9kMiA9IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnMpICE9IG51bGwgPyBfZDIgOiAwKSAvIG1zVG9GaW5pc2hcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUb29sQ2FsbFRvb2xOYW1lc1tjaHVuay5pZF0gPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tjaHVuay50b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIub25JbnB1dFN0YXJ0KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0b29sMi5vbklucHV0U3RhcnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljOiAoX2UyID0gY2h1bmsuZHluYW1pYykgIT0gbnVsbCA/IF9lMiA6ICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwiZHluYW1pY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50aXRsZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIub25JbnB1dERlbHRhKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0b29sMi5vbklucHV0RGVsdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFRleHREZWx0YTogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVSYXdDaHVua3MyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGFjdGl2ZVRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KHN0ZXBQcm92aWRlck1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiBzdGVwVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2Uub3V0cHV0VG9rZW5zXCI6IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG90YWxUb2tlbnNcIjogc3RlcFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiBzdGVwVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNhY2hlZElucHV0VG9rZW5zXCI6IHN0ZXBVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbc3RlcEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2gtc3RlcFwiLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogc3RlcFJhd0ZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSwgc3RlcFVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHN0ZXBGaW5pc2gucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRUb29sT3V0cHV0cyA9IHN0ZXBUb29sT3V0cHV0cy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sT3V0cHV0KSA9PiB0b29sT3V0cHV0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHN0ZXBUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Jlc3VsdEluU3RlcCA9IHN0ZXBUb29sT3V0cHV0cy5zb21lKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG91dHB1dDIpID0+IG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiICYmIG91dHB1dDIudG9vbENhbGxJZCA9PT0gdG9vbENhbGwudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNSZXN1bHRJblN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zZXQodG9vbENhbGwudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdXRwdXQyIG9mIHN0ZXBUb29sT3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuZGVsZXRlKG91dHB1dDIudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNsZWFyU3RlcFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgIGNsZWFyQ2h1bmtUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGlmOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBUaGVyZSBhcmUgY2xpZW50IHRvb2wgY2FsbHMgdGhhdCBoYXZlIGFsbCBiZWVuIGV4ZWN1dGVkLCBPUlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBUaGVyZSBhcmUgcGVuZGluZyBkZWZlcnJlZCByZXN1bHRzIGZyb20gcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgKGNsaWVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIGNsaWVudFRvb2xPdXRwdXRzLmxlbmd0aCA9PT0gY2xpZW50VG9vbENhbGxzLmxlbmd0aCB8fCBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuc2l6ZSA+IDApICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICAgICAgICAgICAhYXdhaXQgaXNTdG9wQ29uZGl0aW9uTWV0KHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9wQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hd2FpdCB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdHJhbnNmb3JtZWQgY29udGVudCB0byBjcmVhdGUgdGhlIG1lc3NhZ2VzIGZvciB0aGUgbmV4dCBzdGVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV0uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdHJlYW1TdGVwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBjdXJyZW50U3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVXNhZ2U6IGNvbWJpbmVkVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdHJlYW1TdGVwKHtcbiAgICAgICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzOiBpbml0aWFsUmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgICB1c2FnZTogY3JlYXRlTnVsbExhbmd1YWdlTW9kZWxVc2FnZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc2VsZi5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgc2VsZi5jbG9zZVN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzdGVwcygpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHMucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLnRoZW4oKHN0ZXBzKSA9PiBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuY29udGVudCk7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLndhcm5pbmdzKTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5wcm92aWRlck1ldGFkYXRhKTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50ZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZWFzb25pbmdUZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZyk7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc291cmNlcyk7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmZpbGVzKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zdGF0aWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50b29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnVzYWdlKTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXF1ZXN0KTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVzcG9uc2UpO1xuICB9XG4gIGdldCB0b3RhbFVzYWdlKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl90b3RhbFVzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgZ2V0IHJhd0ZpbmlzaFJlYXNvbigpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fcmF3RmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLmJhc2VTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBhc3luYyBjb25zdW1lU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogdGhpcy5mdWxsU3RyZWFtLFxuICAgICAgICBvbkVycm9yOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChvcHRpb25zLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGdldCBleHBlcmltZW50YWxfcGFydGlhbE91dHB1dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWFsT3V0cHV0U3RyZWFtO1xuICB9XG4gIGdldCBwYXJ0aWFsT3V0cHV0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydGlhbE91dHB1dCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocGFydGlhbE91dHB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0aWFsT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZWxlbWVudFN0cmVhbSgpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IChfYTE3ID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCk7XG4gICAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogYGVsZW1lbnQgc3RyZWFtcyBpbiAkeyhfYyA9IChfYiA9IHRoaXMub3V0cHV0U3BlY2lmaWNhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9IG51bGwgPyBfYyA6IFwidGV4dFwifSBtb2RlYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2godHJhbnNmb3JtKSk7XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBjb25zdCBvdXRwdXQgPSAoX2ExNyA9IHRoaXMub3V0cHV0U3BlY2lmaWNhdGlvbikgIT0gbnVsbCA/IF9hMTcgOiB0ZXh0KCk7XG4gICAgICByZXR1cm4gb3V0cHV0LnBhcnNlQ29tcGxldGVPdXRwdXQoXG4gICAgICAgIHsgdGV4dDogc3RlcC50ZXh0IH0sXG4gICAgICAgIHtcbiAgICAgICAgICByZXNwb25zZTogc3RlcC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogc3RlcC51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXAuZmluaXNoUmVhc29uXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgdG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcgPSB0cnVlLFxuICAgIHNlbmRTb3VyY2VzID0gZmFsc2UsXG4gICAgc2VuZFN0YXJ0ID0gdHJ1ZSxcbiAgICBzZW5kRmluaXNoID0gdHJ1ZSxcbiAgICBvbkVycm9yID0gZ2V0RXJyb3JNZXNzYWdlN1xuICB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZU1lc3NhZ2VJZCA9IGdlbmVyYXRlTWVzc2FnZUlkICE9IG51bGwgPyBnZXRSZXNwb25zZVVJTWVzc2FnZUlkKHtcbiAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICByZXNwb25zZU1lc3NhZ2VJZDogZ2VuZXJhdGVNZXNzYWdlSWRcbiAgICB9KSA6IHZvaWQgMDtcbiAgICBjb25zdCBpc0R5bmFtaWMgPSAocGFydCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBjb25zdCB0b29sMiA9IChfYTE3ID0gdGhpcy50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTdbcGFydC50b29sTmFtZV07XG4gICAgICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFydC5keW5hbWljO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwiZHluYW1pY1wiID8gdHJ1ZSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VTdHJlYW0gPSB0aGlzLmZ1bGxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtOiBhc3luYyAocGFydCwgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VNZXRhZGF0YVZhbHVlID0gbWVzc2FnZU1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlTWV0YWRhdGEoeyBwYXJ0IH0pO1xuICAgICAgICAgIGNvbnN0IHBhcnRUeXBlID0gcGFydC50eXBlO1xuICAgICAgICAgIHN3aXRjaCAocGFydFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZGVsdGFcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0LmZpbGUubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogYGRhdGE6JHtwYXJ0LmZpbGUubWVkaWFUeXBlfTtiYXNlNjQsJHtwYXJ0LmZpbGUuYmFzZTY0fWBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU291cmNlcyAmJiBwYXJ0LnNvdXJjZVR5cGUgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtdXJsXCIsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VJZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIHVybDogcGFydC51cmwsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydC50aXRsZSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzICYmIHBhcnQuc291cmNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlLWRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VJZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydC50aXRsZSxcbiAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4ucGFydC50aXRsZSAhPSBudWxsID8geyB0aXRsZTogcGFydC50aXRsZSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgaW5wdXRUZXh0RGVsdGE6IHBhcnQuZGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWMgPSBpc0R5bmFtaWMocGFydCk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0LmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge30sXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IocGFydC5lcnJvciksXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnRpdGxlICE9IG51bGwgPyB7IHRpdGxlOiBwYXJ0LnRpdGxlIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnRpdGxlICE9IG51bGwgPyB7IHRpdGxlOiBwYXJ0LnRpdGxlIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWMgPSBpc0R5bmFtaWMocGFydCk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByZWxpbWluYXJ5ICE9IG51bGwgPyB7IHByZWxpbWluYXJ5OiBwYXJ0LnByZWxpbWluYXJ5IH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLW91dHB1dC1kZW5pZWRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZGVuaWVkXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnQtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnQtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2gtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoLXN0ZXBcIiB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VNZXRhZGF0YVZhbHVlICE9IG51bGwgPyB7IG1lc3NhZ2VNZXRhZGF0YTogbWVzc2FnZU1ldGFkYXRhVmFsdWUgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VNZXNzYWdlSWQgIT0gbnVsbCA/IHsgbWVzc2FnZUlkOiByZXNwb25zZU1lc3NhZ2VJZCB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZEZpbmlzaCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBwYXJ0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VNZXRhZGF0YVZhbHVlICE9IG51bGwgPyB7IG1lc3NhZ2VNZXRhZGF0YTogbWVzc2FnZU1ldGFkYXRhVmFsdWUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYWJvcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHBhcnRUeXBlO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlTWV0YWRhdGFWYWx1ZSAhPSBudWxsICYmIHBhcnRUeXBlICE9PSBcInN0YXJ0XCIgJiYgcGFydFR5cGUgIT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZS1tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IG1lc3NhZ2VNZXRhZGF0YVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIGhhbmRsZVVJTWVzc2FnZVN0cmVhbUZpbmlzaCh7XG4gICAgICAgIHN0cmVhbTogYmFzZVN0cmVhbSxcbiAgICAgICAgbWVzc2FnZUlkOiByZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8gcmVzcG9uc2VNZXNzYWdlSWQgOiBnZW5lcmF0ZU1lc3NhZ2VJZCA9PSBudWxsID8gdm9pZCAwIDogZ2VuZXJhdGVNZXNzYWdlSWQoKSxcbiAgICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uRXJyb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwge1xuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgc2VuZEZpbmlzaCxcbiAgICBzZW5kU3RhcnQsXG4gICAgb25FcnJvcixcbiAgICAuLi5pbml0XG4gIH0gPSB7fSkge1xuICAgIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgICAgIHNlbmRSZWFzb25pbmcsXG4gICAgICAgIHNlbmRTb3VyY2VzLFxuICAgICAgICBzZW5kRmluaXNoLFxuICAgICAgICBzZW5kU3RhcnQsXG4gICAgICAgIG9uRXJyb3JcbiAgICAgIH0pLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHRleHRTdHJlYW06IHRoaXMudGV4dFN0cmVhbSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICB0b1VJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nLFxuICAgIHNlbmRTb3VyY2VzLFxuICAgIHNlbmRGaW5pc2gsXG4gICAgc2VuZFN0YXJ0LFxuICAgIG9uRXJyb3IsXG4gICAgLi4uaW5pdFxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgc3RyZWFtOiB0aGlzLnRvVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgICAgIHNlbmRSZWFzb25pbmcsXG4gICAgICAgIHNlbmRTb3VyY2VzLFxuICAgICAgICBzZW5kRmluaXNoLFxuICAgICAgICBzZW5kU3RhcnQsXG4gICAgICAgIG9uRXJyb3JcbiAgICAgIH0pLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlKHtcbiAgICAgIHRleHRTdHJlYW06IHRoaXMudGV4dFN0cmVhbSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2FnZW50L3Rvb2wtbG9vcC1hZ2VudC50c1xudmFyIFRvb2xMb29wQWdlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gXCJhZ2VudC12MVwiO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgfVxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBhZ2VudC5cbiAgICovXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5pZDtcbiAgfVxuICAvKipcbiAgICogVGhlIHRvb2xzIHRoYXQgdGhlIGFnZW50IGNhbiB1c2UuXG4gICAqL1xuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudG9vbHM7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUNhbGwob3B0aW9ucykge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IGJhc2VDYWxsQXJncyA9IHtcbiAgICAgIC4uLnRoaXMuc2V0dGluZ3MsXG4gICAgICBzdG9wV2hlbjogKF9hMTcgPSB0aGlzLnNldHRpbmdzLnN0b3BXaGVuKSAhPSBudWxsID8gX2ExNyA6IHN0ZXBDb3VudElzKDIwKSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVkQ2FsbEFyZ3MgPSAoX2QgPSBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zZXR0aW5ncykucHJlcGFyZUNhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBiYXNlQ2FsbEFyZ3MpKSkgIT0gbnVsbCA/IF9kIDogYmFzZUNhbGxBcmdzO1xuICAgIGNvbnN0IHsgaW5zdHJ1Y3Rpb25zLCBtZXNzYWdlcywgcHJvbXB0LCAuLi5jYWxsQXJncyB9ID0gcHJlcGFyZWRDYWxsQXJncztcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2FsbEFyZ3MsXG4gICAgICAvLyByZXN0b3JlIHByb21wdCB0eXBlc1xuICAgICAgLi4ueyBzeXN0ZW06IGluc3RydWN0aW9ucywgbWVzc2FnZXMsIHByb21wdCB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIG91dHB1dCBmcm9tIHRoZSBhZ2VudCAobm9uLXN0cmVhbWluZykuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZSh7XG4gICAgYWJvcnRTaWduYWwsXG4gICAgdGltZW91dCxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVUZXh0KHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucHJlcGFyZUNhbGwob3B0aW9ucyksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIHRpbWVvdXRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtcyBhbiBvdXRwdXQgZnJvbSB0aGUgYWdlbnQgKHN0cmVhbWluZykuXG4gICAqL1xuICBhc3luYyBzdHJlYW0oe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIHRpbWVvdXQsXG4gICAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybSxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICByZXR1cm4gc3RyZWFtVGV4dCh7XG4gICAgICAuLi5hd2FpdCB0aGlzLnByZXBhcmVDYWxsKG9wdGlvbnMpLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICB0aW1lb3V0LFxuICAgICAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vY3JlYXRlLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5pbXBvcnQge1xuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jLFxuICBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlOFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gY3JlYXRlVUlNZXNzYWdlU3RyZWFtKHtcbiAgZXhlY3V0ZSxcbiAgb25FcnJvciA9IGdldEVycm9yTWVzc2FnZTgsXG4gIG9yaWdpbmFsTWVzc2FnZXMsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jXG59KSB7XG4gIGxldCBjb250cm9sbGVyO1xuICBjb25zdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMgPSBbXTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyQXJnKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckFyZztcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzYWZlRW5xdWV1ZShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGUoe1xuICAgICAgd3JpdGVyOiB7XG4gICAgICAgIHdyaXRlKHBhcnQpIHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2Uoc3RyZWFtQXJnKSB7XG4gICAgICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1BcmcuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgc2FmZUVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgIHJlc3VsdC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2FpdEZvclN0cmVhbXMgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZTMpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlMygpO1xuICB9KTtcbiAgd2FpdEZvclN0cmVhbXMuZmluYWxseSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgIHN0cmVhbSxcbiAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBvbkZpbmlzaCxcbiAgICBvbkVycm9yXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcmVhZC11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gcmVhZFVJTWVzc2FnZVN0cmVhbSh7XG4gIG1lc3NhZ2UsXG4gIHN0cmVhbSxcbiAgb25FcnJvcixcbiAgdGVybWluYXRlT25FcnJvciA9IGZhbHNlXG59KSB7XG4gIHZhciBfYTE3O1xuICBsZXQgY29udHJvbGxlcjtcbiAgbGV0IGhhc0Vycm9yZWQgPSBmYWxzZTtcbiAgY29uc3Qgb3V0cHV0U3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbWVzc2FnZUlkOiAoX2ExNyA9IG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYTE3IDogXCJcIixcbiAgICBsYXN0TWVzc2FnZTogbWVzc2FnZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yKTtcbiAgICBpZiAoIWhhc0Vycm9yZWQgJiYgdGVybWluYXRlT25FcnJvcikge1xuICAgICAgaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN1bWVTdHJlYW0oe1xuICAgIHN0cmVhbTogcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICBzdHJlYW0sXG4gICAgICBydW5VcGRhdGVNZXNzYWdlSm9iKGpvYikge1xuICAgICAgICByZXR1cm4gam9iKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHN0cnVjdHVyZWRDbG9uZShzdGF0ZS5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBoYW5kbGVFcnJvclxuICAgIH0pLFxuICAgIG9uRXJyb3I6IGhhbmRsZUVycm9yXG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGlmICghaGFzRXJyb3JlZCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG91dHB1dFN0cmVhbSk7XG59XG5cbi8vIHNyYy91aS9jb252ZXJ0LXRvLW1vZGVsLW1lc3NhZ2VzLnRzXG5pbXBvcnQge1xuICBpc05vbk51bGxhYmxlXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlSW5jb21wbGV0ZVRvb2xDYWxscykge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHBhcnRzOiBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgKHBhcnQpID0+ICFpc1Rvb2xVSVBhcnQocGFydCkgfHwgcGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1zdHJlYW1pbmdcIiAmJiBwYXJ0LnN0YXRlICE9PSBcImlucHV0LWF2YWlsYWJsZVwiXG4gICAgICApXG4gICAgfSkpO1xuICB9XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIHN3aXRjaCAobWVzc2FnZS5yb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgY29uc3QgdGV4dFBhcnRzID0gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHRleHRQYXJ0cy5yZWR1Y2UoKGFjYywgcGFydCkgPT4ge1xuICAgICAgICAgIGlmIChwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogdGV4dFBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpLFxuICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHByb3ZpZGVyTWV0YWRhdGEpLmxlbmd0aCA+IDAgPyB7IHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UucGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgIGlmIChpc1RleHRVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmlsZVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFydC51cmwsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGF0YVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMTcgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnZlcnREYXRhUGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHBhcnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maWx0ZXIoaXNOb25OdWxsYWJsZSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgYmxvY2sgPSBbXTtcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQmxvY2soKSB7XG4gICAgICAgICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKGJsb2NrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKGlzVGV4dFVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpbGVVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBwYXJ0LnVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVhc29uaW5nVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVG9vbFVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gKF9hMTcgPSBwYXJ0LmlucHV0KSAhPSBudWxsID8gX2ExNyA6IFwicmF3SW5wdXRcIiBpbiBwYXJ0ID8gcGFydC5yYXdJbnB1dCA6IHZvaWQgMCA6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmFwcHJvdmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWwuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnQucHJvdmlkZXJFeGVjdXRlZCA9PT0gdHJ1ZSAmJiBwYXJ0LnN0YXRlICE9PSBcImFwcHJvdmFsLXJlc3BvbmRlZFwiICYmIChwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBwYXJ0LmVycm9yVGV4dCA6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbDogKF9iID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW3Rvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTW9kZTogcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IFwianNvblwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGF0YVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFQYXJ0ID0gKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb252ZXJ0RGF0YVBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHBhcnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhUGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goZGF0YVBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcGFydDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0b29sUGFydHMgPSBibG9jay5maWx0ZXIoXG4gICAgICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9vbFVJUGFydChwYXJ0KSAmJiAocGFydC5wcm92aWRlckV4ZWN1dGVkICE9PSB0cnVlIHx8ICgoX2ExOCA9IHBhcnQuYXBwcm92YWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmFwcHJvdmVkKSAhPSBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0b29sUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudDIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xQYXJ0IG9mIHRvb2xQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgaWYgKCgoX2QgPSB0b29sUGFydC5hcHByb3ZhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFwcHJvdmVkKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xQYXJ0LmFwcHJvdmFsLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB0b29sUGFydC5hcHByb3ZhbC5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHRvb2xQYXJ0LmFwcHJvdmFsLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sUGFydC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xQYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvb2xQYXJ0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtZGVuaWVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xQYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogZ2V0VG9vbE5hbWUodG9vbFBhcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3ItdGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKF9lID0gdG9vbFBhcnQuYXBwcm92YWwucmVhc29uKSAhPSBudWxsID8gX2UgOiBcIlRvb2wgZXhlY3V0aW9uIGRlbmllZC5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogdG9vbFBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dC1lcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWF2YWlsYWJsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBnZXRUb29sTmFtZSh0b29sUGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xQYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sUGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IHRvb2xQYXJ0LmVycm9yVGV4dCA6IHRvb2xQYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbDogKF9mID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mW3Rvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9vbFBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiB0b29sUGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBtZXNzYWdlLnBhcnRzKSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0VUlQYXJ0KHBhcnQpIHx8IGlzUmVhc29uaW5nVUlQYXJ0KHBhcnQpIHx8IGlzRmlsZVVJUGFydChwYXJ0KSB8fCBpc1Rvb2xVSVBhcnQocGFydCkgfHwgaXNEYXRhVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgIGJsb2NrLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc0Jsb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHByb2Nlc3NCbG9jaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbWVzc2FnZS5yb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGVsTWVzc2FnZXM7XG59XG5cbi8vIHNyYy91aS92YWxpZGF0ZS11aS1tZXNzYWdlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBsYXp5U2NoZW1hIGFzIGxhenlTY2hlbWEyLFxuICB2YWxpZGF0ZVR5cGVzIGFzIHZhbGlkYXRlVHlwZXMyLFxuICB6b2RTY2hlbWEgYXMgem9kU2NoZW1hMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6OCB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB1aU1lc3NhZ2VzU2NoZW1hID0gbGF6eVNjaGVtYTIoXG4gICgpID0+IHpvZFNjaGVtYTIoXG4gICAgejguYXJyYXkoXG4gICAgICB6OC5vYmplY3Qoe1xuICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgIHJvbGU6IHo4LmVudW0oW1wic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiXSksXG4gICAgICAgIG1ldGFkYXRhOiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcGFydHM6IHo4LmFycmF5KFxuICAgICAgICAgIHo4LnVuaW9uKFtcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICAgICAgICAgICAgICB0ZXh0OiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmVudW0oW1wic3RyZWFtaW5nXCIsIFwiZG9uZVwiXSkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gICAgICAgICAgICAgIHRleHQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejguZW51bShbXCJzdHJlYW1pbmdcIiwgXCJkb25lXCJdKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInNvdXJjZS11cmxcIiksXG4gICAgICAgICAgICAgIHNvdXJjZUlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdXJsOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdGl0bGU6IHo4LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwic291cmNlLWRvY3VtZW50XCIpLFxuICAgICAgICAgICAgICBzb3VyY2VJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRpdGxlOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHo4LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICAgICAgICAgICAgbWVkaWFUeXBlOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHo4LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHVybDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwic3RlcC1zdGFydFwiKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwiZGF0YS1cIiksXG4gICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBkYXRhOiB6OC51bmtub3duKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1zdHJlYW1pbmdcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImlucHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImFwcHJvdmFsLXJlcXVlc3RlZFwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXNwb25kZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejguYm9vbGVhbigpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByZWxpbWluYXJ5OiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKHRydWUpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWVycm9yXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICByYXdJbnB1dDogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKHRydWUpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWRlbmllZFwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKGZhbHNlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1zdHJlYW1pbmdcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImlucHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImFwcHJvdmFsLXJlcXVlc3RlZFwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXNwb25kZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejguYm9vbGVhbigpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByZWxpbWluYXJ5OiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKHRydWUpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWVycm9yXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcmF3SW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKHRydWUpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWRlbmllZFwiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5saXRlcmFsKGZhbHNlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSlcbiAgICAgICAgKS5ub25lbXB0eShcIk1lc3NhZ2UgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBwYXJ0XCIpXG4gICAgICB9KVxuICAgICkubm9uZW1wdHkoXCJNZXNzYWdlcyBhcnJheSBtdXN0IG5vdCBiZSBlbXB0eVwiKVxuICApXG4pO1xuYXN5bmMgZnVuY3Rpb24gc2FmZVZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICBtZXRhZGF0YVNjaGVtYSxcbiAgZGF0YVNjaGVtYXMsXG4gIHRvb2xzXG59KSB7XG4gIHRyeSB7XG4gICAgaWYgKG1lc3NhZ2VzID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgICBwYXJhbWV0ZXI6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICB2YWx1ZTogbWVzc2FnZXMsXG4gICAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZFwiXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZWRNZXNzYWdlcyA9IGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogdWlNZXNzYWdlc1NjaGVtYVxuICAgIH0pO1xuICAgIGlmIChtZXRhZGF0YVNjaGVtYSkge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHZhbGlkYXRlZE1lc3NhZ2VzKSB7XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogbWVzc2FnZS5tZXRhZGF0YSxcbiAgICAgICAgICBzY2hlbWE6IG1ldGFkYXRhU2NoZW1hXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YVNjaGVtYXMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB2YWxpZGF0ZWRNZXNzYWdlcykge1xuICAgICAgICBjb25zdCBkYXRhUGFydHMgPSBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGFQYXJ0IG9mIGRhdGFQYXJ0cykge1xuICAgICAgICAgIGNvbnN0IGRhdGFOYW1lID0gZGF0YVBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgICBjb25zdCBkYXRhU2NoZW1hID0gZGF0YVNjaGVtYXNbZGF0YU5hbWVdO1xuICAgICAgICAgIGlmICghZGF0YVNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhUGFydC5kYXRhLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgTm8gZGF0YSBzY2hlbWEgZm91bmQgZm9yIGRhdGEgcGFydCAke2RhdGFOYW1lfWBcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhUGFydC5kYXRhLFxuICAgICAgICAgICAgc2NoZW1hOiBkYXRhU2NoZW1hXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvb2xzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgdG9vbFBhcnRzID0gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZS5zdGFydHNXaXRoKFwidG9vbC1cIilcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sUGFydCBvZiB0b29sUGFydHMpIHtcbiAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHRvb2xQYXJ0LnR5cGUuc2xpY2UoNSk7XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKCF0b29sMikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICBjYXVzZTogYE5vIHRvb2wgc2NoZW1hIGZvdW5kIGZvciB0b29sIHBhcnQgJHt0b29sTmFtZX1gXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9vbFBhcnQuc3RhdGUgPT09IFwiaW5wdXQtYXZhaWxhYmxlXCIgfHwgdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiIHx8IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiICYmIHRvb2xQYXJ0LmlucHV0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICBzY2hlbWE6IHRvb2wyLmlucHV0U2NoZW1hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiAmJiB0b29sMi5vdXRwdXRTY2hlbWEpIHtcbiAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sMi5vdXRwdXRTY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHZhbGlkYXRlZE1lc3NhZ2VzXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBlcnIgPSBlcnJvcjtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVVSU1lc3NhZ2VzKHtcbiAgbWVzc2FnZXMsXG4gIG1ldGFkYXRhU2NoZW1hLFxuICBkYXRhU2NoZW1hcyxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzYWZlVmFsaWRhdGVVSU1lc3NhZ2VzKHtcbiAgICBtZXNzYWdlcyxcbiAgICBtZXRhZGF0YVNjaGVtYSxcbiAgICBkYXRhU2NoZW1hcyxcbiAgICB0b29sc1xuICB9KTtcbiAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKVxuICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn1cblxuLy8gc3JjL2FnZW50L2NyZWF0ZS1hZ2VudC11aS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFnZW50VUlTdHJlYW0oe1xuICBhZ2VudCxcbiAgdWlNZXNzYWdlcyxcbiAgb3B0aW9ucyxcbiAgYWJvcnRTaWduYWwsXG4gIHRpbWVvdXQsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm0sXG4gIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnNcbn0pIHtcbiAgY29uc3QgdmFsaWRhdGVkTWVzc2FnZXMgPSBhd2FpdCB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICAgIG1lc3NhZ2VzOiB1aU1lc3NhZ2VzLFxuICAgIHRvb2xzOiBhZ2VudC50b29sc1xuICB9KTtcbiAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb01vZGVsTWVzc2FnZXModmFsaWRhdGVkTWVzc2FnZXMsIHtcbiAgICB0b29sczogYWdlbnQudG9vbHNcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LnN0cmVhbSh7XG4gICAgcHJvbXB0OiBtb2RlbE1lc3NhZ2VzLFxuICAgIG9wdGlvbnMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgdGltZW91dCxcbiAgICBleHBlcmltZW50YWxfdHJhbnNmb3JtXG4gIH0pO1xuICByZXR1cm4gcmVzdWx0LnRvVUlNZXNzYWdlU3RyZWFtKHVpTWVzc2FnZVN0cmVhbU9wdGlvbnMpO1xufVxuXG4vLyBzcmMvYWdlbnQvY3JlYXRlLWFnZW50LXVpLXN0cmVhbS1yZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWdlbnRVSVN0cmVhbVJlc3BvbnNlKHtcbiAgaGVhZGVycyxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBjb25zdW1lU3NlU3RyZWFtLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIHJldHVybiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjb25zdW1lU3NlU3RyZWFtLFxuICAgIHN0cmVhbTogYXdhaXQgY3JlYXRlQWdlbnRVSVN0cmVhbShvcHRpb25zKVxuICB9KTtcbn1cblxuLy8gc3JjL2FnZW50L3BpcGUtYWdlbnQtdWktc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBwaXBlQWdlbnRVSVN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgaGVhZGVycyxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBjb25zdW1lU3NlU3RyZWFtLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBoZWFkZXJzLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNvbnN1bWVTc2VTdHJlYW0sXG4gICAgc3RyZWFtOiBhd2FpdCBjcmVhdGVBZ2VudFVJU3RyZWFtKG9wdGlvbnMpXG4gIH0pO1xufVxuXG4vLyBzcmMvZW1iZWQvZW1iZWQudHNcbmltcG9ydCB7IHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbDogbW9kZWxBcmcsXG4gIHZhbHVlLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlRW1iZWRkaW5nTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4MyhcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCB3YXJuaW5ncywgcmVzcG9uc2UsIHByb3ZpZGVyTWV0YWRhdGEgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgLy8gbmVzdGVkIHNwYW5zIHRvIGFsaWduIHdpdGggdGhlIGVtYmVkTWFueSB0ZWxlbWV0cnkgZGF0YTpcbiAgICAgICAgICByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjogeyBpbnB1dDogKCkgPT4gW0pTT04uc3RyaW5naWZ5KHZhbHVlKV0gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExNyA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE3IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nXCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgbG9nV2FybmluZ3MoeyB3YXJuaW5ncywgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLCBtb2RlbDogbW9kZWwubW9kZWxJZCB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkUmVzdWx0KHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGVtYmVkZGluZyxcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICByZXNwb25zZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgfVxufTtcblxuLy8gc3JjL2VtYmVkL2VtYmVkLW1hbnkudHNcbmltcG9ydCB7IHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheTIsIGNodW5rU2l6ZSkge1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheTIubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5Mi5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2VtYmVkL2VtYmVkLW1hbnkudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueSh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWVzLFxuICBtYXhQYXJhbGxlbENhbGxzID0gSW5maW5pdHksXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg0KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGNvbnN0IFttYXhFbWJlZGRpbmdzUGVyQ2FsbCwgc3VwcG9ydHNQYXJhbGxlbENhbGxzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICAgIG1vZGVsLnN1cHBvcnRzUGFyYWxsZWxDYWxsc1xuICAgICAgXSk7XG4gICAgICBpZiAobWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCB8fCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UsIHdhcm5pbmdzOiB3YXJuaW5nczIsIHJlc3BvbnNlLCBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhMiB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MzID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExOCA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE4IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogbW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzMixcbiAgICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nczIsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YTIsXG4gICAgICAgICAgcmVzcG9uc2VzOiBbcmVzcG9uc2VdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVDaHVua3MgPSBzcGxpdEFycmF5KHZhbHVlcywgbWF4RW1iZWRkaW5nc1BlckNhbGwpO1xuICAgICAgY29uc3QgZW1iZWRkaW5ncyA9IFtdO1xuICAgICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgbGV0IHRva2VucyA9IDA7XG4gICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGNvbnN0IHBhcmFsbGVsQ2h1bmtzID0gc3BsaXRBcnJheShcbiAgICAgICAgdmFsdWVDaHVua3MsXG4gICAgICAgIHN1cHBvcnRzUGFyYWxsZWxDYWxscyA/IG1heFBhcmFsbGVsQ2FsbHMgOiAxXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBwYXJhbGxlbENodW5rIG9mIHBhcmFsbGVsQ2h1bmtzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBwYXJhbGxlbENodW5rLm1hcCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gY2h1bmsubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlID0gKF9hMTggPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExOCA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogbW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgIGVtYmVkZGluZ3MucHVzaCguLi5yZXN1bHQuZW1iZWRkaW5ncyk7XG4gICAgICAgICAgd2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpO1xuICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gICAgICAgICAgdG9rZW5zICs9IHJlc3VsdC51c2FnZS50b2tlbnM7XG4gICAgICAgICAgaWYgKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IHsgLi4ucmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW3Byb3ZpZGVyTmFtZSwgbWV0YWRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAuLi4oX2ExNyA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSkgIT0gbnVsbCA/IF9hMTcgOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZW1iZWRkaW5ncyxcbiAgICAgICAgdXNhZ2U6IHsgdG9rZW5zIH0sXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICByZXNwb25zZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtaW1hZ2UvZ2VuZXJhdGUtaW1hZ2UudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTQsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDVcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2Uoe1xuICBtb2RlbDogbW9kZWxBcmcsXG4gIHByb21wdDogcHJvbXB0QXJnLFxuICBuID0gMSxcbiAgbWF4SW1hZ2VzUGVyQ2FsbCxcbiAgc2l6ZSxcbiAgYXNwZWN0UmF0aW8sXG4gIHNlZWQsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTcsIF9iO1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVJbWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4NShcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQgPSAoX2ExNyA9IG1heEltYWdlc1BlckNhbGwgIT0gbnVsbCA/IG1heEltYWdlc1BlckNhbGwgOiBhd2FpdCBpbnZva2VNb2RlbE1heEltYWdlc1BlckNhbGwobW9kZWwpKSAhPSBudWxsID8gX2ExNyA6IDE7XG4gIGNvbnN0IGNhbGxDb3VudCA9IE1hdGguY2VpbChuIC8gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0KTtcbiAgY29uc3QgY2FsbEltYWdlQ291bnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY2FsbENvdW50IH0sIChfLCBpKSA9PiB7XG4gICAgaWYgKGkgPCBjYWxsQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCByZW1haW5kZXIgPSBuICUgbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0O1xuICAgIHJldHVybiByZW1haW5kZXIgPT09IDAgPyBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQgOiByZW1haW5kZXI7XG4gIH0pO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY2FsbEltYWdlQ291bnRzLm1hcChcbiAgICAgIGFzeW5jIChjYWxsSW1hZ2VDb3VudCkgPT4gcmV0cnkoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHByb21wdCwgZmlsZXMsIG1hc2sgfSA9IG5vcm1hbGl6ZVByb21wdChwcm9tcHRBcmcpO1xuICAgICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgbjogY2FsbEltYWdlQ291bnQsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBhc3BlY3RSYXRpbyxcbiAgICAgICAgICBzZWVkLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJPcHRpb25zICE9IG51bGwgPyBwcm92aWRlck9wdGlvbnMgOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB7fTtcbiAgbGV0IHRvdGFsVXNhZ2UgPSB7XG4gICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICB0b3RhbFRva2Vuczogdm9pZCAwXG4gIH07XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpbWFnZXMucHVzaChcbiAgICAgIC4uLnJlc3VsdC5pbWFnZXMubWFwKFxuICAgICAgICAoaW1hZ2UpID0+IHtcbiAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgIGRhdGE6IGltYWdlLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiAoX2ExOCA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGltYWdlLFxuICAgICAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgICAgIH0pKSAhPSBudWxsID8gX2ExOCA6IFwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgd2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpO1xuICAgIGlmIChyZXN1bHQudXNhZ2UgIT0gbnVsbCkge1xuICAgICAgdG90YWxVc2FnZSA9IGFkZEltYWdlTW9kZWxVc2FnZSh0b3RhbFVzYWdlLCByZXN1bHQudXNhZ2UpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgW3Byb3ZpZGVyTmFtZSwgbWV0YWRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSkge1xuICAgICAgICBpZiAocHJvdmlkZXJOYW1lID09PSBcImdhdGV3YXlcIikge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbnRyeSA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXTtcbiAgICAgICAgICBpZiAoY3VycmVudEVudHJ5ICE9IG51bGwgJiYgdHlwZW9mIGN1cnJlbnRFbnRyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0ge1xuICAgICAgICAgICAgICAuLi5jdXJyZW50RW50cnksXG4gICAgICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSBtZXRhZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW1hZ2VzVmFsdWUgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGltYWdlc1ZhbHVlKSAmJiBpbWFnZXNWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoX2IgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0pICE9IG51bGwgPyBfYiA6IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IHsgaW1hZ2VzOiBbXSB9O1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXMucHVzaChcbiAgICAgICAgICAgIC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNwb25zZXMucHVzaChyZXN1bHQucmVzcG9uc2UpO1xuICB9XG4gIGxvZ1dhcm5pbmdzKHsgd2FybmluZ3MsIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlciwgbW9kZWw6IG1vZGVsLm1vZGVsSWQgfSk7XG4gIGlmICghaW1hZ2VzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBOb0ltYWdlR2VuZXJhdGVkRXJyb3IoeyByZXNwb25zZXMgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCh7XG4gICAgaW1hZ2VzLFxuICAgIHdhcm5pbmdzLFxuICAgIHJlc3BvbnNlcyxcbiAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgIHVzYWdlOiB0b3RhbFVzYWdlXG4gIH0pO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5pbWFnZXMgPSBvcHRpb25zLmltYWdlcztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgfVxuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VzWzBdO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gaW52b2tlTW9kZWxNYXhJbWFnZXNQZXJDYWxsKG1vZGVsKSB7XG4gIGNvbnN0IGlzRnVuY3Rpb24gPSBtb2RlbC5tYXhJbWFnZXNQZXJDYWxsIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIGlmICghaXNGdW5jdGlvbikge1xuICAgIHJldHVybiBtb2RlbC5tYXhJbWFnZXNQZXJDYWxsO1xuICB9XG4gIHJldHVybiBtb2RlbC5tYXhJbWFnZXNQZXJDYWxsKHtcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvbXB0KHByb21wdCkge1xuICBpZiAodHlwZW9mIHByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7IHByb21wdCwgZmlsZXM6IHZvaWQgMCwgbWFzazogdm9pZCAwIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHByb21wdC50ZXh0LFxuICAgIGZpbGVzOiBwcm9tcHQuaW1hZ2VzLm1hcCh0b0ltYWdlTW9kZWxWM0ZpbGUpLFxuICAgIG1hc2s6IHByb21wdC5tYXNrID8gdG9JbWFnZU1vZGVsVjNGaWxlKHByb21wdC5tYXNrKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gdG9JbWFnZU1vZGVsVjNGaWxlKGRhdGFDb250ZW50KSB7XG4gIGlmICh0eXBlb2YgZGF0YUNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiYgZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1cmxcIixcbiAgICAgIHVybDogZGF0YUNvbnRlbnRcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YUNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiYgZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgY29uc3QgeyBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChkYXRhQ29udGVudCk7XG4gICAgaWYgKGJhc2U2NENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdWludDhEYXRhMiA9IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXk0KGJhc2U2NENvbnRlbnQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IHVpbnQ4RGF0YTIsXG4gICAgICAgIG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSB8fCBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgIGRhdGE6IHVpbnQ4RGF0YTIsXG4gICAgICAgICAgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pIHx8IFwiaW1hZ2UvcG5nXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHVpbnQ4RGF0YSA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShkYXRhQ29udGVudCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJmaWxlXCIsXG4gICAgZGF0YTogdWludDhEYXRhLFxuICAgIG1lZGlhVHlwZTogZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgIGRhdGE6IHVpbnQ4RGF0YSxcbiAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgIH0pIHx8IFwiaW1hZ2UvcG5nXCJcbiAgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLWltYWdlL2luZGV4LnRzXG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UgPSBnZW5lcmF0ZUltYWdlO1xuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IzLFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg2XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2V4dHJhY3QtcmVhc29uaW5nLWNvbnRlbnQudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZWFzb25pbmdDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwicmVhc29uaW5nXCJcbiAgKTtcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHBhcnRzLm1hcCgoY29udGVudDIpID0+IGNvbnRlbnQyLnRleHQpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG5pbXBvcnQge1xuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3I0LFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hNCxcbiAgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXM0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogYXN5bmMgKCkgPT4gdm9pZCAwLFxuICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgYXN5bmMgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSwgY29udGV4dDIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgdGV4dDogY29udGV4dDIudGV4dCxcbiAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICB9KVxuICAgIH0gOiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyh7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBhc3luYyAoKSA9PiBhd2FpdCBzY2hlbWEuanNvblNjaGVtYSxcbiAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzNCh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyh7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBvYmplY3QgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGFycmF5T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYXJyYXkgb2YgZWxlbWVudHMsIHNpbmNlIG1vc3QgTExNcyB3aWxsIG5vdFxuICAgIC8vIGJlIGFibGUgdG8gZ2VuZXJhdGUgYW4gYXJyYXkgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGFycmF5cyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIGdyYW1tYXItZ3VpZGVkIGdlbmVyYXRpb25cbiAgICBqc29uU2NoZW1hOiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7ICRzY2hlbWEsIC4uLml0ZW1TY2hlbWEgfSA9IGF3YWl0IHNjaGVtYS5qc29uU2NoZW1hO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgIGlzRmluYWxEZWx0YVxuICAgIH0pIHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGNvbnN0IHJlc3VsdEFycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGlucHV0QXJyYXlbaV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzNCh7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmIChpID09PSBpbnB1dEFycmF5Lmxlbmd0aCAtIDEgJiYgIWlzRmluYWxEZWx0YSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdEFycmF5LnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1Ymxpc2hlZEVsZW1lbnRDb3VudCA9IChfYTE3ID0gbGF0ZXN0T2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RPYmplY3QubGVuZ3RoKSAhPSBudWxsID8gX2ExNyA6IDA7XG4gICAgICBsZXQgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgIGlmIChpc0ZpcnN0RGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiW1wiO1xuICAgICAgfVxuICAgICAgaWYgKHB1Ymxpc2hlZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiLFwiO1xuICAgICAgfVxuICAgICAgdGV4dERlbHRhICs9IHJlc3VsdEFycmF5LnNsaWNlKHB1Ymxpc2hlZEVsZW1lbnRDb3VudCkubWFwKChlbGVtZW50KSA9PiBKU09OLnN0cmluZ2lmeShlbGVtZW50KSkuam9pbihcIixcIik7XG4gICAgICBpZiAoaXNGaW5hbERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIl1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcGFydGlhbDogcmVzdWx0QXJyYXksXG4gICAgICAgICAgdGV4dERlbHRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXM0KHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICAgIG9yaWdpbmFsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXkyID0gY2h1bmsub2JqZWN0O1xuICAgICAgICAgICAgICAgICAgZm9yICg7IHB1Ymxpc2hlZEVsZW1lbnRzIDwgYXJyYXkyLmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXkyW3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IGFzeW5jICgpID0+ICh7XG4gICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmVzdWx0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGVudW06IGVudW1WYWx1ZXMgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJyZXN1bHRcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9KSxcbiAgICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIGNvbnN0IHBvc3NpYmxlRW51bVZhbHVlcyA9IGVudW1WYWx1ZXMuZmlsdGVyKFxuICAgICAgICAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUuc3RhcnRzV2l0aChyZXN1bHQpXG4gICAgICApO1xuICAgICAgaWYgKHZhbHVlLnJlc3VsdC5sZW5ndGggPT09IDAgfHwgcG9zc2libGVFbnVtVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiBwb3NzaWJsZUVudW1WYWx1ZXMubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHBvc3NpYmxlRW51bVZhbHVlc1swXSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPdXRwdXRTdHJhdGVneSh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIHN3aXRjaCAob3V0cHV0KSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIG9iamVjdE91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hNChzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hNChzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9wYXJzZS1hbmQtdmFsaWRhdGUtb2JqZWN0LXJlc3VsdC50c1xuaW1wb3J0IHsgSlNPTlBhcnNlRXJyb3IgYXMgSlNPTlBhcnNlRXJyb3IyLCBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCBjb250ZXh0Mikge1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT040KHsgdGV4dDogcmVzdWx0IH0pO1xuICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgIHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIHtcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZVxuICAgIH1cbiAgKTtcbiAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIocmVzdWx0LCBvdXRwdXRTdHJhdGVneSwgcmVwYWlyVGV4dCwgY29udGV4dDIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCBjb250ZXh0Mik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHJlcGFpclRleHQgIT0gbnVsbCAmJiBOb09iamVjdEdlbmVyYXRlZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpICYmIChKU09OUGFyc2VFcnJvcjIuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjUuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkpKSB7XG4gICAgICBjb25zdCByZXBhaXJlZFRleHQgPSBhd2FpdCByZXBhaXJUZXh0KHtcbiAgICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgICBlcnJvcjogZXJyb3IuY2F1c2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcGFpcmVkVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KFxuICAgICAgICByZXBhaXJlZFRleHQsXG4gICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICBjb250ZXh0MlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbW9kZWw6IG1vZGVsQXJnLFxuICAgIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIGhlYWRlcnMsXG4gICAgZXhwZXJpbWVudGFsX3JlcGFpclRleHQ6IHJlcGFpclRleHQsXG4gICAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICAgIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZW51bSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgc2NoZW1hTmFtZVxuICB9ID0gXCJzY2hlbWFcIiBpbiBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDYoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgc2V0dGluZ3M6IHsgLi4uY2FsbFNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICBjb25zdCBqc29uU2NoZW1hMiA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBqc29uU2NoZW1hMiAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoanNvblNjaGVtYTIpIH0gOiB2b2lkIDAsXG4gICAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGVcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICAgIGxldCB1c2FnZTtcbiAgICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICBsZXQgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IHJlYXNvbmluZztcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogY2FsbFNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTgsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IChfYiA9IChfYTE4ID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTguaWQpICE9IG51bGwgPyBfYiA6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MudGltZXN0YW1wKSAhPSBudWxsID8gX2QgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tb2RlbElkKSAhPSBudWxsID8gX2YgOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IChfZyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IChfaCA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfaC5ib2R5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQyID0gZXh0cmFjdFRleHRDb250ZW50KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZzIgPSBleHRyYWN0UmVhc29uaW5nQ29udGVudChyZXN1bHQyLmNvbnRlbnQpO1xuICAgICAgICAgICAgICBpZiAodGV4dDIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogdGhlIG1vZGVsIGRpZCBub3QgcmV0dXJuIGEgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKHJlc3VsdDIudXNhZ2UpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQyLmZpbmlzaFJlYXNvbi51bmlmaWVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHRleHQyIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIuZmluaXNoUmVhc29uLnVuaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnMudG90YWxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3VsdDIsXG4gICAgICAgICAgICAgICAgb2JqZWN0VGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgcmVhc29uaW5nOiByZWFzb25pbmcyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkO1xuICAgICAgICB1c2FnZSA9IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGdlbmVyYXRlUmVzdWx0LnVzYWdlKTtcbiAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIHJlcXVlc3QgPSAoX2ExNyA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYTE3IDoge307XG4gICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICByZWFzb25pbmcgPSBnZW5lcmF0ZVJlc3VsdC5yZWFzb25pbmc7XG4gICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9iamVjdDIgPSBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0V2l0aFJlcGFpcihcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgICAgICAgcmVwYWlyVGV4dCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHJlc3VsdFByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdDIsXG4gICAgICAgICAgcmVhc29uaW5nLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgd3JhcEdhdGV3YXlFcnJvcihlcnJvcik7XG4gIH1cbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucmVxdWVzdCA9IG9wdGlvbnMucmVxdWVzdDtcbiAgICB0aGlzLnJlYXNvbmluZyA9IG9wdGlvbnMucmVhc29uaW5nO1xuICB9XG4gIHRvSnNvblJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExNztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiAoX2ExNyA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExNyA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjQsXG4gIERlbGF5ZWRQcm9taXNlIGFzIERlbGF5ZWRQcm9taXNlMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcInZlY3RvcjEsdmVjdG9yMlwiLFxuICAgICAgdmFsdWU6IHsgdmVjdG9yMUxlbmd0aDogdmVjdG9yMS5sZW5ndGgsIHZlY3RvcjJMZW5ndGg6IHZlY3RvcjIubGVuZ3RoIH0sXG4gICAgICBtZXNzYWdlOiBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG4gPSB2ZWN0b3IxLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgbWFnbml0dWRlU3F1YXJlZDEgPSAwO1xuICBsZXQgbWFnbml0dWRlU3F1YXJlZDIgPSAwO1xuICBsZXQgZG90UHJvZHVjdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUxID0gdmVjdG9yMVtpXTtcbiAgICBjb25zdCB2YWx1ZTIgPSB2ZWN0b3IyW2ldO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQxICs9IHZhbHVlMSAqIHZhbHVlMTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMiArPSB2YWx1ZTIgKiB2YWx1ZTI7XG4gICAgZG90UHJvZHVjdCArPSB2YWx1ZTEgKiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIG1hZ25pdHVkZVNxdWFyZWQxID09PSAwIHx8IG1hZ25pdHVkZVNxdWFyZWQyID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAoTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQxKSAqIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMikpO1xufVxuXG4vLyBzcmMvdXRpbC9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWVkaWFUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlsL3NlcmlhbC1qb2ItZXhlY3V0b3IudHNcbnZhciBTZXJpYWxKb2JFeGVjdXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1F1ZXVlKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5xdWV1ZVswXSgpO1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHJ1bihqb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUzLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgam9iKCk7XG4gICAgICAgICAgcmVzb2x2ZTMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvc2ltdWxhdGUtcmVhZGFibGUtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBkZWxheUZ1bmN0aW9uIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0oe1xuICBjaHVua3MsXG4gIGluaXRpYWxEZWxheUluTXMgPSAwLFxuICBjaHVua0RlbGF5SW5NcyA9IDAsXG4gIF9pbnRlcm5hbFxufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgZGVsYXkyID0gKF9hMTcgPSBfaW50ZXJuYWwgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbC5kZWxheSkgIT0gbnVsbCA/IF9hMTcgOiBkZWxheUZ1bmN0aW9uO1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkyKGluZGV4ID09PSAwID8gaW5pdGlhbERlbGF5SW5NcyA6IGNodW5rRGVsYXlJbk1zKTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rc1tpbmRleCsrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgbm93OiBub3cyID0gbm93XG4gICAgfSA9IHt9LFxuICAgIC4uLnNldHRpbmdzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmVudW0gPyBvcHRpb25zLmVudW0gOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHNjaGVtYU5hbWVcbiAgfSA9IFwic2NoZW1hXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcmVwYWlyVGV4dCxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHJlcGFpclRleHQsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3VzYWdlID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fd2FybmluZ3MgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9yZXNwb25zZSA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgY29uc3QgbW9kZWwgPSByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbEFyZyk7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgb25FcnJvcih7IGVycm9yOiB3cmFwR2F0ZXdheUVycm9yKGNodW5rLmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLnBpcGVUaHJvdWdoKGV2ZW50UHJvY2Vzc29yKTtcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zY2hlbWFcIjoge1xuICAgICAgICAgICAgaW5wdXQ6IGFzeW5jICgpID0+IEpTT04uc3RyaW5naWZ5KGF3YWl0IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc2NoZW1hOiBhd2FpdCBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKCksXG4gICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGluY2x1ZGVSYXdDaHVua3M6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuZGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmVhbS1zdGFydFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgcmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzZWxmLl9yZXF1ZXN0LnJlc29sdmUocmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9KTtcbiAgICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgICBsZXQgdXNhZ2UgPSBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCk7XG4gICAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgICAgICBsZXQgb2JqZWN0MjtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgYWNjdW11bGF0ZWRUZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgIGxldCBmdWxsUmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwib2JqZWN0XCIgJiYgY2h1bmsudHlwZSA9PT0gXCJzdHJlYW0tc3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gY2h1bmsud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGV4dERlbHRhICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLCBzdGF0ZTogcGFyc2VTdGF0ZSB9ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50T2JqZWN0SnNvbiAhPT0gdm9pZCAwICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0SnNvbiwgY3VycmVudE9iamVjdEpzb24pKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBpc0ZpbmFsRGVsdGE6IHBhcnNlU3RhdGUgPT09IFwic3VjY2Vzc2Z1bC1wYXJzZVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgJiYgIWlzRGVlcEVxdWFsRGF0YShcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0SnNvbiA9IGN1cnJlbnRPYmplY3RKc29uO1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxhdGVzdE9iamVjdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUudGV4dERlbHRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBmdWxsUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExNyA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExNyA6IGZ1bGxSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IGZ1bGxSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IGZ1bGxSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgaWYgKHRleHREZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uLnVuaWZpZWQ7XG4gICAgICAgICAgICAgICAgICB1c2FnZSA9IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZnVsbFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzICE9IG51bGwgPyB3YXJuaW5ncyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3VzYWdlLnJlc29sdmUodXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvdmlkZXJNZXRhZGF0YS5yZXNvbHZlKHByb3ZpZGVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fd2FybmluZ3MucmVzb2x2ZSh3YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVzb2x2ZShmaW5pc2hSZWFzb24gIT0gbnVsbCA/IGZpbmlzaFJlYXNvbiA6IFwib3RoZXJcIik7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QyID0gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIoXG4gICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGFpclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxVc2FnZSA9IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogZnVsbFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0odHJhbnNmb3JtZWRTdHJlYW0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3QucHJvbWlzZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEucHJvbWlzZTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdzLnByb21pc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucHJvbWlzZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLmJhc2VTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0cmF0ZWd5LmNyZWF0ZUVsZW1lbnRTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtc3BlZWNoL2dlbmVyYXRlLXNwZWVjaC50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgc3VwZXIoeyBkYXRhLCBtZWRpYVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgY29uc3QgbWVkaWFUeXBlUGFydHMgPSBtZWRpYVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1lZGlhVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWVkaWFUeXBlICE9PSBcImF1ZGlvL21wZWdcIikge1xuICAgICAgICAgIGZvcm1hdCA9IG1lZGlhVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWVkaWEgdHlwZVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3BlZWNoKHtcbiAgbW9kZWwsXG4gIHRleHQ6IHRleHQyLFxuICB2b2ljZSxcbiAgb3V0cHV0Rm9ybWF0LFxuICBpbnN0cnVjdGlvbnMsXG4gIHNwZWVkLFxuICBsYW5ndWFnZSxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCByZXNvbHZlZE1vZGVsID0gcmVzb2x2ZVNwZWVjaE1vZGVsKG1vZGVsKTtcbiAgaWYgKCFyZXNvbHZlZE1vZGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgY291bGQgbm90IGJlIHJlc29sdmVkXCIpO1xuICB9XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDcoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gcmVzb2x2ZWRNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdm9pY2UsXG4gICAgICBvdXRwdXRGb3JtYXQsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICBzcGVlZCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgIH0pXG4gICk7XG4gIGlmICghcmVzdWx0LmF1ZGlvIHx8IHJlc3VsdC5hdWRpby5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTm9TcGVlY2hHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcHJvdmlkZXI6IHJlc29sdmVkTW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWw6IHJlc29sdmVkTW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3BlZWNoUmVzdWx0KHtcbiAgICBhdWRpbzogbmV3IERlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUoe1xuICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgbWVkaWFUeXBlOiAoX2ExNyA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgIGRhdGE6IHJlc3VsdC5hdWRpbyxcbiAgICAgICAgc2lnbmF0dXJlczogYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICB9KSkgIT0gbnVsbCA/IF9hMTcgOiBcImF1ZGlvL21wM1wiXG4gICAgfSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRTcGVlY2hSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IHt9O1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9wcnVuZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gcHJ1bmVNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICByZWFzb25pbmcgPSBcIm5vbmVcIixcbiAgdG9vbENhbGxzID0gW10sXG4gIGVtcHR5TWVzc2FnZXMgPSBcInJlbW92ZVwiXG59KSB7XG4gIGlmIChyZWFzb25pbmcgPT09IFwiYWxsXCIgfHwgcmVhc29uaW5nID09PSBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIikge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlLCBtZXNzYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIiB8fCByZWFzb25pbmcgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiICYmIG1lc3NhZ2VJbmRleCA9PT0gbWVzc2FnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJyZWFzb25pbmdcIilcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgaWYgKHRvb2xDYWxscyA9PT0gXCJub25lXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbXTtcbiAgfSBlbHNlIGlmICh0b29sQ2FsbHMgPT09IFwiYWxsXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbeyB0eXBlOiBcImFsbFwiIH1dO1xuICB9IGVsc2UgaWYgKHRvb2xDYWxscyA9PT0gXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbeyB0eXBlOiBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIiB9XTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9vbENhbGxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG9vbENhbGxzID0gW3sgdHlwZTogdG9vbENhbGxzIH1dO1xuICB9XG4gIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgY29uc3Qga2VlcExhc3RNZXNzYWdlc0NvdW50ID0gdG9vbENhbGwudHlwZSA9PT0gXCJhbGxcIiA/IHZvaWQgMCA6IHRvb2xDYWxsLnR5cGUgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiID8gMSA6IE51bWJlcihcbiAgICAgIHRvb2xDYWxsLnR5cGUuc2xpY2UoXCJiZWZvcmUtbGFzdC1cIi5sZW5ndGgpLnNsaWNlKDAsIC1cIi1tZXNzYWdlc1wiLmxlbmd0aClcbiAgICApO1xuICAgIGNvbnN0IGtlcHRUb29sQ2FsbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qga2VwdEFwcHJvdmFsSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBpZiAoa2VlcExhc3RNZXNzYWdlc0NvdW50ICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcy5zbGljZSgta2VlcExhc3RNZXNzYWdlc0NvdW50KSkge1xuICAgICAgICBpZiAoKG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiB8fCBtZXNzYWdlLnJvbGUgPT09IFwidG9vbFwiKSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikge1xuICAgICAgICAgICAgICBrZXB0VG9vbENhbGxJZHMuYWRkKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICAgIGtlcHRBcHByb3ZhbElkcy5hZGQocGFydC5hcHByb3ZhbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UsIG1lc3NhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiAmJiBtZXNzYWdlLnJvbGUgIT09IFwidG9vbFwiIHx8IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgfHwga2VlcExhc3RNZXNzYWdlc0NvdW50ICYmIG1lc3NhZ2VJbmRleCA+PSBtZXNzYWdlcy5sZW5ndGggLSBrZWVwTGFzdE1lc3NhZ2VzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sQ2FsbElkVG9Ub29sTmFtZSA9IHt9O1xuICAgICAgY29uc3QgYXBwcm92YWxJZFRvVG9vbE5hbWUgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHtcbiAgICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRvb2wtY2FsbFwiICYmIHBhcnQudHlwZSAhPT0gXCJ0b29sLXJlc3VsdFwiICYmIHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiAmJiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgICAgdG9vbENhbGxJZFRvVG9vbE5hbWVbcGFydC50b29sQ2FsbElkXSA9IHBhcnQudG9vbE5hbWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpIHtcbiAgICAgICAgICAgIGFwcHJvdmFsSWRUb1Rvb2xOYW1lW3BhcnQuYXBwcm92YWxJZF0gPSB0b29sQ2FsbElkVG9Ub29sTmFtZVtwYXJ0LnRvb2xDYWxsSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikgJiYga2VwdFRvb2xDYWxsSWRzLmhhcyhwYXJ0LnRvb2xDYWxsSWQpIHx8IChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIikgJiYga2VwdEFwcHJvdmFsSWRzLmhhcyhwYXJ0LmFwcHJvdmFsSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvb2xDYWxsLnRvb2xzICE9IG51bGwgJiYgIXRvb2xDYWxsLnRvb2xzLmluY2x1ZGVzKFxuICAgICAgICAgICAgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gcGFydC50b29sTmFtZSA6IGFwcHJvdmFsSWRUb1Rvb2xOYW1lW3BhcnQuYXBwcm92YWxJZF1cbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBpZiAoZW1wdHlNZXNzYWdlcyA9PT0gXCJyZW1vdmVcIikge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQubGVuZ3RoID4gMCk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zbW9vdGgtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBvcmlnaW5hbERlbGF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgQ0hVTktJTkdfUkVHRVhQUyA9IHtcbiAgd29yZDogL1xcUytcXHMrL20sXG4gIGxpbmU6IC9cXG4rL21cbn07XG5mdW5jdGlvbiBzbW9vdGhTdHJlYW0oe1xuICBkZWxheUluTXMgPSAxMCxcbiAgY2h1bmtpbmcgPSBcIndvcmRcIixcbiAgX2ludGVybmFsOiB7IGRlbGF5OiBkZWxheTIgPSBvcmlnaW5hbERlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBkZXRlY3RDaHVuaztcbiAgaWYgKGNodW5raW5nICE9IG51bGwgJiYgdHlwZW9mIGNodW5raW5nID09PSBcIm9iamVjdFwiICYmIFwic2VnbWVudFwiIGluIGNodW5raW5nICYmIHR5cGVvZiBjaHVua2luZy5zZWdtZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzZWdtZW50ZXIgPSBjaHVua2luZztcbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc2VnbWVudGVyLnNlZ21lbnQoYnVmZmVyKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICBjb25zdCBmaXJzdCA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiAoZmlyc3QgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0LnNlZ21lbnQpIHx8IG51bGw7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmtpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZyhidWZmZXIpO1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5raW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgbm9uLWVtcHR5IHN0cmluZy5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghYnVmZmVyLnN0YXJ0c1dpdGgobWF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBtYXRjaCB0aGF0IGlzIGEgcHJlZml4IG9mIHRoZSBidWZmZXIuIFJlY2VpdmVkOiBcIiR7bWF0Y2h9XCIgZXhwZWN0ZWQgdG8gc3RhcnQgd2l0aCBcIiR7YnVmZmVyfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2h1bmtpbmdSZWdleCA9IHR5cGVvZiBjaHVua2luZyA9PT0gXCJzdHJpbmdcIiA/IENIVU5LSU5HX1JFR0VYUFNbY2h1bmtpbmddIDogY2h1bmtpbmcgaW5zdGFuY2VvZiBSZWdFeHAgPyBjaHVua2luZyA6IHZvaWQgMDtcbiAgICBpZiAoY2h1bmtpbmdSZWdleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgICAgYXJndW1lbnQ6IFwiY2h1bmtpbmdcIixcbiAgICAgICAgbWVzc2FnZTogYENodW5raW5nIG11c3QgYmUgXCJ3b3JkXCIsIFwibGluZVwiLCBhIFJlZ0V4cCwgYW4gSW50bC5TZWdtZW50ZXIsIG9yIGEgQ2h1bmtEZXRlY3RvciBmdW5jdGlvbi4gUmVjZWl2ZWQ6ICR7Y2h1bmtpbmd9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZ1JlZ2V4LmV4ZWMoYnVmZmVyKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIChtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2hbMF0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGxldCB0eXBlID0gdm9pZCAwO1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGZsdXNoQnVmZmVyKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCAmJiB0eXBlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRleHQ6IGJ1ZmZlcixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICAuLi5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dC1kZWx0YVwiICYmIGNodW5rLnR5cGUgIT09IFwicmVhc29uaW5nLWRlbHRhXCIpIHtcbiAgICAgICAgICBmbHVzaEJ1ZmZlcihjb250cm9sbGVyKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNodW5rLnR5cGUgIT09IHR5cGUgfHwgY2h1bmsuaWQgIT09IGlkKSAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZsdXNoQnVmZmVyKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0O1xuICAgICAgICBpZCA9IGNodW5rLmlkO1xuICAgICAgICB0eXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgaWYgKGNodW5rLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGRldGVjdENodW5rKGJ1ZmZlcikpICE9IG51bGwpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlLCB0ZXh0OiBtYXRjaCwgaWQgfSk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgYXdhaXQgZGVsYXkyKGRlbGF5SW5Ncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1lbWJlZGRpbmctc2V0dGluZ3MtbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdEVtYmVkZGluZ1NldHRpbmdzTWlkZGxld2FyZSh7XG4gIHNldHRpbmdzXG59KSB7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB0cmFuc2Zvcm1QYXJhbXM6IGFzeW5jICh7IHBhcmFtcyB9KSA9PiB7XG4gICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKHNldHRpbmdzLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoc2V0dGluZ3MsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LWpzb24tbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSh0ZXh0Mikge1xuICByZXR1cm4gdGV4dDIucmVwbGFjZSgvXmBgYCg/Ompzb24pP1xccypcXG4/LywgXCJcIikucmVwbGFjZSgvXFxuP2BgYFxccyokLywgXCJcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEpzb25NaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IChfYTE3ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9IG51bGwgPyBfYTE3IDogZGVmYXVsdFRyYW5zZm9ybTtcbiAgY29uc3QgaGFzQ3VzdG9tVHJhbnNmb3JtID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgLi4ucmVzdCB9ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRDb250ZW50ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIHRleHQ6IHRyYW5zZm9ybShwYXJ0LnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSB7fTtcbiAgICAgIGNvbnN0IFNVRkZJWF9CVUZGRVJfU0laRSA9IDEyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2tzW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHRyYW5zZm9ybXMgbmVlZCB0byBidWZmZXIgYWxsIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHBoYXNlOiBoYXNDdXN0b21UcmFuc2Zvcm0gPyBcImJ1ZmZlcmluZ1wiIDogXCJwcmVmaXhcIixcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgIHByZWZpeFN0cmlwcGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2suYnVmZmVyICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5idWZmZXIubGVuZ3RoID4gMCAmJiAhYmxvY2suYnVmZmVyLnN0YXJ0c1dpdGgoXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIuc3RhcnRzV2l0aChcImBgYFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2suYnVmZmVyLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4TWF0Y2ggPSBibG9jay5idWZmZXIubWF0Y2goL15gYGAoPzpqc29uKT9cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeE1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnByZWZpeFN0cmlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShibG9jay5zdGFydEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIubGVuZ3RoID49IDMgJiYgIWJsb2NrLmJ1ZmZlci5zdGFydHNXaXRoKFwiYGBgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwic3RyZWFtaW5nXCIgJiYgYmxvY2suYnVmZmVyLmxlbmd0aCA+IFNVRkZJWF9CVUZGRVJfU0laRSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9TdHJlYW0gPSBibG9jay5idWZmZXIuc2xpY2UoMCwgLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogdG9TdHJlYW1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIgfHwgYmxvY2sucGhhc2UgPT09IFwiYnVmZmVyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGJsb2NrLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSB0cmFuc2Zvcm0ocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sucHJlZml4U3RyaXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1xcbj9gYGBcXHMqJC8sIFwiXCIpLnRyaW1FbmQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHRyYW5zZm9ybShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRleHRCbG9ja3NbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9nZXQtcG90ZW50aWFsLXN0YXJ0LWluZGV4LnRzXG5mdW5jdGlvbiBnZXRQb3RlbnRpYWxTdGFydEluZGV4KHRleHQyLCBzZWFyY2hlZFRleHQpIHtcbiAgaWYgKHNlYXJjaGVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXJlY3RJbmRleCA9IHRleHQyLmluZGV4T2Yoc2VhcmNoZWRUZXh0KTtcbiAgaWYgKGRpcmVjdEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkaXJlY3RJbmRleDtcbiAgfVxuICBmb3IgKGxldCBpID0gdGV4dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdWZmaXggPSB0ZXh0Mi5zdWJzdHJpbmcoaSk7XG4gICAgaWYgKHNlYXJjaGVkVGV4dC5zdGFydHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZXh0cmFjdC1yZWFzb25pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUoe1xuICB0YWdOYW1lLFxuICBzZXBhcmF0b3IgPSBcIlxcblwiLFxuICBzdGFydFdpdGhSZWFzb25pbmcgPSBmYWxzZVxufSkge1xuICBjb25zdCBvcGVuaW5nVGFnID0gYDwke3RhZ05hbWV9PmA7XG4gIGNvbnN0IGNsb3NpbmdUYWcgPSBgPC8ke3RhZ05hbWV9PmA7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB3cmFwR2VuZXJhdGU6IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBjb250ZW50LCAuLi5yZXN0IH0gPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZENvbnRlbnQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dDIgPSBzdGFydFdpdGhSZWFzb25pbmcgPyBvcGVuaW5nVGFnICsgcGFydC50ZXh0IDogcGFydC50ZXh0O1xuICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAke29wZW5pbmdUYWd9KC4qPykke2Nsb3NpbmdUYWd9YCwgXCJnc1wiKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odGV4dDIubWF0Y2hBbGwocmVnZXhwKSk7XG4gICAgICAgIGlmICghbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFzb25pbmdUZXh0ID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaFsxXSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBsZXQgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSB0ZXh0MjtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgY29uc3QgYmVmb3JlTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgY29uc3QgYWZ0ZXJNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKFxuICAgICAgICAgICAgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIHRleHRXaXRob3V0UmVhc29uaW5nID0gYmVmb3JlTWF0Y2ggKyAoYmVmb3JlTWF0Y2gubGVuZ3RoID4gMCAmJiBhZnRlck1hdGNoLmxlbmd0aCA+IDAgPyBzZXBhcmF0b3IgOiBcIlwiKSArIGFmdGVyTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgdGV4dDogcmVhc29uaW5nVGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHRleHRXaXRob3V0UmVhc29uaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHJlYXNvbmluZ0V4dHJhY3Rpb25zID0ge307XG4gICAgICBsZXQgZGVsYXllZFRleHRTdGFydDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiICYmIGRlbGF5ZWRUZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGVsYXllZFRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0UmVhc29uaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaXNGaXJzdFRleHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBpc1JlYXNvbmluZzogc3RhcnRXaXRoUmVhc29uaW5nLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgaWRDb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgICAgdGV4dElkOiBjaHVuay5pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRXh0cmFjdGlvbiA9IHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2godGV4dDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCAmJiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcgOiAhYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCkgPyBzZXBhcmF0b3IgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgJiYgKGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggfHwgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGByZWFzb25pbmctJHthY3RpdmVFeHRyYWN0aW9uLmlkQ291bnRlcn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBwcmVmaXggKyB0ZXh0MixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBhY3RpdmVFeHRyYWN0aW9uLnRleHRJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhZyA9IGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPyBjbG9zaW5nVGFnIDogb3BlbmluZ1RhZztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gZ2V0UG90ZW50aWFsU3RhcnRJbmRleChcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgbmV4dFRhZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRGdWxsTWF0Y2ggPSBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGggPD0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgPSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCArIG5leHRUYWcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyKyt9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPSAhYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZztcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvc2ltdWxhdGUtc3RyZWFtaW5nLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgbGV0IGlkID0gMDtcbiAgICAgIGNvbnN0IHNpbXVsYXRlZFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJzdHJlYW0tc3RhcnRcIixcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlc3BvbnNlLW1ldGFkYXRhXCIsIC4uLnJlc3VsdC5yZXNwb25zZSB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1zdGFydFwiLCBpZDogU3RyaW5nKGlkKSB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXG4gICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgIGlkKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2UsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHNpbXVsYXRlZFN0cmVhbSxcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzcG9uc2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9hZGQtdG9vbC1pbnB1dC1leGFtcGxlcy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0Rm9ybWF0RXhhbXBsZShleGFtcGxlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShleGFtcGxlLmlucHV0KTtcbn1cbmZ1bmN0aW9uIGFkZFRvb2xJbnB1dEV4YW1wbGVzTWlkZGxld2FyZSh7XG4gIHByZWZpeCA9IFwiSW5wdXQgRXhhbXBsZXM6XCIsXG4gIGZvcm1hdCA9IGRlZmF1bHRGb3JtYXRFeGFtcGxlLFxuICByZW1vdmUgPSB0cnVlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgaWYgKCEoKF9hMTcgPSBwYXJhbXMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBwYXJhbXMudG9vbHMubWFwKCh0b29sMikgPT4ge1xuICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgaWYgKHRvb2wyLnR5cGUgIT09IFwiZnVuY3Rpb25cIiB8fCAhKChfYTE4ID0gdG9vbDIuaW5wdXRFeGFtcGxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTgubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiB0b29sMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IHRvb2wyLmlucHV0RXhhbXBsZXMubWFwKChleGFtcGxlLCBpbmRleCkgPT4gZm9ybWF0KGV4YW1wbGUsIGluZGV4KSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZXNTZWN0aW9uID0gYCR7cHJlZml4fVxuJHtmb3JtYXR0ZWRFeGFtcGxlc31gO1xuICAgICAgICBjb25zdCB0b29sRGVzY3JpcHRpb24gPSB0b29sMi5kZXNjcmlwdGlvbiA/IGAke3Rvb2wyLmRlc2NyaXB0aW9ufVxuXG4ke2V4YW1wbGVzU2VjdGlvbn1gIDogZXhhbXBsZXNTZWN0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRvb2wyLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sRGVzY3JpcHRpb24sXG4gICAgICAgICAgaW5wdXRFeGFtcGxlczogcmVtb3ZlID8gdm9pZCAwIDogdG9vbDIuaW5wdXRFeGFtcGxlc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHRvb2xzOiB0cmFuc2Zvcm1lZFRvb2xzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1sYW5ndWFnZS1tb2RlbC50c1xudmFyIHdyYXBMYW5ndWFnZU1vZGVsID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmVBcmcsXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgcmV0dXJuIFsuLi5hc0FycmF5KG1pZGRsZXdhcmVBcmcpXS5yZXZlcnNlKCkucmVkdWNlKCh3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUpID0+IHtcbiAgICByZXR1cm4gZG9XcmFwKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZToge1xuICAgIHRyYW5zZm9ybVBhcmFtcyxcbiAgICB3cmFwR2VuZXJhdGUsXG4gICAgd3JhcFN0cmVhbSxcbiAgICBvdmVycmlkZVByb3ZpZGVyLFxuICAgIG92ZXJyaWRlTW9kZWxJZCxcbiAgICBvdmVycmlkZVN1cHBvcnRlZFVybHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2ExNywgX2IsIF9jO1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIHR5cGUsIG1vZGVsIH0pIDogcGFyYW1zO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBwcm92aWRlcjogKF9hMTcgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IChfYiA9IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBvdmVycmlkZU1vZGVsSWQgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTW9kZWxJZCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgIHN1cHBvcnRlZFVybHM6IChfYyA9IG92ZXJyaWRlU3VwcG9ydGVkVXJscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYyA6IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwiZ2VuZXJhdGVcIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIGRvU3RyZWFtLFxuICAgICAgICBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLFxuICAgICAgICBtb2RlbFxuICAgICAgfSkgOiBkb0dlbmVyYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBkb1N0cmVhbShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwic3RyZWFtXCIgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICBjb25zdCBkb1N0cmVhbSA9IGFzeW5jICgpID0+IG1vZGVsLmRvU3RyZWFtKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwU3RyZWFtID8gd3JhcFN0cmVhbSh7IGRvR2VuZXJhdGUsIGRvU3RyZWFtLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvU3RyZWFtKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1lbWJlZGRpbmctbW9kZWwudHNcbnZhciB3cmFwRW1iZWRkaW5nTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAyKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAyID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEVtYmVkLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oe1xuICAgIHBhcmFtc1xuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2ExNyA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTE3IDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IChfYyA9IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgc3VwcG9ydHNQYXJhbGxlbENhbGxzOiAoX2QgPSBvdmVycmlkZVN1cHBvcnRzUGFyYWxsZWxDYWxscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9kIDogbW9kZWwuc3VwcG9ydHNQYXJhbGxlbENhbGxzLFxuICAgIGFzeW5jIGRvRW1iZWQocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9FbWJlZCA9IGFzeW5jICgpID0+IG1vZGVsLmRvRW1iZWQodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBFbWJlZCA/IHdyYXBFbWJlZCh7XG4gICAgICAgIGRvRW1iZWQsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvRW1iZWQoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLWltYWdlLW1vZGVsLnRzXG52YXIgd3JhcEltYWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAzKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAzID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEdlbmVyYXRlLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbFxuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3LCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCBtb2RlbCB9KSA6IHBhcmFtcztcbiAgfVxuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsUmF3ID0gKF9hMTcgPSBvdmVycmlkZU1heEltYWdlc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IG1vZGVsLm1heEltYWdlc1BlckNhbGw7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGwgPSBtYXhJbWFnZXNQZXJDYWxsUmF3IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBtYXhJbWFnZXNQZXJDYWxsUmF3LmJpbmQobW9kZWwpIDogbWF4SW1hZ2VzUGVyQ2FsbFJhdztcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2IgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiAoX2MgPSBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogb3ZlcnJpZGVNb2RlbElkID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZU1vZGVsSWQoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubW9kZWxJZCxcbiAgICBtYXhJbWFnZXNQZXJDYWxsLFxuICAgIGFzeW5jIGRvR2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbW9kZWwvYXMtcHJvdmlkZXItdjMudHNcbmZ1bmN0aW9uIGFzUHJvdmlkZXJWMyhwcm92aWRlcikge1xuICBpZiAoXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiIGluIHByb3ZpZGVyICYmIHByb3ZpZGVyLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgY29uc3QgdjJQcm92aWRlciA9IHByb3ZpZGVyO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgbGFuZ3VhZ2VNb2RlbDogKG1vZGVsSWQpID0+IGFzTGFuZ3VhZ2VNb2RlbFYzKHYyUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IChtb2RlbElkKSA9PiBhc0VtYmVkZGluZ01vZGVsVjModjJQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkpLFxuICAgIGltYWdlTW9kZWw6IChtb2RlbElkKSA9PiBhc0ltYWdlTW9kZWxWMyh2MlByb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCkpLFxuICAgIHRyYW5zY3JpcHRpb25Nb2RlbDogdjJQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyh2MlByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKSkgOiB2b2lkIDAsXG4gICAgc3BlZWNoTW9kZWw6IHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNTcGVlY2hNb2RlbFYzKHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCkpIDogdm9pZCAwLFxuICAgIHJlcmFua2luZ01vZGVsOiB2b2lkIDBcbiAgICAvLyB2MiBwcm92aWRlcnMgZG9uJ3QgaGF2ZSByZXJhbmtpbmcgbW9kZWxzXG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtcHJvdmlkZXIudHNcbmZ1bmN0aW9uIHdyYXBQcm92aWRlcih7XG4gIHByb3ZpZGVyLFxuICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbn0pIHtcbiAgY29uc3QgcHJvdmlkZXJWMyA9IGFzUHJvdmlkZXJWMyhwcm92aWRlcik7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBsYW5ndWFnZU1vZGVsOiAobW9kZWxJZCkgPT4gd3JhcExhbmd1YWdlTW9kZWwoe1xuICAgICAgbW9kZWw6IHByb3ZpZGVyVjMubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgfSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IHByb3ZpZGVyVjMuZW1iZWRkaW5nTW9kZWwsXG4gICAgaW1hZ2VNb2RlbDogKG1vZGVsSWQpID0+IHtcbiAgICAgIGxldCBtb2RlbCA9IHByb3ZpZGVyVjMuaW1hZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIGlmIChpbWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICAgIG1vZGVsID0gd3JhcEltYWdlTW9kZWwoeyBtb2RlbCwgbWlkZGxld2FyZTogaW1hZ2VNb2RlbE1pZGRsZXdhcmUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWw6IHByb3ZpZGVyVjMudHJhbnNjcmlwdGlvbk1vZGVsLFxuICAgIHNwZWVjaE1vZGVsOiBwcm92aWRlclYzLnNwZWVjaE1vZGVsLFxuICAgIHJlcmFua2luZ01vZGVsOiBwcm92aWRlclYzLnJlcmFua2luZ01vZGVsXG4gIH07XG59XG5cbi8vIHNyYy9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7XG4gIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGN1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIGVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIHRyYW5zY3JpcHRpb25Nb2RlbHMsXG4gIHNwZWVjaE1vZGVscyxcbiAgcmVyYW5raW5nTW9kZWxzLFxuICBmYWxsYmFja1Byb3ZpZGVyOiBmYWxsYmFja1Byb3ZpZGVyQXJnXG59KSB7XG4gIGNvbnN0IGZhbGxiYWNrUHJvdmlkZXIgPSBmYWxsYmFja1Byb3ZpZGVyQXJnID8gYXNQcm92aWRlclYzKGZhbGxiYWNrUHJvdmlkZXJBcmcpIDogdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgbGFuZ3VhZ2VNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAobGFuZ3VhZ2VNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGxhbmd1YWdlTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmxhbmd1YWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgZW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gZW1iZWRkaW5nTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBlbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5lbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJlbWJlZGRpbmdNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgaW1hZ2VNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAoaW1hZ2VNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGltYWdlTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBpbWFnZU1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuaW1hZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJpbWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRyYW5zY3JpcHRpb25Nb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRyYW5zY3JpcHRpb25Nb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY3JpcHRpb25Nb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgc3BlZWNoTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHNwZWVjaE1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gc3BlZWNoTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5zcGVlY2hNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5zcGVlY2hNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJzcGVlY2hNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgcmVyYW5raW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHJlcmFua2luZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gcmVyYW5raW5nTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiByZXJhbmtpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5yZXJhbmtpbmdNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5yZXJhbmtpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJyZXJhbmtpbmdNb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcblxuLy8gc3JjL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIxLCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTYgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIxNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTZ9YDtcbnZhciBzeW1ib2wxNiA9IFN5bWJvbC5mb3IobWFya2VyMTYpO1xudmFyIF9hMTY7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMTYsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTZdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE2KTtcbiAgfVxufTtcbl9hMTYgPSBzeW1ib2wxNjtcblxuLy8gc3JjL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQge1xuICBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycywge1xuICBzZXBhcmF0b3IgPSBcIjpcIixcbiAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUsXG4gIGltYWdlTW9kZWxNaWRkbGV3YXJlXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvcixcbiAgICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgICBpbWFnZU1vZGVsTWlkZGxld2FyZVxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlLFxuICAgIGltYWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgIHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgPSBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgICB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlID0gaW1hZ2VNb2RlbE1pZGRsZXdhcmU7XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7XG4gICAgaWQsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKHRoaXMuc2VwYXJhdG9yKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZCR7dGhpcy5zZXBhcmF0b3J9bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyB0aGlzLnNlcGFyYXRvci5sZW5ndGgpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTcsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGxldCBtb2RlbCA9IChfYiA9IChfYTE3ID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImxhbmd1YWdlTW9kZWxcIikpLmxhbmd1YWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKFxuICAgICAgX2ExNyxcbiAgICAgIG1vZGVsSWRcbiAgICApO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwTGFuZ3VhZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5lbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwiZW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBpbWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwiaW1hZ2VNb2RlbFwiKTtcbiAgICBsZXQgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLmltYWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwSW1hZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRyYW5zY3JpcHRpb25Nb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwidHJhbnNjcmlwdGlvbk1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHNwZWVjaE1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJlcmFua2luZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5yZXJhbmtpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwicmVyYW5raW5nTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59O1xuXG4vLyBzcmMvcmVyYW5rL3JlcmFuay50c1xuYXN5bmMgZnVuY3Rpb24gcmVyYW5rKHtcbiAgbW9kZWwsXG4gIGRvY3VtZW50cyxcbiAgcXVlcnksXG4gIHRvcE4sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRGVmYXVsdFJlcmFua1Jlc3VsdCh7XG4gICAgICBvcmlnaW5hbERvY3VtZW50czogW10sXG4gICAgICByYW5raW5nOiBbXSxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgZG9jdW1lbnRzVG9TZW5kID0gdHlwZW9mIGRvY3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlczogZG9jdW1lbnRzIH0gOiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlczogZG9jdW1lbnRzIH07XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnJlcmFua1wiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5yZXJhbmtcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS5kb2N1bWVudHNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBkb2N1bWVudHMubWFwKChkb2N1bWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZG9jdW1lbnQpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2I7XG4gICAgICBjb25zdCB7IHJhbmtpbmcsIHJlc3BvbnNlLCBwcm92aWRlck1ldGFkYXRhLCB3YXJuaW5ncyB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICBcImFpLmRvY3VtZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGRvY3VtZW50cy5tYXAoKGRvY3VtZW50KSA9PiBKU09OLnN0cmluZ2lmeShkb2N1bWVudCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1JlcmFua1NwYW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb1JlcmFuayh7XG4gICAgICAgICAgICAgIGRvY3VtZW50czogZG9jdW1lbnRzVG9TZW5kLFxuICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgdG9wTixcbiAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByYW5raW5nMiA9IG1vZGVsUmVzcG9uc2UucmFua2luZztcbiAgICAgICAgICAgIGRvUmVyYW5rU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yYW5raW5nLnR5cGVcIjogZG9jdW1lbnRzVG9TZW5kLnR5cGUsXG4gICAgICAgICAgICAgICAgICBcImFpLnJhbmtpbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJhbmtpbmcyLm1hcCgocmFua2luZzMpID0+IEpTT04uc3RyaW5naWZ5KHJhbmtpbmczKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmFua2luZzogcmFua2luZzIsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSxcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRSZXJhbmtSZXN1bHQoe1xuICAgICAgICBvcmlnaW5hbERvY3VtZW50czogZG9jdW1lbnRzLFxuICAgICAgICByYW5raW5nOiByYW5raW5nLm1hcCgocmFua2luZzIpID0+ICh7XG4gICAgICAgICAgb3JpZ2luYWxJbmRleDogcmFua2luZzIuaW5kZXgsXG4gICAgICAgICAgc2NvcmU6IHJhbmtpbmcyLnJlbGV2YW5jZVNjb3JlLFxuICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudHNbcmFua2luZzIuaW5kZXhdXG4gICAgICAgIH0pKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICBpZDogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogKF9hMTcgPSByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UudGltZXN0YW1wKSAhPSBudWxsID8gX2ExNyA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IChfYiA9IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5tb2RlbElkKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFJlcmFua1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3JpZ2luYWxEb2N1bWVudHMgPSBvcHRpb25zLm9yaWdpbmFsRG9jdW1lbnRzO1xuICAgIHRoaXMucmFua2luZyA9IG9wdGlvbnMucmFua2luZztcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHJlcmFua2VkRG9jdW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmtpbmcubWFwKChyYW5raW5nKSA9PiByYW5raW5nLmRvY3VtZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3RyYW5zY3JpYmUvdHJhbnNjcmliZS50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4OCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9lcnJvci9uby10cmFuc2NyaXB0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIE5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMjIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJBSV9Ob1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJObyB0cmFuc2NyaXB0IGdlbmVyYXRlZC5cIlxuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy90cmFuc2NyaWJlL3RyYW5zY3JpYmUudHNcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmUoe1xuICBtb2RlbCxcbiAgYXVkaW8sXG4gIHByb3ZpZGVyT3B0aW9ucyA9IHt9LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICBjb25zdCByZXNvbHZlZE1vZGVsID0gcmVzb2x2ZVRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbCk7XG4gIGlmICghcmVzb2x2ZWRNb2RlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGNvdWxkIG5vdCBiZSByZXNvbHZlZFwiKTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4OChcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvIGluc3RhbmNlb2YgVVJMID8gKGF3YWl0IGRvd25sb2FkKHsgdXJsOiBhdWRpbyB9KSkuZGF0YSA6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShhdWRpbyk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgcmV0dXJuIHJlc29sdmVkTW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb0RhdGEsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiBhdWRpb0RhdGEsXG4gICAgICAgICAgc2lnbmF0dXJlczogYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vd2F2XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcHJvdmlkZXI6IHJlc29sdmVkTW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWw6IHJlc29sdmVkTW9kZWwubW9kZWxJZFxuICB9KTtcbiAgaWYgKCFyZXN1bHQudGV4dCkge1xuICAgIHRocm93IG5ldyBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCh7XG4gICAgdGV4dDogcmVzdWx0LnRleHQsXG4gICAgc2VnbWVudHM6IHJlc3VsdC5zZWdtZW50cyxcbiAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgIGR1cmF0aW9uSW5TZWNvbmRzOiByZXN1bHQuZHVyYXRpb25JblNlY29uZHMsXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMuc2VnbWVudHMgPSBvcHRpb25zLnNlZ21lbnRzO1xuICAgIHRoaXMubGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xuICAgIHRoaXMuZHVyYXRpb25JblNlY29uZHMgPSBvcHRpb25zLmR1cmF0aW9uSW5TZWNvbmRzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG5pbXBvcnQge1xuICBwYXJzZUpzb25FdmVudFN0cmVhbSxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4OSxcbiAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50IGFzIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL3Byb2Nlc3MtdGV4dC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGF3YWl0IG9uVGV4dFBhcnQodmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSB7XG4gIHZhciBfYTE3O1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXg5KFxuICAgICAgICB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBgYWktc2RrLyR7VkVSU0lPTn1gLFxuICAgICAgICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQyKClcbiAgICAgICksXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2ExNyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hMTcgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBzY2hlbWE6IHVpTWVzc2FnZUNodW5rU2NoZW1hXG4gICAgICAgICAgfSkucGlwZVRocm91Z2goXG4gICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgcGFydC5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtUGFydCA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJlYW1QYXJ0LmRlbHRhO1xuICAgICAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJlYW1QYXJ0LmVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2hhdC50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYzJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL2NvbnZlcnQtZmlsZS1saXN0LXRvLWZpbGUtdWktcGFydHMudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMoZmlsZXMpIHtcbiAgaWYgKGZpbGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLkZpbGVMaXN0IHx8ICEoZmlsZXMgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbGVMaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGVMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIEFycmF5LmZyb20oZmlsZXMpLm1hcChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lOiBuYW1lMTcsIHR5cGUgfSA9IGZpbGU7XG4gICAgICBjb25zdCBkYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUzLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChyZWFkZXJFdmVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgIHJlc29sdmUzKChfYTE3ID0gcmVhZGVyRXZlbnQudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IHR5cGUsXG4gICAgICAgIGZpbGVuYW1lOiBuYW1lMTcsXG4gICAgICAgIHVybDogZGF0YVVybFxuICAgICAgfTtcbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWkvZGVmYXVsdC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHsgcGFyc2VKc29uRXZlbnRTdHJlYW0gYXMgcGFyc2VKc29uRXZlbnRTdHJlYW0yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL2h0dHAtY2hhdC10cmFuc3BvcnQudHNcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUhlYWRlcnMsXG4gIHJlc29sdmUgYXMgcmVzb2x2ZTIsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDEwLFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQgYXMgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50M1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIEh0dHBDaGF0VHJhbnNwb3J0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gICAgZmV0Y2g6IGZldGNoMixcbiAgICBwcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCxcbiAgICBwcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0XG4gIH0pIHtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDI7XG4gICAgdGhpcy5wcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCA9IHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0O1xuICAgIHRoaXMucHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdCA9IHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgc2VuZE1lc3NhZ2VzKHtcbiAgICBhYm9ydFNpZ25hbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVzb2x2ZWRCb2R5ID0gYXdhaXQgcmVzb2x2ZTIodGhpcy5ib2R5KTtcbiAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICBjb25zdCBiYXNlSGVhZGVycyA9IHtcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMocmVzb2x2ZWRIZWFkZXJzKSxcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZXF1ZXN0ID0gYXdhaXQgKChfYTE3ID0gdGhpcy5wcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgaWQ6IG9wdGlvbnMuY2hhdElkLFxuICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICBib2R5OiB7IC4uLnJlc29sdmVkQm9keSwgLi4ub3B0aW9ucy5ib2R5IH0sXG4gICAgICBoZWFkZXJzOiBiYXNlSGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiByZXNvbHZlZENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdE1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhLFxuICAgICAgdHJpZ2dlcjogb3B0aW9ucy50cmlnZ2VyLFxuICAgICAgbWVzc2FnZUlkOiBvcHRpb25zLm1lc3NhZ2VJZFxuICAgIH0pKTtcbiAgICBjb25zdCBhcGkgPSAoX2IgPSBwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5hcGkpICE9IG51bGwgPyBfYiA6IHRoaXMuYXBpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSAocHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgIT09IHZvaWQgMCA/IG5vcm1hbGl6ZUhlYWRlcnMocHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpIDogYmFzZUhlYWRlcnM7XG4gICAgY29uc3QgYm9keSA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5ib2R5KSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmJvZHkgOiB7XG4gICAgICAuLi5yZXNvbHZlZEJvZHksXG4gICAgICAuLi5vcHRpb25zLmJvZHksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIHRyaWdnZXI6IG9wdGlvbnMudHJpZ2dlcixcbiAgICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWRcbiAgICB9O1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4MTAoXG4gICAgICAgIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDMoKVxuICAgICAgKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfZSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHJlc3BvbnNlLmJvZHkpO1xuICB9XG4gIGFzeW5jIHJlY29ubmVjdFRvU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVzb2x2ZWRCb2R5ID0gYXdhaXQgcmVzb2x2ZTIodGhpcy5ib2R5KTtcbiAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICBjb25zdCBiYXNlSGVhZGVycyA9IHtcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMocmVzb2x2ZWRIZWFkZXJzKSxcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZXF1ZXN0ID0gYXdhaXQgKChfYTE3ID0gdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBib2R5OiB7IC4uLnJlc29sdmVkQm9keSwgLi4ub3B0aW9ucy5ib2R5IH0sXG4gICAgICBoZWFkZXJzOiBiYXNlSGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiByZXNvbHZlZENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdE1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogYCR7dGhpcy5hcGl9LyR7b3B0aW9ucy5jaGF0SWR9L3N0cmVhbWA7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gbm9ybWFsaXplSGVhZGVycyhwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgOiBiYXNlSGVhZGVycztcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IChfYyA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmNyZWRlbnRpYWxzKSAhPSBudWxsID8gX2MgOiByZXNvbHZlZENyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGZldGNoMiA9IChfZCA9IHRoaXMuZmV0Y2gpICE9IG51bGwgPyBfZCA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4MTAoXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDMoKVxuICAgICAgKSxcbiAgICAgIGNyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfZSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHJlc3BvbnNlLmJvZHkpO1xuICB9XG59O1xuXG4vLyBzcmMvdWkvZGVmYXVsdC1jaGF0LXRyYW5zcG9ydC50c1xudmFyIERlZmF1bHRDaGF0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBIdHRwQ2hhdFRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHByb2Nlc3NSZXNwb25zZVN0cmVhbShzdHJlYW0pIHtcbiAgICByZXR1cm4gcGFyc2VKc29uRXZlbnRTdHJlYW0yKHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIHNjaGVtYTogdWlNZXNzYWdlQ2h1bmtTY2hlbWFcbiAgICB9KS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IGNodW5rLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jaGF0LnRzXG52YXIgQWJzdHJhY3RDaGF0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuYzIsXG4gICAgaWQgPSBnZW5lcmF0ZUlkMigpLFxuICAgIHRyYW5zcG9ydCA9IG5ldyBEZWZhdWx0Q2hhdFRyYW5zcG9ydCgpLFxuICAgIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICBkYXRhUGFydFNjaGVtYXMsXG4gICAgc3RhdGUsXG4gICAgb25FcnJvcixcbiAgICBvblRvb2xDYWxsLFxuICAgIG9uRmluaXNoLFxuICAgIG9uRGF0YSxcbiAgICBzZW5kQXV0b21hdGljYWxseVdoZW5cbiAgfSkge1xuICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5qb2JFeGVjdXRvciA9IG5ldyBTZXJpYWxKb2JFeGVjdXRvcigpO1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgb3IgcmVwbGFjZXMgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBJZiBhIG1lc3NhZ2VJZCBpcyBwcm92aWRlZCwgdGhlIG1lc3NhZ2Ugd2lsbCBiZSByZXBsYWNlZC5cbiAgICAgKi9cbiAgICB0aGlzLnNlbmRNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgbWVzc2FnZUlkOiAoX2ExNyA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmlkLFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB1aU1lc3NhZ2U7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gbWVzc2FnZSB8fCBcImZpbGVzXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWxlUGFydHMgPSBBcnJheS5pc0FycmF5KG1lc3NhZ2UuZmlsZXMpID8gbWVzc2FnZS5maWxlcyA6IGF3YWl0IGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMobWVzc2FnZS5maWxlcyk7XG4gICAgICAgIHVpTWVzc2FnZSA9IHtcbiAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgLi4uZmlsZVBhcnRzLFxuICAgICAgICAgICAgLi4uXCJ0ZXh0XCIgaW4gbWVzc2FnZSAmJiBtZXNzYWdlLnRleHQgIT0gbnVsbCA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLnRleHQgfV0gOiBbXVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVpTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5tZXNzYWdlSWQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLmZpbmRJbmRleChcbiAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gbWVzc2FnZS5tZXNzYWdlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1lc3NhZ2Ugd2l0aCBpZCAke21lc3NhZ2UubWVzc2FnZUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZXNzYWdlc1ttZXNzYWdlSW5kZXhdLnJvbGUgIT09IFwidXNlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYG1lc3NhZ2Ugd2l0aCBpZCAke21lc3NhZ2UubWVzc2FnZUlkfSBpcyBub3QgYSB1c2VyIG1lc3NhZ2VgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlSW5kZXggKyAxKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZXBsYWNlTWVzc2FnZShtZXNzYWdlSW5kZXgsIHtcbiAgICAgICAgICAuLi51aU1lc3NhZ2UsXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UubWVzc2FnZUlkLFxuICAgICAgICAgIHJvbGU6IChfYiA9IHVpTWVzc2FnZS5yb2xlKSAhPSBudWxsID8gX2IgOiBcInVzZXJcIixcbiAgICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5tZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUucHVzaE1lc3NhZ2Uoe1xuICAgICAgICAgIC4uLnVpTWVzc2FnZSxcbiAgICAgICAgICBpZDogKF9jID0gdWlNZXNzYWdlLmlkKSAhPSBudWxsID8gX2MgOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAoX2QgPSB1aU1lc3NhZ2Uucm9sZSkgIT0gbnVsbCA/IF9kIDogXCJ1c2VyXCIsXG4gICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2UubWVzc2FnZUlkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgdGhlIGFzc2lzdGFudCBtZXNzYWdlIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UgaWQuXG4gICAgICogSWYgbm8gbWVzc2FnZSBpZCBpcyBwcm92aWRlZCwgdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2Ugd2lsbCBiZSByZWdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnJlZ2VuZXJhdGUgPSBhc3luYyAoe1xuICAgICAgbWVzc2FnZUlkLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gbWVzc2FnZUlkID09IG51bGwgPyB0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDEgOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLmZpbmRJbmRleCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbWVzc2FnZUlkKTtcbiAgICAgIGlmIChtZXNzYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWVzc2FnZSAke21lc3NhZ2VJZH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5zbGljZShcbiAgICAgICAgMCxcbiAgICAgICAgLy8gaWYgdGhlIG1lc3NhZ2UgaXMgYSB1c2VyIG1lc3NhZ2UsIHdlIG5lZWQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgcmVxdWVzdDpcbiAgICAgICAgdGhpcy5tZXNzYWdlc1ttZXNzYWdlSW5kZXhdLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgPyBtZXNzYWdlSW5kZXggOiBtZXNzYWdlSW5kZXggKyAxXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgIHRyaWdnZXI6IFwicmVnZW5lcmF0ZS1tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIHJlc3VtZSBhbiBvbmdvaW5nIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VtZVN0cmVhbSA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoeyB0cmlnZ2VyOiBcInJlc3VtZS1zdHJlYW1cIiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBlcnJvciBzdGF0ZSBhbmQgc2V0IHRoZSBzdGF0dXMgdG8gcmVhZHkgaWYgdGhlIGNoYXQgaXMgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAgICovXG4gICAgdGhpcy5jbGVhckVycm9yID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5lcnJvciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwicmVhZHlcIiB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkVG9vbEFwcHJvdmFsUmVzcG9uc2UgPSBhc3luYyAoe1xuICAgICAgaWQsXG4gICAgICBhcHByb3ZlZCxcbiAgICAgIHJlYXNvblxuICAgIH0pID0+IHRoaXMuam9iRXhlY3V0b3IucnVuKGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB1cGRhdGVQYXJ0ID0gKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnN0YXRlID09PSBcImFwcHJvdmFsLXJlcXVlc3RlZFwiICYmIHBhcnQuYXBwcm92YWwuaWQgPT09IGlkID8ge1xuICAgICAgICAuLi5wYXJ0LFxuICAgICAgICBzdGF0ZTogXCJhcHByb3ZhbC1yZXNwb25kZWRcIixcbiAgICAgICAgYXBwcm92YWw6IHsgaWQsIGFwcHJvdmVkLCByZWFzb24gfVxuICAgICAgfSA6IHBhcnQ7XG4gICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VzLmxlbmd0aCAtIDEsIHtcbiAgICAgICAgLi4ubGFzdE1lc3NhZ2UsXG4gICAgICAgIHBhcnRzOiBsYXN0TWVzc2FnZS5wYXJ0cy5tYXAodXBkYXRlUGFydClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIiAmJiAoKF9hMTcgPSB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7IG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzIH0pKSkge1xuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgbWVzc2FnZUlkOiAoX2IgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRUb29sT3V0cHV0ID0gYXN5bmMgKHtcbiAgICAgIHN0YXRlID0gXCJvdXRwdXQtYXZhaWxhYmxlXCIsXG4gICAgICB0b29sOiB0b29sMixcbiAgICAgIHRvb2xDYWxsSWQsXG4gICAgICBvdXRwdXQsXG4gICAgICBlcnJvclRleHRcbiAgICB9KSA9PiB0aGlzLmpvYkV4ZWN1dG9yLnJ1bihhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2I7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXM7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgdXBkYXRlUGFydCA9IChwYXJ0KSA9PiBpc1Rvb2xVSVBhcnQocGFydCkgJiYgcGFydC50b29sQ2FsbElkID09PSB0b29sQ2FsbElkID8geyAuLi5wYXJ0LCBzdGF0ZSwgb3V0cHV0LCBlcnJvclRleHQgfSA6IHBhcnQ7XG4gICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VzLmxlbmd0aCAtIDEsIHtcbiAgICAgICAgLi4ubGFzdE1lc3NhZ2UsXG4gICAgICAgIHBhcnRzOiBsYXN0TWVzc2FnZS5wYXJ0cy5tYXAodXBkYXRlUGFydClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIiAmJiAoKF9hMTcgPSB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7IG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzIH0pKSkge1xuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgbWVzc2FnZUlkOiAoX2IgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBhZGRUb29sT3V0cHV0ICovXG4gICAgdGhpcy5hZGRUb29sUmVzdWx0ID0gdGhpcy5hZGRUb29sT3V0cHV0O1xuICAgIC8qKlxuICAgICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgICAqL1xuICAgIHRoaXMuc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoKF9hMTcgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkMjtcbiAgICB0aGlzLm1lc3NhZ2VNZXRhZGF0YVNjaGVtYSA9IG1lc3NhZ2VNZXRhZGF0YVNjaGVtYTtcbiAgICB0aGlzLmRhdGFQYXJ0U2NoZW1hcyA9IGRhdGFQYXJ0U2NoZW1hcztcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICB0aGlzLm9uVG9vbENhbGwgPSBvblRvb2xDYWxsO1xuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDtcbiAgICB0aGlzLm9uRGF0YSA9IG9uRGF0YTtcbiAgICB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbiA9IHNlbmRBdXRvbWF0aWNhbGx5V2hlbjtcbiAgfVxuICAvKipcbiAgICogSG9vayBzdGF0dXM6XG4gICAqXG4gICAqIC0gYHN1Ym1pdHRlZGA6IFRoZSBtZXNzYWdlIGhhcyBiZWVuIHNlbnQgdG8gdGhlIEFQSSBhbmQgd2UncmUgYXdhaXRpbmcgdGhlIHN0YXJ0IG9mIHRoZSByZXNwb25zZSBzdHJlYW0uXG4gICAqIC0gYHN0cmVhbWluZ2A6IFRoZSByZXNwb25zZSBpcyBhY3RpdmVseSBzdHJlYW1pbmcgaW4gZnJvbSB0aGUgQVBJLCByZWNlaXZpbmcgY2h1bmtzIG9mIGRhdGEuXG4gICAqIC0gYHJlYWR5YDogVGhlIGZ1bGwgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIHByb2Nlc3NlZDsgYSBuZXcgdXNlciBtZXNzYWdlIGNhbiBiZSBzdWJtaXR0ZWQuXG4gICAqIC0gYGVycm9yYDogQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBBUEkgcmVxdWVzdCwgcHJldmVudGluZyBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnN0YXR1cztcbiAgfVxuICBzZXRTdGF0dXMoe1xuICAgIHN0YXR1cyxcbiAgICBlcnJvclxuICB9KSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0ZS5lcnJvciA9IGVycm9yO1xuICB9XG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgfVxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubWVzc2FnZXM7XG4gIH1cbiAgZ2V0IGxhc3RNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1lc3NhZ2VzW3RoaXMuc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc2V0IG1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICB9XG4gIGFzeW5jIG1ha2VSZXF1ZXN0KHtcbiAgICB0cmlnZ2VyLFxuICAgIG1ldGFkYXRhLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBtZXNzYWdlSWRcbiAgfSkge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLCBlcnJvcjogdm9pZCAwIH0pO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gdGhpcy5sYXN0TWVzc2FnZTtcbiAgICBsZXQgaXNBYm9ydCA9IGZhbHNlO1xuICAgIGxldCBpc0Rpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvciA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY3RpdmVSZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgICAgICAgICBsYXN0TWVzc2FnZTogdGhpcy5zdGF0ZS5zbmFwc2hvdChsYXN0TWVzc2FnZSksXG4gICAgICAgICAgbWVzc2FnZUlkOiB0aGlzLmdlbmVyYXRlSWQoKVxuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gYWN0aXZlUmVzcG9uc2U7XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgaWYgKHRyaWdnZXIgPT09IFwicmVzdW1lLXN0cmVhbVwiKSB7XG4gICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlY29ubmVjdFRvU3RyZWFtKHtcbiAgICAgICAgICBjaGF0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVjb25uZWN0ID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSByZWNvbm5lY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kTWVzc2FnZXMoe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyxcbiAgICAgICAgICBhYm9ydFNpZ25hbDogYWN0aXZlUmVzcG9uc2UuYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gKGpvYikgPT4gKFxuICAgICAgICAvLyBzZXJpYWxpemUgdGhlIGpvYiBleGVjdXRpb24gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICB0aGlzLmpvYkV4ZWN1dG9yLnJ1bihcbiAgICAgICAgICAoKSA9PiBqb2Ioe1xuICAgICAgICAgICAgc3RhdGU6IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLFxuICAgICAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN0cmVhbWluZ1wiIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGFzdE1lc3NhZ2UgPSBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLmlkID09PSAoKF9hMTggPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCk7XG4gICAgICAgICAgICAgIGlmIChyZXBsYWNlTGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wdXNoTWVzc2FnZShhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgb25Ub29sQ2FsbDogdGhpcy5vblRvb2xDYWxsLFxuICAgICAgICAgIG9uRGF0YTogdGhpcy5vbkRhdGEsXG4gICAgICAgICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hOiB0aGlzLm1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICAgICAgICBkYXRhUGFydFNjaGVtYXM6IHRoaXMuZGF0YVBhcnRTY2hlbWFzLFxuICAgICAgICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzQWJvcnQgfHwgZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZldGNoXCIpIHx8IGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJuZXR3b3JrXCIpKSkge1xuICAgICAgICBpc0Rpc2Nvbm5lY3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcImVycm9yXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIChfYiA9IHRoaXMub25GaW5pc2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICBtZXNzYWdlOiB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMsXG4gICAgICAgICAgaXNBYm9ydCxcbiAgICAgICAgICBpc0Rpc2Nvbm5lY3QsXG4gICAgICAgICAgaXNFcnJvcixcbiAgICAgICAgICBmaW5pc2hSZWFzb246IChfYTE3ID0gdGhpcy5hY3RpdmVSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuc3RhdGUuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICgoKF9jID0gdGhpcy5zZW5kQXV0b21hdGljYWxseVdoZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIHsgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMgfSkpICYmICFpc0Vycm9yKSB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IChfZCA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3VpL2RpcmVjdC1jaGF0LXRyYW5zcG9ydC50c1xudmFyIERpcmVjdENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhZ2VudCxcbiAgICBvcHRpb25zLFxuICAgIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnNcbiAgfSkge1xuICAgIHRoaXMuYWdlbnQgPSBhZ2VudDtcbiAgICB0aGlzLmFnZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy51aU1lc3NhZ2VTdHJlYW1PcHRpb25zID0gdWlNZXNzYWdlU3RyZWFtT3B0aW9ucztcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIG1lc3NhZ2VzLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRNZXNzYWdlcyA9IGF3YWl0IHZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHRvb2xzOiB0aGlzLmFnZW50LnRvb2xzXG4gICAgfSk7XG4gICAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb01vZGVsTWVzc2FnZXModmFsaWRhdGVkTWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzOiB0aGlzLmFnZW50LnRvb2xzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZ2VudC5zdHJlYW0oe1xuICAgICAgcHJvbXB0OiBtb2RlbE1lc3NhZ2VzLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAuLi50aGlzLmFnZW50T3B0aW9ucyAhPT0gdm9pZCAwID8geyBvcHRpb25zOiB0aGlzLmFnZW50T3B0aW9ucyB9IDoge31cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnRvVUlNZXNzYWdlU3RyZWFtKHRoaXMudWlNZXNzYWdlU3RyZWFtT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIERpcmVjdCB0cmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCByZWNvbm5lY3Rpb24gc2luY2UgdGhlcmUgaXMgbm9cbiAgICogcGVyc2lzdGVudCBzZXJ2ZXItc2lkZSBzdHJlYW0gdG8gcmVjb25uZWN0IHRvLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbHdheXMgcmV0dXJucyBgbnVsbGBcbiAgICovXG4gIGFzeW5jIHJlY29ubmVjdFRvU3RyZWFtKF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9sYXN0LWFzc2lzdGFudC1tZXNzYWdlLWlzLWNvbXBsZXRlLXdpdGgtYXBwcm92YWwtcmVzcG9uc2VzLnRzXG5mdW5jdGlvbiBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoQXBwcm92YWxSZXNwb25zZXMoe1xuICBtZXNzYWdlc1xufSkge1xuICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICghbWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RTdGVwU3RhcnRJbmRleCA9IG1lc3NhZ2UucGFydHMucmVkdWNlKChsYXN0SW5kZXgsIHBhcnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIgPyBpbmRleCA6IGxhc3RJbmRleDtcbiAgfSwgLTEpO1xuICBjb25zdCBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UucGFydHMuc2xpY2UobGFzdFN0ZXBTdGFydEluZGV4ICsgMSkuZmlsdGVyKGlzVG9vbFVJUGFydCkuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKTtcbiAgcmV0dXJuIChcbiAgICAvLyBoYXMgYXQgbGVhc3Qgb25lIHRvb2wgYXBwcm92YWwgcmVzcG9uc2VcbiAgICBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5maWx0ZXIoKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLmxlbmd0aCA+IDAgJiYgLy8gYWxsIHRvb2wgYXBwcm92YWxzIG11c3QgaGF2ZSBhIHJlc3BvbnNlXG4gICAgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoXG4gICAgICAocGFydCkgPT4gcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiB8fCBwYXJ0LnN0YXRlID09PSBcImFwcHJvdmFsLXJlc3BvbmRlZFwiXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvdWkvbGFzdC1hc3Npc3RhbnQtbWVzc2FnZS1pcy1jb21wbGV0ZS13aXRoLXRvb2wtY2FsbHMudHNcbmZ1bmN0aW9uIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhUb29sQ2FsbHMoe1xuICBtZXNzYWdlc1xufSkge1xuICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICghbWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RTdGVwU3RhcnRJbmRleCA9IG1lc3NhZ2UucGFydHMucmVkdWNlKChsYXN0SW5kZXgsIHBhcnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIgPyBpbmRleCA6IGxhc3RJbmRleDtcbiAgfSwgLTEpO1xuICBjb25zdCBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UucGFydHMuc2xpY2UobGFzdFN0ZXBTdGFydEluZGV4ICsgMSkuZmlsdGVyKGlzVG9vbFVJUGFydCkuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoXG4gICAgKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiIHx8IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCJcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RyYW5zZm9ybS10ZXh0LXRvLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0LXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCBpZDogXCJ0ZXh0LTFcIiwgZGVsdGE6IHBhcnQgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImZpbmlzaC1zdGVwXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoXCIgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RleHQtc3RyZWFtLWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBBSVNES0Vycm9yMTggYXMgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBBYnN0cmFjdENoYXQsXG4gIERlZmF1bHRDaGF0VHJhbnNwb3J0LFxuICBEaXJlY3RDaGF0VHJhbnNwb3J0LFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBUb29sTG9vcEFnZW50IGFzIEV4cGVyaW1lbnRhbF9BZ2VudCxcbiAgSHR0cENoYXRUcmFuc3BvcnQsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkU3RyZWFtUGFydEVycm9yLFxuICBJbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3IsXG4gIEludmFsaWRUb29sSW5wdXRFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSxcbiAgTG9hZEFQSUtleUVycm9yLFxuICBMb2FkU2V0dGluZ0Vycm9yLFxuICBNZXNzYWdlQ29udmVyc2lvbkVycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9JbWFnZUdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dEdlbmVyYXRlZEVycm9yLFxuICBOb1NwZWVjaEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIG91dHB1dF9leHBvcnRzIGFzIE91dHB1dCxcbiAgUmV0cnlFcnJvcixcbiAgU2VyaWFsSm9iRXhlY3V0b3IsXG4gIFRleHRTdHJlYW1DaGF0VHJhbnNwb3J0LFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvcixcbiAgVG9vbENhbGxSZXBhaXJFcnJvcixcbiAgVG9vbExvb3BBZ2VudCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVUlNZXNzYWdlU3RyZWFtRXJyb3IsXG4gIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yLFxuICBhZGRUb29sSW5wdXRFeGFtcGxlc01pZGRsZXdhcmUsXG4gIGFzU2NoZW1hNSBhcyBhc1NjaGVtYSxcbiAgYXNzaXN0YW50TW9kZWxNZXNzYWdlU2NoZW1hLFxuICBjYWxsQ29tcGxldGlvbkFwaSxcbiAgY29uc3VtZVN0cmVhbSxcbiAgY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyxcbiAgY29udmVydFRvTW9kZWxNZXNzYWdlcyxcbiAgY29zaW5lU2ltaWxhcml0eSxcbiAgY3JlYXRlQWdlbnRVSVN0cmVhbSxcbiAgY3JlYXRlQWdlbnRVSVN0cmVhbVJlc3BvbnNlLFxuICBjcmVhdGVHYXRld2F5LFxuICBjcmVhdGVJZEdlbmVyYXRvcjUgYXMgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSxcbiAgY3JlYXRlVUlNZXNzYWdlU3RyZWFtLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRFbWJlZGRpbmdTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGR5bmFtaWNUb29sLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVJbWFnZSxcbiAgZ2VuZXJhdGVTcGVlY2ggYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlU3BlZWNoLFxuICB0cmFuc2NyaWJlIGFzIGV4cGVyaW1lbnRhbF90cmFuc2NyaWJlLFxuICBleHRyYWN0SnNvbk1pZGRsZXdhcmUsXG4gIGV4dHJhY3RSZWFzb25pbmdNaWRkbGV3YXJlLFxuICBnYXRld2F5MiBhcyBnYXRld2F5LFxuICBnZW5lcmF0ZUlkLFxuICBnZW5lcmF0ZUltYWdlLFxuICBnZW5lcmF0ZU9iamVjdCxcbiAgZ2VuZXJhdGVUZXh0LFxuICBnZXRTdGF0aWNUb29sTmFtZSxcbiAgZ2V0VGV4dEZyb21EYXRhVXJsLFxuICBnZXRUb29sTmFtZSxcbiAgZ2V0VG9vbE9yRHluYW1pY1Rvb2xOYW1lLFxuICBoYXNUb29sQ2FsbCxcbiAgaXNEYXRhVUlQYXJ0LFxuICBpc0RlZXBFcXVhbERhdGEsXG4gIGlzRmlsZVVJUGFydCxcbiAgaXNSZWFzb25pbmdVSVBhcnQsXG4gIGlzU3RhdGljVG9vbFVJUGFydCxcbiAgaXNUZXh0VUlQYXJ0LFxuICBpc1Rvb2xPckR5bmFtaWNUb29sVUlQYXJ0LFxuICBpc1Rvb2xVSVBhcnQsXG4gIGpzb25TY2hlbWEsXG4gIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhBcHByb3ZhbFJlc3BvbnNlcyxcbiAgbGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aFRvb2xDYWxscyxcbiAgbW9kZWxNZXNzYWdlU2NoZW1hLFxuICBwYXJzZUpzb25FdmVudFN0cmVhbTMgYXMgcGFyc2VKc29uRXZlbnRTdHJlYW0sXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHBpcGVBZ2VudFVJU3RyZWFtVG9SZXNwb25zZSxcbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlLFxuICBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSxcbiAgcHJ1bmVNZXNzYWdlcyxcbiAgcmVhZFVJTWVzc2FnZVN0cmVhbSxcbiAgcmVyYW5rLFxuICBzYWZlVmFsaWRhdGVVSU1lc3NhZ2VzLFxuICBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtLFxuICBzaW11bGF0ZVN0cmVhbWluZ01pZGRsZXdhcmUsXG4gIHNtb290aFN0cmVhbSxcbiAgc3RlcENvdW50SXMsXG4gIHN0cmVhbU9iamVjdCxcbiAgc3RyZWFtVGV4dCxcbiAgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB0b29sLFxuICB0b29sTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB1aU1lc3NhZ2VDaHVua1NjaGVtYSxcbiAgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdmFsaWRhdGVVSU1lc3NhZ2VzLFxuICB3cmFwRW1iZWRkaW5nTW9kZWwsXG4gIHdyYXBJbWFnZU1vZGVsLFxuICB3cmFwTGFuZ3VhZ2VNb2RlbCxcbiAgd3JhcFByb3ZpZGVyLFxuICB6b2RTY2hlbWEzIGFzIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUxNyIsImdldCIsImVudW1lcmFibGUiLCJjcmVhdGVHYXRld2F5IiwiZ2F0ZXdheSIsImdhdGV3YXkyIiwiYXNTY2hlbWEiLCJhc1NjaGVtYTUiLCJjcmVhdGVJZEdlbmVyYXRvciIsImNyZWF0ZUlkR2VuZXJhdG9yNSIsImR5bmFtaWNUb29sIiwiZ2VuZXJhdGVJZCIsImpzb25TY2hlbWEiLCJwYXJzZUpzb25FdmVudFN0cmVhbSIsInBhcnNlSnNvbkV2ZW50U3RyZWFtMyIsInRvb2wiLCJ6b2RTY2hlbWEiLCJ6b2RTY2hlbWEzIiwiZ2V0RXJyb3JNZXNzYWdlIiwiZ2V0RXJyb3JNZXNzYWdlNSIsIndpdGhVc2VyQWdlbnRTdWZmaXgiLCJ3aXRoVXNlckFnZW50U3VmZml4MiIsIkFJU0RLRXJyb3IiLCJBSVNES0Vycm9yMTgiLCJBUElDYWxsRXJyb3IiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiSW52YWxpZFByb21wdEVycm9yIiwiSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yIiwiSlNPTlBhcnNlRXJyb3IiLCJMb2FkQVBJS2V5RXJyb3IiLCJMb2FkU2V0dGluZ0Vycm9yIiwiTm9Db250ZW50R2VuZXJhdGVkRXJyb3IiLCJOb1N1Y2hNb2RlbEVycm9yIiwiVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciIsIm5hbWUiLCJtYXJrZXIiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJfYSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiY29uc3RydWN0b3IiLCJwYXJhbWV0ZXIiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJBSVNES0Vycm9yMiIsIm5hbWUyIiwibWFya2VyMiIsInN5bWJvbDIiLCJfYTIiLCJJbnZhbGlkU3RyZWFtUGFydEVycm9yIiwiY2h1bmsiLCJBSVNES0Vycm9yMyIsIm5hbWUzIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJJbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3IiLCJhcHByb3ZhbElkIiwiQUlTREtFcnJvcjQiLCJuYW1lNCIsIm1hcmtlcjQiLCJzeW1ib2w0IiwiX2E0IiwiSW52YWxpZFRvb2xJbnB1dEVycm9yIiwidG9vbElucHV0IiwidG9vbE5hbWUiLCJjYXVzZSIsIkFJU0RLRXJyb3I1IiwibmFtZTUiLCJtYXJrZXI1Iiwic3ltYm9sNSIsIl9hNSIsIlRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yIiwidG9vbENhbGxJZCIsIkFJU0RLRXJyb3I2IiwibmFtZTYiLCJtYXJrZXI2Iiwic3ltYm9sNiIsIl9hNiIsIk5vSW1hZ2VHZW5lcmF0ZWRFcnJvciIsInJlc3BvbnNlcyIsIkFJU0RLRXJyb3I3IiwibmFtZTciLCJtYXJrZXI3Iiwic3ltYm9sNyIsIl9hNyIsIk5vT2JqZWN0R2VuZXJhdGVkRXJyb3IiLCJ0ZXh0IiwidGV4dDIiLCJyZXNwb25zZSIsInVzYWdlIiwiZmluaXNoUmVhc29uIiwiQUlTREtFcnJvcjgiLCJuYW1lOCIsIm1hcmtlcjgiLCJzeW1ib2w4IiwiX2E4IiwiTm9PdXRwdXRHZW5lcmF0ZWRFcnJvciIsIkFJU0RLRXJyb3I5IiwiTm9TcGVlY2hHZW5lcmF0ZWRFcnJvciIsIm9wdGlvbnMiLCJBSVNES0Vycm9yMTAiLCJuYW1lOSIsIm1hcmtlcjkiLCJzeW1ib2w5IiwiX2E5IiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJqb2luIiwiQUlTREtFcnJvcjExIiwiZ2V0RXJyb3JNZXNzYWdlMiIsIm5hbWUxMCIsIm1hcmtlcjEwIiwic3ltYm9sMTAiLCJfYTEwIiwiVG9vbENhbGxSZXBhaXJFcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJBSVNES0Vycm9yMTIiLCJVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yIiwidmVyc2lvbiIsInByb3ZpZGVyIiwibW9kZWxJZCIsIkFJU0RLRXJyb3IxMyIsIm5hbWUxMSIsIm1hcmtlcjExIiwic3ltYm9sMTEiLCJfYTExIiwiVUlNZXNzYWdlU3RyZWFtRXJyb3IiLCJjaHVua1R5cGUiLCJjaHVua0lkIiwiQUlTREtFcnJvcjE0IiwibmFtZTEyIiwibWFya2VyMTIiLCJzeW1ib2wxMiIsIl9hMTIiLCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsImNvbnRlbnQiLCJBSVNES0Vycm9yMTUiLCJuYW1lMTMiLCJtYXJrZXIxMyIsInN5bWJvbDEzIiwiX2ExMyIsIkludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwicm9sZSIsIkFJU0RLRXJyb3IxNiIsIm5hbWUxNCIsIm1hcmtlcjE0Iiwic3ltYm9sMTQiLCJfYTE0IiwiTWVzc2FnZUNvbnZlcnNpb25FcnJvciIsIm9yaWdpbmFsTWVzc2FnZSIsIkRvd25sb2FkRXJyb3IiLCJBSVNES0Vycm9yMTciLCJuYW1lMTUiLCJtYXJrZXIxNSIsInN5bWJvbDE1IiwiX2ExNSIsIlJldHJ5RXJyb3IiLCJyZWFzb24iLCJlcnJvcnMiLCJsYXN0RXJyb3IiLCJsZW5ndGgiLCJmb3JtYXRXYXJuaW5nIiwid2FybmluZyIsIm1vZGVsIiwicHJlZml4IiwidHlwZSIsImZlYXR1cmUiLCJkZXRhaWxzIiwiSlNPTiIsInN0cmluZ2lmeSIsIkZJUlNUX1dBUk5JTkdfSU5GT19NRVNTQUdFIiwiaGFzTG9nZ2VkQmVmb3JlIiwibG9nV2FybmluZ3MiLCJ3YXJuaW5ncyIsImxvZ2dlciIsImdsb2JhbFRoaXMiLCJBSV9TREtfTE9HX1dBUk5JTkdTIiwiY29uc29sZSIsImluZm8iLCJ3YXJuIiwibG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyIsImFzRW1iZWRkaW5nTW9kZWxWMyIsInNwZWNpZmljYXRpb25WZXJzaW9uIiwiUHJveHkiLCJwcm9wIiwiYXNJbWFnZU1vZGVsVjMiLCJhc0xhbmd1YWdlTW9kZWxWMyIsImFyZ3MiLCJyZXN1bHQiLCJkb0dlbmVyYXRlIiwiY29udmVydFYyRmluaXNoUmVhc29uVG9WMyIsImNvbnZlcnRWMlVzYWdlVG9WMyIsImRvU3RyZWFtIiwic3RyZWFtIiwiY29udmVydFYyU3RyZWFtVG9WMyIsInBpcGVUaHJvdWdoIiwiVHJhbnNmb3JtU3RyZWFtIiwidHJhbnNmb3JtIiwiY29udHJvbGxlciIsImVucXVldWUiLCJ1bmlmaWVkIiwicmF3IiwiaW5wdXRUb2tlbnMiLCJ0b3RhbCIsIm5vQ2FjaGUiLCJjYWNoZVJlYWQiLCJjYWNoZWRJbnB1dFRva2VucyIsImNhY2hlV3JpdGUiLCJvdXRwdXRUb2tlbnMiLCJyZWFzb25pbmciLCJyZWFzb25pbmdUb2tlbnMiLCJhc1NwZWVjaE1vZGVsVjMiLCJhc1RyYW5zY3JpcHRpb25Nb2RlbFYzIiwicmVzb2x2ZUxhbmd1YWdlTW9kZWwiLCJ1bnN1cHBvcnRlZE1vZGVsIiwiZ2V0R2xvYmFsUHJvdmlkZXIiLCJsYW5ndWFnZU1vZGVsIiwicmVzb2x2ZUVtYmVkZGluZ01vZGVsIiwiZW1iZWRkaW5nTW9kZWwiLCJyZXNvbHZlVHJhbnNjcmlwdGlvbk1vZGVsIiwiX2ExNyIsIl9iIiwidHJhbnNjcmlwdGlvbk1vZGVsIiwiY2FsbCIsInJlc29sdmVTcGVlY2hNb2RlbCIsInNwZWVjaE1vZGVsIiwicmVzb2x2ZUltYWdlTW9kZWwiLCJpbWFnZU1vZGVsIiwiQUlfU0RLX0RFRkFVTFRfUFJPVklERVIiLCJnZXRUb3RhbFRpbWVvdXRNcyIsInRpbWVvdXQiLCJ0b3RhbE1zIiwiZ2V0U3RlcFRpbWVvdXRNcyIsInN0ZXBNcyIsImdldENodW5rVGltZW91dE1zIiwiY2h1bmtNcyIsImlzVXJsU3VwcG9ydGVkIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImltYWdlTWVkaWFUeXBlU2lnbmF0dXJlcyIsIm1lZGlhVHlwZSIsImJ5dGVzUHJlZml4IiwiYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzIiwic3RyaXBJRDMiLCJkYXRhIiwiYnl0ZXMiLCJpZDNTaXplIiwic2xpY2UiLCJzdHJpcElEM1RhZ3NJZlByZXNlbnQiLCJoYXNJZDMiLCJzdGFydHNXaXRoIiwiZGV0ZWN0TWVkaWFUeXBlIiwic2lnbmF0dXJlcyIsInByb2Nlc3NlZERhdGEiLCJzdWJzdHJpbmciLCJNYXRoIiwibWluIiwic2lnbmF0dXJlIiwiZXZlcnkiLCJieXRlIiwiaW5kZXgiLCJEb3dubG9hZEVycm9yMiIsImdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCIsIlZFUlNJT04iLCJkb3dubG9hZCIsInVybCIsInVybFRleHQiLCJ0b1N0cmluZyIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJjcmVhdGVEZWZhdWx0RG93bmxvYWRGdW5jdGlvbiIsImRvd25sb2FkMiIsInJlcXVlc3RlZERvd25sb2FkcyIsIlByb21pc2UiLCJtYXAiLCJyZXF1ZXN0ZWREb3dubG9hZCIsImlzVXJsU3VwcG9ydGVkQnlNb2RlbCIsIkFJU0RLRXJyb3IxOSIsImNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyIiwiY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCIsInoiLCJzcGxpdERhdGFVcmwiLCJkYXRhVXJsIiwiaGVhZGVyIiwiYmFzZTY0Q29udGVudCIsInNwbGl0IiwiZGF0YUNvbnRlbnRTY2hlbWEiLCJ1bmlvbiIsInN0cmluZyIsImluc3RhbmNlb2YiLCJBcnJheUJ1ZmZlciIsImN1c3RvbSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYzRGF0YUNvbnRlbnQiLCJVUkwiLCJwcm90b2NvbCIsImRhdGFVcmxNZWRpYVR5cGUiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyIsImNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSIsImFzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0Iiwic3VwcG9ydGVkVXJscyIsImRvd25sb2FkZWRBc3NldHMiLCJkb3dubG9hZEFzc2V0cyIsIm1lc3NhZ2VzIiwic3lzdGVtIiwicHJvdmlkZXJPcHRpb25zIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UiLCJjb21iaW5lZE1lc3NhZ2VzIiwicHVzaCIsImxhc3RDb21iaW5lZE1lc3NhZ2UiLCJhdCIsInBhcnQiLCJjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQiLCJmaWx0ZXIiLCJmaWxlbmFtZSIsImlucHV0IiwicHJvdmlkZXJFeGVjdXRlZCIsIm91dHB1dCIsIm1hcFRvb2xSZXN1bHRPdXRwdXQiLCJhcHByb3ZlZCIsIl9leGhhdXN0aXZlQ2hlY2siLCJwbGFubmVkRG93bmxvYWRzIiwiZmxhdCIsImltYWdlIiwiaWdub3JlZCIsImRvd25sb2FkZWRGaWxlcyIsImZyb21FbnRyaWVzIiwiZmlsZSIsIm9yaWdpbmFsRGF0YSIsIkVycm9yIiwiY29udmVydGVkRGF0YSIsImNvbnZlcnRlZE1lZGlhVHlwZSIsImRvd25sb2FkZWRGaWxlIiwiaXRlbSIsImdldEVycm9yTWVzc2FnZTMiLCJjcmVhdGVUb29sTW9kZWxPdXRwdXQiLCJ0b29sMiIsImVycm9yTW9kZSIsInRvSlNPTlZhbHVlIiwidG9Nb2RlbE91dHB1dCIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhPdXRwdXRUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJ0b3BLIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInNlZWQiLCJzdG9wU2VxdWVuY2VzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNOb25FbXB0eU9iamVjdCIsIm9iamVjdDIiLCJrZXlzIiwicHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSIsInRvb2xzIiwidG9vbENob2ljZSIsImFjdGl2ZVRvb2xzIiwiZmlsdGVyZWRUb29scyIsImVudHJpZXMiLCJpbmNsdWRlcyIsImxhbmd1YWdlTW9kZWxUb29scyIsInRvb2xUeXBlIiwiZGVzY3JpcHRpb24iLCJpbnB1dFNjaGVtYSIsImlucHV0RXhhbXBsZXMiLCJzdHJpY3QiLCJpZCIsImV4aGF1c3RpdmVDaGVjayIsIkludmFsaWRQcm9tcHRFcnJvcjIiLCJzYWZlVmFsaWRhdGVUeXBlcyIsIno2IiwiejUiLCJ6MyIsInoyIiwianNvblZhbHVlU2NoZW1hIiwibGF6eSIsIm51bGwiLCJudW1iZXIiLCJib29sZWFuIiwicmVjb3JkIiwib3B0aW9uYWwiLCJhcnJheSIsInByb3ZpZGVyTWV0YWRhdGFTY2hlbWEiLCJ6NCIsInRleHRQYXJ0U2NoZW1hIiwib2JqZWN0IiwibGl0ZXJhbCIsImltYWdlUGFydFNjaGVtYSIsImZpbGVQYXJ0U2NoZW1hIiwicmVhc29uaW5nUGFydFNjaGVtYSIsInRvb2xDYWxsUGFydFNjaGVtYSIsInVua25vd24iLCJvdXRwdXRTY2hlbWEiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJmaWxlSWQiLCJ0b29sUmVzdWx0UGFydFNjaGVtYSIsInRvb2xBcHByb3ZhbFJlcXVlc3RTY2hlbWEiLCJ0b29sQXBwcm92YWxSZXNwb25zZVNjaGVtYSIsInN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSIsInVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEiLCJhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEiLCJ0b29sTW9kZWxNZXNzYWdlU2NoZW1hIiwibW9kZWxNZXNzYWdlU2NoZW1hIiwic3RhbmRhcmRpemVQcm9tcHQiLCJ2YWxpZGF0aW9uUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsIkdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yIiwiQUlTREtFcnJvcjIwIiwid3JhcEdhdGV3YXlFcnJvciIsImlzUHJvZHVjdGlvbkVudiIsInByb2Nlc3MiLCJtb3JlSW5mb1VSTCIsImFzc2lnbiIsImFzc2VtYmxlT3BlcmF0aW9uTmFtZSIsIm9wZXJhdGlvbklkIiwidGVsZW1ldHJ5IiwiZnVuY3Rpb25JZCIsImdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwic2V0dGluZ3MiLCJyZWR1Y2UiLCJhdHRyaWJ1dGVzIiwia2V5IiwidG90YWxUaW1lb3V0TXMiLCJtZXRhZGF0YSIsInRyYWNlIiwibm9vcFRyYWNlciIsInN0YXJ0U3BhbiIsIm5vb3BTcGFuIiwic3RhcnRBY3RpdmVTcGFuIiwiYXJnMSIsImFyZzIiLCJhcmczIiwic3BhbkNvbnRleHQiLCJub29wU3BhbkNvbnRleHQiLCJzZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwiYWRkRXZlbnQiLCJhZGRMaW5rIiwiYWRkTGlua3MiLCJzZXRTdGF0dXMiLCJ1cGRhdGVOYW1lIiwiZW5kIiwiaXNSZWNvcmRpbmciLCJyZWNvcmRFeGNlcHRpb24iLCJ0cmFjZUlkIiwic3BhbklkIiwidHJhY2VGbGFncyIsImdldFRyYWNlciIsImlzRW5hYmxlZCIsInRyYWNlciIsIlNwYW5TdGF0dXNDb2RlIiwiY29udGV4dCIsInJlY29yZFNwYW4iLCJmbiIsImVuZFdoZW5Eb25lIiwic3BhbiIsImN0eCIsImFjdGl2ZSIsIndpdGgiLCJyZWNvcmRFcnJvck9uU3BhbiIsInN0YWNrIiwiY29kZSIsIkVSUk9SIiwic2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyIsInJlc3VsdEF0dHJpYnV0ZXMiLCJyZWNvcmRJbnB1dHMiLCJyZWNvcmRPdXRwdXRzIiwic3RyaW5naWZ5Rm9yVGVsZW1ldHJ5IiwiYXNMYW5ndWFnZU1vZGVsVXNhZ2UiLCJpbnB1dFRva2VuRGV0YWlscyIsIm5vQ2FjaGVUb2tlbnMiLCJjYWNoZVJlYWRUb2tlbnMiLCJjYWNoZVdyaXRlVG9rZW5zIiwib3V0cHV0VG9rZW5EZXRhaWxzIiwidGV4dFRva2VucyIsInRvdGFsVG9rZW5zIiwiYWRkVG9rZW5Db3VudHMiLCJjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlIiwiYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlIiwidXNhZ2UxIiwidXNhZ2UyIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2kiLCJfaiIsInRva2VuQ291bnQxIiwidG9rZW5Db3VudDIiLCJhZGRJbWFnZU1vZGVsVXNhZ2UiLCJtZXJnZU9iamVjdHMiLCJiYXNlIiwib3ZlcnJpZGVzIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJvdmVycmlkZXNWYWx1ZSIsImJhc2VWYWx1ZSIsImlzU291cmNlT2JqZWN0IiwiRGF0ZSIsIlJlZ0V4cCIsImlzVGFyZ2V0T2JqZWN0IiwiQVBJQ2FsbEVycm9yMiIsImRlbGF5IiwiZ2V0RXJyb3JNZXNzYWdlNCIsImlzQWJvcnRFcnJvciIsImdldFJldHJ5RGVsYXlJbk1zIiwiZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXkiLCJyZXNwb25zZUhlYWRlcnMiLCJtcyIsInJldHJ5QWZ0ZXJNcyIsInRpbWVvdXRNcyIsInBhcnNlRmxvYXQiLCJpc05hTiIsInJldHJ5QWZ0ZXIiLCJ0aW1lb3V0U2Vjb25kcyIsInBhcnNlIiwibm93IiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlJbk1zIiwiYmFja29mZkZhY3RvciIsImFib3J0U2lnbmFsIiwiZiIsIl9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJkZWxheUluTXMiLCJlcnJvck1lc3NhZ2UiLCJuZXdFcnJvcnMiLCJ0cnlOdW1iZXIiLCJpc1JldHJ5YWJsZSIsInByZXBhcmVSZXRyaWVzIiwibWF4UmV0cmllc1Jlc3VsdCIsInJldHJ5IiwiY29sbGVjdFRvb2xBcHByb3ZhbHMiLCJsYXN0TWVzc2FnZSIsImFwcHJvdmVkVG9vbEFwcHJvdmFscyIsImRlbmllZFRvb2xBcHByb3ZhbHMiLCJ0b29sQ2FsbHNCeVRvb2xDYWxsSWQiLCJ0b29sQXBwcm92YWxSZXF1ZXN0c0J5QXBwcm92YWxJZCIsInRvb2xSZXN1bHRzIiwiYXBwcm92YWxSZXNwb25zZXMiLCJhcHByb3ZhbFJlc3BvbnNlIiwiYXBwcm92YWxSZXF1ZXN0IiwidG9vbENhbGwiLCJhcHByb3ZhbCIsImV4ZWN1dGVUb29sIiwiZXhlY3V0ZVRvb2xDYWxsIiwiZXhwZXJpbWVudGFsX2NvbnRleHQiLCJvblByZWxpbWluYXJ5VG9vbFJlc3VsdCIsImV4ZWN1dGUiLCJiaW5kIiwicHJlbGltaW5hcnkiLCJkeW5hbWljIiwicHJvdmlkZXJNZXRhZGF0YSIsImV4dHJhY3RUZXh0Q29udGVudCIsInBhcnRzIiwiY29udGVudDIiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MyIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyIiwiRGVmYXVsdEdlbmVyYXRlZEZpbGUiLCJpc1VpbnQ4QXJyYXkiLCJiYXNlNjREYXRhIiwidWludDhBcnJheURhdGEiLCJiYXNlNjQiLCJ1aW50OEFycmF5IiwiRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSIsImlzQXBwcm92YWxOZWVkZWQiLCJuZWVkc0FwcHJvdmFsIiwib3V0cHV0X2V4cG9ydHMiLCJjaG9pY2UiLCJqc29uIiwiVHlwZVZhbGlkYXRpb25FcnJvcjIiLCJhc1NjaGVtYTIiLCJyZXNvbHZlIiwic2FmZVBhcnNlSlNPTiIsInNhZmVQYXJzZUpTT04yIiwic2FmZVZhbGlkYXRlVHlwZXMyIiwiZml4SnNvbiIsImxhc3RWYWxpZEluZGV4IiwibGl0ZXJhbFN0YXJ0IiwicHJvY2Vzc1ZhbHVlU3RhcnQiLCJjaGFyIiwiaSIsInN3YXBTdGF0ZSIsInBvcCIsInByb2Nlc3NBZnRlck9iamVjdFZhbHVlIiwicHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZSIsImN1cnJlbnRTdGF0ZSIsInBhcnRpYWxMaXRlcmFsIiwic3RhdGUiLCJwYXJzZVBhcnRpYWxKc29uIiwianNvblRleHQiLCJyZXNwb25zZUZvcm1hdCIsInBhcnNlQ29tcGxldGVPdXRwdXQiLCJwYXJzZVBhcnRpYWxPdXRwdXQiLCJwYXJ0aWFsIiwiY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSIsInRoZW4iLCJqc29uU2NoZW1hMiIsImNvbnRleHQyIiwicGFyc2VSZXN1bHQiLCJlbGVtZW50IiwiaW5wdXRFbGVtZW50U2NoZW1hIiwiZWxlbWVudFNjaGVtYSIsIiRzY2hlbWEiLCJpdGVtU2NoZW1hIiwicHJvcGVydGllcyIsImVsZW1lbnRzIiwiaXRlbXMiLCJyZXF1aXJlZCIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwib3V0ZXJWYWx1ZSIsInJhd0VsZW1lbnRzIiwicGFyc2VkRWxlbWVudHMiLCJyYXdFbGVtZW50IiwicHVibGlzaGVkRWxlbWVudHMiLCJwYXJ0aWFsT3V0cHV0IiwiY2hvaWNlT3B0aW9ucyIsImVudW0iLCJwb3RlbnRpYWxNYXRjaGVzIiwiY2hvaWNlT3B0aW9uIiwiYXNTY2hlbWEzIiwic2FmZVBhcnNlSlNPTjMiLCJzYWZlVmFsaWRhdGVUeXBlczMiLCJwYXJzZVRvb2xDYWxsIiwicmVwYWlyVG9vbENhbGwiLCJwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwiLCJkb1BhcnNlVG9vbENhbGwiLCJyZXBhaXJlZFRvb2xDYWxsIiwicmVwYWlyRXJyb3IiLCJwYXJzZWRJbnB1dCIsImludmFsaWQiLCJ0aXRsZSIsInRyaW0iLCJEZWZhdWx0U3RlcFJlc3VsdCIsInJhd0ZpbmlzaFJlYXNvbiIsInJlcXVlc3QiLCJyZWFzb25pbmdUZXh0IiwiZmlsZXMiLCJzb3VyY2VzIiwidG9vbENhbGxzIiwic3RhdGljVG9vbENhbGxzIiwiZHluYW1pY1Rvb2xDYWxscyIsInN0YXRpY1Rvb2xSZXN1bHRzIiwidG9vbFJlc3VsdCIsImR5bmFtaWNUb29sUmVzdWx0cyIsInN0ZXBDb3VudElzIiwic3RlcENvdW50Iiwic3RlcHMiLCJoYXNUb29sQ2FsbCIsInNvbWUiLCJpc1N0b3BDb25kaXRpb25NZXQiLCJzdG9wQ29uZGl0aW9ucyIsImNvbmRpdGlvbiIsInRvUmVzcG9uc2VNZXNzYWdlcyIsImlucHV0Q29udGVudCIsInJlc3BvbnNlTWVzc2FnZXMiLCJ0b29sUmVzdWx0Q29udGVudCIsIm1lcmdlQWJvcnRTaWduYWxzIiwic2lnbmFscyIsInZhbGlkU2lnbmFscyIsInNpZ25hbCIsIkFib3J0Q29udHJvbGxlciIsImFib3J0ZWQiLCJhYm9ydCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwib3JpZ2luYWxHZW5lcmF0ZUlkIiwic2l6ZSIsImdlbmVyYXRlVGV4dCIsIm1vZGVsQXJnIiwibWF4UmV0cmllc0FyZyIsInN0b3BXaGVuIiwiZXhwZXJpbWVudGFsX291dHB1dCIsImV4cGVyaW1lbnRhbF90ZWxlbWV0cnkiLCJleHBlcmltZW50YWxfYWN0aXZlVG9vbHMiLCJleHBlcmltZW50YWxfcHJlcGFyZVN0ZXAiLCJwcmVwYXJlU3RlcCIsImV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbCIsImV4cGVyaW1lbnRhbF9kb3dubG9hZCIsIl9pbnRlcm5hbCIsImdlbmVyYXRlSWQyIiwib25TdGVwRmluaXNoIiwib25GaW5pc2giLCJzdGVwVGltZW91dE1zIiwic3RlcEFib3J0Q29udHJvbGxlciIsIm1lcmdlZEFib3J0U2lnbmFsIiwiQWJvcnRTaWduYWwiLCJjYWxsU2V0dGluZ3MiLCJoZWFkZXJzV2l0aFVzZXJBZ2VudCIsImJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiaW5pdGlhbFByb21wdCIsImluaXRpYWxNZXNzYWdlcyIsImxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzIiwidG9vbEFwcHJvdmFsIiwidG9vbE91dHB1dHMiLCJleGVjdXRlVG9vbHMiLCJ0b29sQ29udGVudCIsIm91dHB1dDIiLCJtb2RlbE91dHB1dCIsIm9wZW5haSIsInByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzIiwiY2FsbFNldHRpbmdzMiIsImN1cnJlbnRNb2RlbFJlc3BvbnNlIiwiY2xpZW50VG9vbENhbGxzIiwiY2xpZW50VG9vbE91dHB1dHMiLCJwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMiLCJNYXAiLCJzdGVwVGltZW91dElkIiwic2V0VGltZW91dCIsInN0ZXBJbnB1dE1lc3NhZ2VzIiwicHJlcGFyZVN0ZXBSZXN1bHQiLCJzdGVwTnVtYmVyIiwic3RlcE1vZGVsIiwicHJvbXB0TWVzc2FnZXMiLCJzdGVwVG9vbENob2ljZSIsInN0ZXBUb29scyIsIl9hMTgiLCJzcGFuMiIsIl9hMTkiLCJfYjIiLCJfYzIiLCJfZDIiLCJfZTIiLCJfZjIiLCJfZzIiLCJfaDIiLCJzdGVwUHJvdmlkZXJPcHRpb25zIiwicmVzcG9uc2VEYXRhIiwidGltZXN0YW1wIiwiYm9keSIsImFzVG9vbENhbGxzIiwidG9JU09TdHJpbmciLCJzdGVwVG9vbENhbGxzIiwidG9vbEFwcHJvdmFsUmVxdWVzdHMiLCJvbklucHV0QXZhaWxhYmxlIiwiaW52YWxpZFRvb2xDYWxscyIsInN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzIiwiaGFzUmVzdWx0SW5SZXNwb25zZSIsInNldCIsImRlbGV0ZSIsInN0ZXBDb250ZW50IiwiYXNDb250ZW50IiwidmFsdWVzIiwiY3VycmVudFN0ZXBSZXN1bHQiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJjbGVhclRpbWVvdXQiLCJsYXN0U3RlcCIsInRvdGFsVXNhZ2UiLCJ0b3RhbFVzYWdlMiIsInN0ZXAiLCJyZXNvbHZlZE91dHB1dCIsIm91dHB1dFNwZWNpZmljYXRpb24iLCJEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0IiwiX291dHB1dCIsImZpbmFsU3RlcCIsImNvbnRlbnRQYXJ0cyIsImZpbmQiLCJ0b29sQ2FsbDIiLCJpc0Vycm9yIiwiZ2V0RXJyb3JNZXNzYWdlNyIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMiIsImNyZWF0ZUlkR2VuZXJhdG9yMiIsIkRlbGF5ZWRQcm9taXNlIiwiaXNBYm9ydEVycm9yMiIsInByZXBhcmVIZWFkZXJzIiwiZGVmYXVsdEhlYWRlcnMiLCJIZWFkZXJzIiwiaGFzIiwiY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlIiwidGV4dFN0cmVhbSIsIlJlc3BvbnNlIiwiVGV4dEVuY29kZXJTdHJlYW0iLCJ3cml0ZVRvU2VydmVyUmVzcG9uc2UiLCJ3cml0ZUhlYWQiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJyZWFkIiwiZG9uZSIsImNhbkNvbnRpbnVlIiwid3JpdGUiLCJyZXNvbHZlMyIsInBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSIsIkpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSIsImZsdXNoIiwiVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUyIsImNvbm5lY3Rpb24iLCJjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSIsImNvbnN1bWVTc2VTdHJlYW0iLCJzc2VTdHJlYW0iLCJzdHJlYW0xIiwic3RyZWFtMiIsInRlZSIsImdldFJlc3BvbnNlVUlNZXNzYWdlSWQiLCJvcmlnaW5hbE1lc3NhZ2VzIiwicmVzcG9uc2VNZXNzYWdlSWQiLCJ2YWxpZGF0ZVR5cGVzIiwiejciLCJsYXp5U2NoZW1hIiwidWlNZXNzYWdlQ2h1bmtTY2hlbWEiLCJzdHJpY3RPYmplY3QiLCJkZWx0YSIsImVycm9yVGV4dCIsImlucHV0VGV4dERlbHRhIiwic291cmNlSWQiLCJ0cmFuc2llbnQiLCJtZXNzYWdlSWQiLCJtZXNzYWdlTWV0YWRhdGEiLCJpc0RhdGFVSU1lc3NhZ2VDaHVuayIsImlzRGF0YVVJUGFydCIsImlzVGV4dFVJUGFydCIsImlzRmlsZVVJUGFydCIsImlzUmVhc29uaW5nVUlQYXJ0IiwiaXNTdGF0aWNUb29sVUlQYXJ0IiwiaXNEeW5hbWljVG9vbFVJUGFydCIsImlzVG9vbFVJUGFydCIsImlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQiLCJnZXRTdGF0aWNUb29sTmFtZSIsImdldFRvb2xOYW1lIiwiZ2V0VG9vbE9yRHluYW1pY1Rvb2xOYW1lIiwiY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUiLCJhY3RpdmVUZXh0UGFydHMiLCJhY3RpdmVSZWFzb25pbmdQYXJ0cyIsInBhcnRpYWxUb29sQ2FsbHMiLCJwcm9jZXNzVUlNZXNzYWdlU3RyZWFtIiwibWVzc2FnZU1ldGFkYXRhU2NoZW1hIiwiZGF0YVBhcnRTY2hlbWFzIiwicnVuVXBkYXRlTWVzc2FnZUpvYiIsIm9uRXJyb3IiLCJvblRvb2xDYWxsIiwib25EYXRhIiwiZ2V0VG9vbEludm9jYXRpb24iLCJ0b29sSW52b2NhdGlvbnMiLCJ0b29sSW52b2NhdGlvbiIsImludm9jYXRpb24iLCJ1cGRhdGVUb29sUGFydCIsInBhcnQyIiwiYW55T3B0aW9ucyIsImFueVBhcnQiLCJyYXdJbnB1dCIsImNhbGxQcm92aWRlck1ldGFkYXRhIiwidXBkYXRlRHluYW1pY1Rvb2xQYXJ0IiwidXBkYXRlTWVzc2FnZU1ldGFkYXRhIiwibWVyZ2VkTWV0YWRhdGEiLCJ0ZXh0UGFydCIsInJlYXNvbmluZ1BhcnQiLCJwYXJ0aWFsVG9vbENhbGwiLCJwYXJ0aWFsQXJncyIsImRhdGFDaHVuayIsImV4aXN0aW5nVUlQYXJ0IiwiY2h1bmtBcmciLCJoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2giLCJpc0Fib3J0ZWQiLCJpZEluamVjdGVkU3RyZWFtIiwic3RhcnRDaHVuayIsImpvYiIsImZpbmlzaENhbGxlZCIsImNhbGxPbkZpbmlzaCIsImlzQ29udGludWF0aW9uIiwicmVzcG9uc2VNZXNzYWdlIiwiY2FuY2VsIiwicGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UiLCJjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtIiwic291cmNlIiwiYXN5bmNJdGVyYXRvciIsImZpbmlzaGVkIiwiY2xlYW51cCIsImNhbmNlbFN0cmVhbSIsInJlbGVhc2VMb2NrIiwiZSIsIm5leHQiLCJyZXR1cm4iLCJ0aHJvdyIsImVyciIsImNvbnN1bWVTdHJlYW0iLCJjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSIsInJlamVjdCIsInByb21pc2UiLCJyZXMiLCJyZWoiLCJjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtIiwiaW5uZXJTdHJlYW1SZWFkZXJzIiwiaXNDbG9zZWQiLCJ3YWl0Rm9yTmV3U3RyZWFtIiwidGVybWluYXRlIiwiZm9yRWFjaCIsImNsb3NlIiwicHJvY2Vzc1B1bGwiLCJzaGlmdCIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyUGFyYW0iLCJwdWxsIiwiYWRkU3RyZWFtIiwiaW5uZXJTdHJlYW0iLCJwZXJmb3JtYW5jZSIsImdldEVycm9yTWVzc2FnZTYiLCJydW5Ub29sc1RyYW5zZm9ybWF0aW9uIiwiZ2VuZXJhdG9yU3RyZWFtIiwidG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyIiwidG9vbFJlc3VsdHNTdHJlYW0iLCJvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzIiwiU2V0IiwidG9vbElucHV0cyIsImNhbkNsb3NlIiwiZmluaXNoQ2h1bmsiLCJhdHRlbXB0Q2xvc2UiLCJmb3J3YXJkU3RyZWFtIiwidG9vbEV4ZWN1dGlvbklkIiwiYWRkIiwiY2F0Y2giLCJmaW5hbGx5IiwicGlwZVRvIiwiV3JpdGFibGVTdHJlYW0iLCJvcmlnaW5hbEdlbmVyYXRlSWQyIiwic3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF90cmFuc2Zvcm0iLCJpbmNsdWRlUmF3Q2h1bmtzIiwib25DaHVuayIsIm9uQWJvcnQiLCJub3cyIiwiY2h1bmtUaW1lb3V0TXMiLCJjaHVua0Fib3J0Q29udHJvbGxlciIsIkRlZmF1bHRTdHJlYW1UZXh0UmVzdWx0IiwidHJhbnNmb3JtcyIsImNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbSIsImZpcnN0VGV4dENodW5rSWQiLCJ0ZXh0Q2h1bmsiLCJ0ZXh0UHJvdmlkZXJNZXRhZGF0YSIsImxhc3RQdWJsaXNoZWRKc29uIiwicHVibGlzaFRleHRDaHVuayIsImN1cnJlbnRKc29uIiwiX3RvdGFsVXNhZ2UiLCJfZmluaXNoUmVhc29uIiwiX3Jhd0ZpbmlzaFJlYXNvbiIsIl9zdGVwcyIsInN0ZXBGaW5pc2giLCJyZWNvcmRlZENvbnRlbnQiLCJyZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMiLCJyZWNvcmRlZEZpbmlzaFJlYXNvbiIsInJlY29yZGVkUmF3RmluaXNoUmVhc29uIiwicmVjb3JkZWRUb3RhbFVzYWdlIiwicmVjb3JkZWRSZXF1ZXN0IiwicmVjb3JkZWRXYXJuaW5ncyIsInJlY29yZGVkU3RlcHMiLCJyb290U3BhbiIsImFjdGl2ZVRleHRDb250ZW50IiwiYWN0aXZlUmVhc29uaW5nQ29udGVudCIsImV2ZW50UHJvY2Vzc29yIiwiYWN0aXZlVGV4dCIsImFjdGl2ZVJlYXNvbmluZyIsInN0ZXBNZXNzYWdlcyIsInNlbGYiLCJzdGl0Y2hhYmxlU3RyZWFtIiwiY2xvc2VTdHJlYW0iLCJzdG9wU3RyZWFtIiwiYmFzZVN0cmVhbSIsInJvb3RTcGFuQXJnIiwiaW5pdGlhbFJlc3BvbnNlTWVzc2FnZXMiLCJsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMiLCJkZW5pZWRQcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyIsInRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciIsInRvb2xFeGVjdXRpb25TdGVwU3RyZWFtIiwicmVzdWx0MiIsImxvY2FsVG9vbENvbnRlbnQiLCJzdHJlYW1TdGVwIiwiY3VycmVudFN0ZXAiLCJpbmNsdWRlUmF3Q2h1bmtzMiIsImNodW5rVGltZW91dElkIiwicmVzZXRDaHVua1RpbWVvdXQiLCJjbGVhckNodW5rVGltZW91dCIsImNsZWFyU3RlcFRpbWVvdXQiLCJkb1N0cmVhbVNwYW4iLCJzdGFydFRpbWVzdGFtcE1zIiwiZG9TdHJlYW1TcGFuMiIsInN0cmVhbVdpdGhUb29sUmVzdWx0cyIsInN0ZXBSZXF1ZXN0Iiwic3RlcFRvb2xPdXRwdXRzIiwiYWN0aXZlVG9vbENhbGxUb29sTmFtZXMiLCJzdGVwRmluaXNoUmVhc29uIiwic3RlcFJhd0ZpbmlzaFJlYXNvbiIsInN0ZXBVc2FnZSIsInN0ZXBQcm92aWRlck1ldGFkYXRhIiwic3RlcEZpcnN0Q2h1bmsiLCJzdGVwUmVzcG9uc2UiLCJtc1RvRmlyc3RDaHVuayIsIm1zVG9GaW5pc2giLCJvbklucHV0U3RhcnQiLCJvbklucHV0RGVsdGEiLCJzdGVwVG9vbENhbGxzSnNvbiIsImNvbWJpbmVkVXNhZ2UiLCJ0b29sT3V0cHV0IiwiaGFzUmVzdWx0SW5TdGVwIiwidGVlU3RyZWFtIiwiZnVsbFN0cmVhbSIsImV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtIiwicGFydGlhbE91dHB1dFN0cmVhbSIsImVsZW1lbnRTdHJlYW0iLCJmdW5jdGlvbmFsaXR5IiwidG9VSU1lc3NhZ2VTdHJlYW0iLCJnZW5lcmF0ZU1lc3NhZ2VJZCIsInNlbmRSZWFzb25pbmciLCJzZW5kU291cmNlcyIsInNlbmRTdGFydCIsInNlbmRGaW5pc2giLCJpc0R5bmFtaWMiLCJtZXNzYWdlTWV0YWRhdGFWYWx1ZSIsInBhcnRUeXBlIiwic291cmNlVHlwZSIsImluaXQiLCJ0b1VJTWVzc2FnZVN0cmVhbVJlc3BvbnNlIiwidG9UZXh0U3RyZWFtUmVzcG9uc2UiLCJUb29sTG9vcEFnZW50IiwicHJlcGFyZUNhbGwiLCJiYXNlQ2FsbEFyZ3MiLCJwcmVwYXJlZENhbGxBcmdzIiwiaW5zdHJ1Y3Rpb25zIiwiY2FsbEFyZ3MiLCJnZW5lcmF0ZSIsImdlbmVyYXRlSWRGdW5jIiwiZ2V0RXJyb3JNZXNzYWdlOCIsImNyZWF0ZVVJTWVzc2FnZVN0cmVhbSIsIm9uZ29pbmdTdHJlYW1Qcm9taXNlcyIsImNvbnRyb2xsZXJBcmciLCJzYWZlRW5xdWV1ZSIsIndyaXRlciIsIm1lcmdlIiwic3RyZWFtQXJnIiwid2FpdEZvclN0cmVhbXMiLCJyZWFkVUlNZXNzYWdlU3RyZWFtIiwidGVybWluYXRlT25FcnJvciIsImhhc0Vycm9yZWQiLCJvdXRwdXRTdHJlYW0iLCJoYW5kbGVFcnJvciIsImlzTm9uTnVsbGFibGUiLCJjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzIiwibW9kZWxNZXNzYWdlcyIsImlnbm9yZUluY29tcGxldGVUb29sQ2FsbHMiLCJ0ZXh0UGFydHMiLCJhY2MiLCJjb252ZXJ0RGF0YVBhcnQiLCJibG9jayIsInByb2Nlc3NCbG9jayIsImRhdGFQYXJ0IiwidG9vbFBhcnRzIiwidG9vbFBhcnQiLCJUeXBlVmFsaWRhdGlvbkVycm9yMyIsImxhenlTY2hlbWEyIiwidmFsaWRhdGVUeXBlczIiLCJ6b2RTY2hlbWEyIiwiejgiLCJ1aU1lc3NhZ2VzU2NoZW1hIiwibmV2ZXIiLCJub25lbXB0eSIsInNhZmVWYWxpZGF0ZVVJTWVzc2FnZXMiLCJtZXRhZGF0YVNjaGVtYSIsImRhdGFTY2hlbWFzIiwidmFsaWRhdGVkTWVzc2FnZXMiLCJkYXRhUGFydHMiLCJkYXRhTmFtZSIsImRhdGFTY2hlbWEiLCJ2YWxpZGF0ZVVJTWVzc2FnZXMiLCJjcmVhdGVBZ2VudFVJU3RyZWFtIiwiYWdlbnQiLCJ1aU1lc3NhZ2VzIiwidWlNZXNzYWdlU3RyZWFtT3B0aW9ucyIsImNyZWF0ZUFnZW50VUlTdHJlYW1SZXNwb25zZSIsInBpcGVBZ2VudFVJU3RyZWFtVG9SZXNwb25zZSIsIndpdGhVc2VyQWdlbnRTdWZmaXgzIiwiZW1iZWQiLCJlbWJlZGRpbmciLCJkb0VtYmVkU3BhbiIsIm1vZGVsUmVzcG9uc2UiLCJkb0VtYmVkIiwiZW1iZWRkaW5nMiIsImVtYmVkZGluZ3MiLCJ0b2tlbnMiLCJOYU4iLCJlbWJlZGRpbmczIiwiRGVmYXVsdEVtYmVkUmVzdWx0Iiwid2l0aFVzZXJBZ2VudFN1ZmZpeDQiLCJzcGxpdEFycmF5IiwiYXJyYXkyIiwiY2h1bmtTaXplIiwiZW1iZWRNYW55IiwibWF4UGFyYWxsZWxDYWxscyIsIkluZmluaXR5IiwibWF4RW1iZWRkaW5nc1BlckNhbGwiLCJzdXBwb3J0c1BhcmFsbGVsQ2FsbHMiLCJlbWJlZGRpbmdzMiIsIndhcm5pbmdzMiIsInByb3ZpZGVyTWV0YWRhdGEyIiwiZW1iZWRkaW5nczMiLCJEZWZhdWx0RW1iZWRNYW55UmVzdWx0IiwidmFsdWVDaHVua3MiLCJwYXJhbGxlbENodW5rcyIsInBhcmFsbGVsQ2h1bmsiLCJyZXN1bHRzIiwicHJvdmlkZXJOYW1lIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheTQiLCJ3aXRoVXNlckFnZW50U3VmZml4NSIsImdlbmVyYXRlSW1hZ2UiLCJwcm9tcHRBcmciLCJuIiwibWF4SW1hZ2VzUGVyQ2FsbCIsImFzcGVjdFJhdGlvIiwibWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0IiwiaW52b2tlTW9kZWxNYXhJbWFnZXNQZXJDYWxsIiwiY2FsbENvdW50IiwiY2VpbCIsImNhbGxJbWFnZUNvdW50cyIsImZyb20iLCJfIiwicmVtYWluZGVyIiwiY2FsbEltYWdlQ291bnQiLCJtYXNrIiwibm9ybWFsaXplUHJvbXB0IiwiaW1hZ2VzIiwiY3VycmVudEVudHJ5IiwiaW1hZ2VzVmFsdWUiLCJEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCIsImlzRnVuY3Rpb24iLCJGdW5jdGlvbiIsInRvSW1hZ2VNb2RlbFYzRmlsZSIsImRhdGFDb250ZW50IiwidWludDhEYXRhMiIsInVpbnQ4RGF0YSIsImV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlIiwiY3JlYXRlSWRHZW5lcmF0b3IzIiwid2l0aFVzZXJBZ2VudFN1ZmZpeDYiLCJleHRyYWN0UmVhc29uaW5nQ29udGVudCIsImlzSlNPTkFycmF5IiwiaXNKU09OT2JqZWN0IiwiVHlwZVZhbGlkYXRpb25FcnJvcjQiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMiLCJhc1NjaGVtYTQiLCJzYWZlVmFsaWRhdGVUeXBlczQiLCJub1NjaGVtYU91dHB1dFN0cmF0ZWd5IiwidmFsaWRhdGVQYXJ0aWFsUmVzdWx0IiwidGV4dERlbHRhIiwidmFsaWRhdGVGaW5hbFJlc3VsdCIsImNyZWF0ZUVsZW1lbnRTdHJlYW0iLCJvYmplY3RPdXRwdXRTdHJhdGVneSIsImFycmF5T3V0cHV0U3RyYXRlZ3kiLCJsYXRlc3RPYmplY3QiLCJpc0ZpcnN0RGVsdGEiLCJpc0ZpbmFsRGVsdGEiLCJpbnB1dEFycmF5IiwicmVzdWx0QXJyYXkiLCJwdWJsaXNoZWRFbGVtZW50Q291bnQiLCJvcmlnaW5hbFN0cmVhbSIsImVudW1PdXRwdXRTdHJhdGVneSIsImVudW1WYWx1ZXMiLCJwb3NzaWJsZUVudW1WYWx1ZXMiLCJlbnVtVmFsdWUiLCJnZXRPdXRwdXRTdHJhdGVneSIsIkpTT05QYXJzZUVycm9yMiIsIlR5cGVWYWxpZGF0aW9uRXJyb3I1Iiwic2FmZVBhcnNlSlNPTjQiLCJwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0Iiwib3V0cHV0U3RyYXRlZ3kiLCJwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0V2l0aFJlcGFpciIsInJlcGFpclRleHQiLCJyZXBhaXJlZFRleHQiLCJ2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCIsInNjaGVtYU5hbWUiLCJzY2hlbWFEZXNjcmlwdGlvbiIsIm9yaWdpbmFsR2VuZXJhdGVJZDMiLCJnZW5lcmF0ZU9iamVjdCIsImV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0IiwiY3VycmVudERhdGUiLCJyZXN1bHRQcm92aWRlck1ldGFkYXRhIiwic3RhbmRhcmRpemVkUHJvbXB0IiwiZ2VuZXJhdGVSZXN1bHQiLCJyZWFzb25pbmcyIiwib2JqZWN0VGV4dCIsIkRlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCIsInRvSnNvblJlc3BvbnNlIiwiY3JlYXRlSWRHZW5lcmF0b3I0IiwiRGVsYXllZFByb21pc2UyIiwiY29zaW5lU2ltaWxhcml0eSIsInZlY3RvcjEiLCJ2ZWN0b3IyIiwidmVjdG9yMUxlbmd0aCIsInZlY3RvcjJMZW5ndGgiLCJtYWduaXR1ZGVTcXVhcmVkMSIsIm1hZ25pdHVkZVNxdWFyZWQyIiwiZG90UHJvZHVjdCIsInZhbHVlMSIsInZhbHVlMiIsInNxcnQiLCJnZXRUZXh0RnJvbURhdGFVcmwiLCJ3aW5kb3ciLCJhdG9iIiwiaXNEZWVwRXF1YWxEYXRhIiwib2JqMSIsIm9iajIiLCJnZXRUaW1lIiwia2V5czEiLCJrZXlzMiIsIlNlcmlhbEpvYkV4ZWN1dG9yIiwicXVldWUiLCJpc1Byb2Nlc3NpbmciLCJwcm9jZXNzUXVldWUiLCJydW4iLCJkZWxheUZ1bmN0aW9uIiwic2ltdWxhdGVSZWFkYWJsZVN0cmVhbSIsImNodW5rcyIsImNodW5rRGVsYXlJbk1zIiwiZGVsYXkyIiwib3JpZ2luYWxHZW5lcmF0ZUlkNCIsInN0cmVhbU9iamVjdCIsIkRlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQiLCJfb2JqZWN0IiwiX3VzYWdlIiwiX3Byb3ZpZGVyTWV0YWRhdGEiLCJfd2FybmluZ3MiLCJfcmVxdWVzdCIsIl9yZXNwb25zZSIsImNhbGxPcHRpb25zIiwidHJhbnNmb3JtZXIiLCJhY2N1bXVsYXRlZFRleHQiLCJmdWxsUmVzcG9uc2UiLCJsYXRlc3RPYmplY3RKc29uIiwiaXNGaXJzdENodW5rIiwidHJhbnNmb3JtZWRTdHJlYW0iLCJjdXJyZW50T2JqZWN0SnNvbiIsInBhcnNlU3RhdGUiLCJmaW5hbFVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsImVycm9yMiIsInBhcnRpYWxPYmplY3RTdHJlYW0iLCJ3aXRoVXNlckFnZW50U3VmZml4NyIsIkRlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUiLCJmb3JtYXQiLCJtZWRpYVR5cGVQYXJ0cyIsImdlbmVyYXRlU3BlZWNoIiwidm9pY2UiLCJvdXRwdXRGb3JtYXQiLCJzcGVlZCIsImxhbmd1YWdlIiwicmVzb2x2ZWRNb2RlbCIsImF1ZGlvIiwiRGVmYXVsdFNwZWVjaFJlc3VsdCIsInBydW5lTWVzc2FnZXMiLCJlbXB0eU1lc3NhZ2VzIiwibWVzc2FnZUluZGV4Iiwia2VlcExhc3RNZXNzYWdlc0NvdW50Iiwia2VwdFRvb2xDYWxsSWRzIiwia2VwdEFwcHJvdmFsSWRzIiwidG9vbENhbGxJZFRvVG9vbE5hbWUiLCJhcHByb3ZhbElkVG9Ub29sTmFtZSIsIm9yaWdpbmFsRGVsYXkiLCJJbnZhbGlkQXJndW1lbnRFcnJvcjIiLCJDSFVOS0lOR19SRUdFWFBTIiwid29yZCIsImxpbmUiLCJzbW9vdGhTdHJlYW0iLCJjaHVua2luZyIsImRldGVjdENodW5rIiwic2VnbWVudCIsInNlZ21lbnRlciIsImJ1ZmZlciIsIml0ZXJhdG9yIiwiZmlyc3QiLCJtYXRjaCIsImNodW5raW5nUmVnZXgiLCJhcmd1bWVudCIsImV4ZWMiLCJmbHVzaEJ1ZmZlciIsImRlZmF1bHRFbWJlZGRpbmdTZXR0aW5nc01pZGRsZXdhcmUiLCJ0cmFuc2Zvcm1QYXJhbXMiLCJwYXJhbXMiLCJkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlIiwiZGVmYXVsdFRyYW5zZm9ybSIsInJlcGxhY2UiLCJleHRyYWN0SnNvbk1pZGRsZXdhcmUiLCJoYXNDdXN0b21UcmFuc2Zvcm0iLCJ3cmFwR2VuZXJhdGUiLCJyZXN0IiwidHJhbnNmb3JtZWRDb250ZW50Iiwid3JhcFN0cmVhbSIsInRleHRCbG9ja3MiLCJTVUZGSVhfQlVGRkVSX1NJWkUiLCJzdGFydEV2ZW50IiwicGhhc2UiLCJwcmVmaXhTdHJpcHBlZCIsInByZWZpeE1hdGNoIiwidG9TdHJlYW0iLCJyZW1haW5pbmciLCJ0cmltRW5kIiwiZ2V0UG90ZW50aWFsU3RhcnRJbmRleCIsInNlYXJjaGVkVGV4dCIsImRpcmVjdEluZGV4IiwiaW5kZXhPZiIsInN1ZmZpeCIsImV4dHJhY3RSZWFzb25pbmdNaWRkbGV3YXJlIiwidGFnTmFtZSIsInNlcGFyYXRvciIsInN0YXJ0V2l0aFJlYXNvbmluZyIsIm9wZW5pbmdUYWciLCJjbG9zaW5nVGFnIiwicmVnZXhwIiwibWF0Y2hlcyIsIm1hdGNoQWxsIiwidGV4dFdpdGhvdXRSZWFzb25pbmciLCJiZWZvcmVNYXRjaCIsImFmdGVyTWF0Y2giLCJyZWFzb25pbmdFeHRyYWN0aW9ucyIsImRlbGF5ZWRUZXh0U3RhcnQiLCJpc0ZpcnN0UmVhc29uaW5nIiwiaXNGaXJzdFRleHQiLCJhZnRlclN3aXRjaCIsImlzUmVhc29uaW5nIiwiaWRDb3VudGVyIiwidGV4dElkIiwiYWN0aXZlRXh0cmFjdGlvbiIsInB1Ymxpc2giLCJuZXh0VGFnIiwic3RhcnRJbmRleCIsImZvdW5kRnVsbE1hdGNoIiwic2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlIiwic2ltdWxhdGVkU3RyZWFtIiwiU3RyaW5nIiwiZGVmYXVsdEZvcm1hdEV4YW1wbGUiLCJleGFtcGxlIiwiYWRkVG9vbElucHV0RXhhbXBsZXNNaWRkbGV3YXJlIiwicmVtb3ZlIiwidHJhbnNmb3JtZWRUb29scyIsImZvcm1hdHRlZEV4YW1wbGVzIiwiZXhhbXBsZXNTZWN0aW9uIiwidG9vbERlc2NyaXB0aW9uIiwid3JhcExhbmd1YWdlTW9kZWwiLCJtaWRkbGV3YXJlIiwibWlkZGxld2FyZUFyZyIsInByb3ZpZGVySWQiLCJyZXZlcnNlIiwid3JhcHBlZE1vZGVsIiwiZG9XcmFwIiwib3ZlcnJpZGVQcm92aWRlciIsIm92ZXJyaWRlTW9kZWxJZCIsIm92ZXJyaWRlU3VwcG9ydGVkVXJscyIsImRvVHJhbnNmb3JtIiwidHJhbnNmb3JtZWRQYXJhbXMiLCJ3cmFwRW1iZWRkaW5nTW9kZWwiLCJkb1dyYXAyIiwid3JhcEVtYmVkIiwib3ZlcnJpZGVNYXhFbWJlZGRpbmdzUGVyQ2FsbCIsIm92ZXJyaWRlU3VwcG9ydHNQYXJhbGxlbENhbGxzIiwid3JhcEltYWdlTW9kZWwiLCJkb1dyYXAzIiwib3ZlcnJpZGVNYXhJbWFnZXNQZXJDYWxsIiwibWF4SW1hZ2VzUGVyQ2FsbFJhdyIsImFzUHJvdmlkZXJWMyIsInYyUHJvdmlkZXIiLCJ0ZXh0RW1iZWRkaW5nTW9kZWwiLCJyZXJhbmtpbmdNb2RlbCIsIndyYXBQcm92aWRlciIsImxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlIiwiaW1hZ2VNb2RlbE1pZGRsZXdhcmUiLCJwcm92aWRlclYzIiwiTm9TdWNoTW9kZWxFcnJvcjIiLCJjdXN0b21Qcm92aWRlciIsImxhbmd1YWdlTW9kZWxzIiwiZW1iZWRkaW5nTW9kZWxzIiwiaW1hZ2VNb2RlbHMiLCJ0cmFuc2NyaXB0aW9uTW9kZWxzIiwic3BlZWNoTW9kZWxzIiwicmVyYW5raW5nTW9kZWxzIiwiZmFsbGJhY2tQcm92aWRlciIsImZhbGxiYWNrUHJvdmlkZXJBcmciLCJtb2RlbFR5cGUiLCJleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIiLCJBSVNES0Vycm9yMjEiLCJOb1N1Y2hNb2RlbEVycm9yMyIsIm5hbWUxNiIsIm1hcmtlcjE2Iiwic3ltYm9sMTYiLCJfYTE2IiwiTm9TdWNoUHJvdmlkZXJFcnJvciIsImF2YWlsYWJsZVByb3ZpZGVycyIsImVycm9yTmFtZSIsIk5vU3VjaE1vZGVsRXJyb3I0IiwiY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSIsInByb3ZpZGVycyIsInJlZ2lzdHJ5IiwiRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkiLCJyZWdpc3RlclByb3ZpZGVyIiwiZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkiLCJnZXRQcm92aWRlciIsInNwbGl0SWQiLCJyZXJhbmsiLCJkb2N1bWVudHMiLCJxdWVyeSIsInRvcE4iLCJEZWZhdWx0UmVyYW5rUmVzdWx0Iiwib3JpZ2luYWxEb2N1bWVudHMiLCJyYW5raW5nIiwiZG9jdW1lbnRzVG9TZW5kIiwiZG9jdW1lbnQiLCJkb1JlcmFua1NwYW4iLCJkb1JlcmFuayIsInJhbmtpbmcyIiwicmFua2luZzMiLCJvcmlnaW5hbEluZGV4Iiwic2NvcmUiLCJyZWxldmFuY2VTY29yZSIsInJlcmFua2VkRG9jdW1lbnRzIiwid2l0aFVzZXJBZ2VudFN1ZmZpeDgiLCJBSVNES0Vycm9yMjIiLCJOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciIsInRyYW5zY3JpYmUiLCJhdWRpb0RhdGEiLCJEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCIsInNlZ21lbnRzIiwiZHVyYXRpb25JblNlY29uZHMiLCJ3aXRoVXNlckFnZW50U3VmZml4OSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDIiLCJwcm9jZXNzVGV4dFN0cmVhbSIsIm9uVGV4dFBhcnQiLCJUZXh0RGVjb2RlclN0cmVhbSIsImdldE9yaWdpbmFsRmV0Y2giLCJjYWxsQ29tcGxldGlvbkFwaSIsImFwaSIsImNyZWRlbnRpYWxzIiwic3RyZWFtUHJvdG9jb2wiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEVycm9yIiwic2V0QWJvcnRDb250cm9sbGVyIiwiZmV0Y2gyIiwiYWJvcnRDb250cm9sbGVyIiwibWV0aG9kIiwic3RyZWFtUGFydCIsImdlbmVyYXRlSWRGdW5jMiIsImNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMiLCJGaWxlTGlzdCIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZWFkZXJFdmVudCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwicGFyc2VKc29uRXZlbnRTdHJlYW0yIiwibm9ybWFsaXplSGVhZGVycyIsInJlc29sdmUyIiwid2l0aFVzZXJBZ2VudFN1ZmZpeDEwIiwiZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MyIsIkh0dHBDaGF0VHJhbnNwb3J0IiwicHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3QiLCJwcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0Iiwic2VuZE1lc3NhZ2VzIiwicmVzb2x2ZWRCb2R5IiwicmVzb2x2ZWRIZWFkZXJzIiwicmVzb2x2ZWRDcmVkZW50aWFscyIsImJhc2VIZWFkZXJzIiwicHJlcGFyZWRSZXF1ZXN0IiwiY2hhdElkIiwicmVxdWVzdE1ldGFkYXRhIiwidHJpZ2dlciIsInByb2Nlc3NSZXNwb25zZVN0cmVhbSIsInJlY29ubmVjdFRvU3RyZWFtIiwiRGVmYXVsdENoYXRUcmFuc3BvcnQiLCJBYnN0cmFjdENoYXQiLCJ0cmFuc3BvcnQiLCJzZW5kQXV0b21hdGljYWxseVdoZW4iLCJhY3RpdmVSZXNwb25zZSIsImpvYkV4ZWN1dG9yIiwic2VuZE1lc3NhZ2UiLCJtYWtlUmVxdWVzdCIsInVpTWVzc2FnZSIsImZpbGVQYXJ0cyIsImZpbmRJbmRleCIsIm0iLCJyZXBsYWNlTWVzc2FnZSIsInB1c2hNZXNzYWdlIiwicmVnZW5lcmF0ZSIsInJlc3VtZVN0cmVhbSIsImNsZWFyRXJyb3IiLCJhZGRUb29sQXBwcm92YWxSZXNwb25zZSIsInVwZGF0ZVBhcnQiLCJhZGRUb29sT3V0cHV0IiwiYWRkVG9vbFJlc3VsdCIsInN0b3AiLCJpc0Fib3J0IiwiaXNEaXNjb25uZWN0Iiwic25hcHNob3QiLCJyZWNvbm5lY3QiLCJyZXBsYWNlTGFzdE1lc3NhZ2UiLCJUeXBlRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsIkRpcmVjdENoYXRUcmFuc3BvcnQiLCJhZ2VudE9wdGlvbnMiLCJfb3B0aW9ucyIsImxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhBcHByb3ZhbFJlc3BvbnNlcyIsImxhc3RTdGVwU3RhcnRJbmRleCIsImxhc3RJbmRleCIsImxhc3RTdGVwVG9vbEludm9jYXRpb25zIiwibGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aFRvb2xDYWxscyIsInRyYW5zZm9ybVRleHRUb1VpTWVzc2FnZVN0cmVhbSIsIlRleHRTdHJlYW1DaGF0VHJhbnNwb3J0IiwiRXhwZXJpbWVudGFsX0FnZW50IiwiT3V0cHV0IiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlU3BlZWNoIiwiZXhwZXJpbWVudGFsX3RyYW5zY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;